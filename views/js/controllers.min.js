/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 * 
 * 
 */

//@see http://forge.taotesting.com/projects/tao/wiki/Front_js
define('taoQtiTest/controller/routes',[],function(){
    'use strict';

    return {
        'Creator': {
            'css': 'creator', 
            'actions': {
                'index' : 'controller/creator/creator'
            }
        }
    };
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technlogies SA
 *
 */

/**
 *
 * Defines the test creator areas
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/controller/creator/areaBroker',[
    'lodash',
    'core/areaBroker'
], function (_, areaBroker) {
    'use strict';

    var requireAreas = [
        'creator',
        'itemSelectorPanel',
        'contentCreatorPanel',
        'propertyPanel',
        'elementPropertyPanel'
    ];

    /**
     * Creates an area broker with the required areas for the item creator
     *
     * @see core/areaBroker
     *
     * @param {jQueryElement|HTMLElement|String} $container - the main container
     * @param {Object} mapping - keys are the area names, values are jQueryElement
     * @returns {broker} the broker
     * @throws {TypeError} without a valid container
     */
    return _.partial(areaBroker, requireAreas);

});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * The BaseType enumeration (port of \qtism\common\enums\BaseType).
 *
 * From IMS QTI:
 *
 * A base-type is simply a description of a set of atomic values (atomic to this specification).
 * Note that several of the baseTypes used to define the runtime data model have identical
 * definitions to those of the basic data types used to define the values for attributes
 * in the specification itself. The use of an enumeration to define the set of baseTypes
 * used in the runtime model, as opposed to the use of classes with similar names, is
 * designed to help distinguish between these two distinct levels of modelling.
 *
 * @author Jérôme Bogaerts <jerome@taotesting.com>
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/baseType',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * The list of QTI base types
     * @type {Object}
     */
    var baseTypeEnum = {
        /**
         * From IMS QTI:
         *
         * The set of identifier values is the same as the set of values
         * defined by the identifier class.
         *
         * @type {Number}
         */
        IDENTIFIER: 0,

        /**
         * From IMS QTI:
         *
         * The set of boolean values is the same as the set of values defined
         * by the boolean class.
         *
         * @type {Number}
         */
        BOOLEAN: 1,

        /**
         * From IMS QTI:
         *
         * The set of integer values is the same as the set of values defined
         * by the integer class.
         *
         * @type {Number}
         */
        INTEGER: 2,

        /**
         * From IMS QTI:
         *
         * The set of float values is the same as the set of values defined by the
         * float class.
         *
         * @type {Number}
         */
        FLOAT: 3,

        /**
         * From IMS QTI:
         *
         * The set of string values is the same as the set of values defined by the
         * string class.
         *
         * @type {Number}
         */
        STRING: 4,

        /**
         * From IMS QTI:
         *
         * A point value represents an integer tuple corresponding to a graphic point.
         * The two integers correspond to the horizontal (x-axis) and vertical (y-axis)
         * positions respectively. The up/down and left/right senses of the axes are
         * context dependent.
         *
         * @type {Number}
         */
        POINT: 5,

        /**
         * From IMS QTI:
         *
         * A pair value represents a pair of identifiers corresponding to an association
         * between two objects. The association is undirected so (A,B) and (B,A) are equivalent.
         *
         * @type {Number}
         */
        PAIR: 6,

        /**
         * From IMS QTI:
         *
         * A directedPair value represents a pair of identifiers corresponding to a directed
         * association between two objects. The two identifiers correspond to the source
         * and destination objects.
         *
         * @type {Number}
         */
        DIRECTED_PAIR: 7,

        /**
         * From IMS QTI:
         *
         * A duration value specifies a distance (in time) between two time points.
         * In other words, a time period as defined by [ISO8601], but represented as
         * a single float that records time in seconds. Durations may have a fractional
         * part. Durations are represented using the xsd:double datatype rather than
         * xsd:dateTime for convenience and backward compatibility.
         *
         * @type {Number}
         */
        DURATION: 8,

        /**
         * From IMS QTI:
         *
         * A file value is any sequence of octets (bytes) qualified by a content-type and an
         * optional filename given to the file (for example, by the candidate when uploading
         * it as part of an interaction). The content type of the file is one of the MIME
         * types defined by [RFC2045].
         *
         * @type {Number}
         */
        FILE: 9,

        /**
         * From IMS QTI:
         *
         * A URI value is a Uniform Resource Identifier as defined by [URI].
         *
         * @type {Number}
         */
        URI: 10,

        /**
         * From IMS QTI:
         *
         * An intOrIdentifier value is the union of the integer baseType and
         * the identifier baseType.
         *
         * @type {Number}
         */
        INT_OR_IDENTIFIER: 11,

        /**
         * In qtism, we consider an extra 'coords' baseType.
         *
         * @type {Number}
         */
        COORDS: 12,

        /**
         * Express that the operands can have any BaseType from the BaseType enumeration and
         * can be different.
         *
         * @type {Number}
         */
        ANY: 12,

        /**
         * Express that all the operands must have the same
         * baseType.
         *
         * @type {Number}
         */
        SAME: 13
    };

    var baseTypeHelper = _({
        /**
         * Gets the the list of QTI base types
         * @returns {Object}
         */
        asArray: function asArray() {
            return baseTypeEnum;
        },

        /**
         * Gets a valid type or the default
         * @param {String|Number} type
         * @param {String|Number} [defaultType]
         * @returns {*}
         */
        getValid: function getValid(type, defaultType) {
            if (_.isFinite(type)) {
                if (!baseTypeHelper.getNameByConstant(type)) {
                    type = false;
                }
            } else {
                type = baseTypeHelper.getConstantByName(type);
            }

            if (false === type) {
                if (!_.isUndefined(defaultType) && defaultType !== -1) {
                    type = baseTypeHelper.getValid(defaultType, -1);
                } else {
                    type = -1;
                }
            }

            return type;
        },

        /**
         * Adjusts a value with respect to the type
         * @param {String|Number} type
         * @param {*} value
         * @returns {*}
         */
        getValue: function getValue(type, value) {
            if (_.isString(type)) {
                type = baseTypeHelper.getConstantByName(type);
            }

            switch (type) {
                case baseTypeEnum.URI:
                case baseTypeEnum.STRING:
                case baseTypeEnum.IDENTIFIER:
                    return value + '';

                case baseTypeEnum.BOOLEAN:
                    if (_.isString(value)) {
                        switch (value.toLowerCase()) {
                            case 'true':
                                return true;
                            case 'false':
                                return false;
                        }
                    }
                    return !!value;

                case baseTypeEnum.INTEGER:
                    return parseInt(value, 10) || 0;

                case baseTypeEnum.FLOAT:
                    return parseFloat(value) || 0;

                case baseTypeEnum.INT_OR_IDENTIFIER:
                    if (!_.isNaN(parseInt(value, 10))) {
                        return parseInt(value, 10) || 0;
                    } else {
                        return '' + value;
                    }
            }

            return value;
        },

        /**
         * Get a constant value from the BaseType enumeration by baseType name.
         *
         * * 'identifier' -> baseTypes.IDENTIFIER
         * * 'boolean' -> baseTypes.BOOLEAN
         * * 'integer' -> baseTypes.INTEGER
         * * 'float' -> baseTypes.FLOAT
         * * 'string' -> baseTypes.STRING
         * * 'point' -> baseTypes.POINT
         * * 'pair' -> baseTypes.PAIR
         * * 'directedPair' -> baseTypes.DIRECTED_PAIR
         * * 'duration' -> baseTypes.DURATION
         * * 'file' -> baseTypes.FILE
         * * 'uri' -> baseTypes.URI
         * * 'intOrIdentifier' -> baseTypes.INT_OR_IDENTIFIER
         * * extra 'coords' -> baseTypes.COORDS
         *
         * @param {String} name The baseType name.
         * @return {Number|Boolean} The related enumeration value or `false` if the name could not be resolved.
         */
        getConstantByName: function getConstantByName(name) {
            switch (String(name).trim().toLowerCase()) {
                case 'identifier':
                    return baseTypeEnum.IDENTIFIER;

                case 'boolean':
                    return baseTypeEnum.BOOLEAN;

                case 'integer':
                    return baseTypeEnum.INTEGER;

                case 'float':
                    return baseTypeEnum.FLOAT;

                case 'string':
                    return baseTypeEnum.STRING;

                case 'point':
                    return baseTypeEnum.POINT;

                case 'pair':
                    return baseTypeEnum.PAIR;

                case 'directedpair':
                    return baseTypeEnum.DIRECTED_PAIR;

                case 'duration':
                    return baseTypeEnum.DURATION;

                case 'file':
                    return baseTypeEnum.FILE;

                case 'uri':
                    return baseTypeEnum.URI;

                case 'intoridentifier':
                    return baseTypeEnum.INT_OR_IDENTIFIER;

                case 'coords':
                    return baseTypeEnum.COORDS;

                case 'any':
                    return baseTypeEnum.ANY;

                case 'same':
                    return baseTypeEnum.SAME;

                default:
                    return false;
            }
        },

        /**
         * Get the QTI name of a BaseType.
         *
         * @param {Number} constant A constant value from the BaseType enumeration.
         * @param {Boolean} [operator] A flag that allow to switch between operator an value types to prevent duplicate name issue
         * @return {String|Boolean} The QTI name or false if not match.
         */
        getNameByConstant: function getNameByConstant(constant, operator) {
            switch (constant) {
                case baseTypeEnum.IDENTIFIER:
                    return 'identifier';

                case baseTypeEnum.BOOLEAN:
                    return 'boolean';

                case baseTypeEnum.INTEGER:
                    return 'integer';

                case baseTypeEnum.FLOAT:
                    return 'float';

                case baseTypeEnum.STRING:
                    return 'string';

                case baseTypeEnum.POINT:
                    return 'point';

                case baseTypeEnum.PAIR:
                    return 'pair';

                case baseTypeEnum.DIRECTED_PAIR:
                    return 'directedPair';

                case baseTypeEnum.DURATION:
                    return 'duration';

                case baseTypeEnum.FILE:
                    return 'file';

                case baseTypeEnum.URI:
                    return 'uri';

                case baseTypeEnum.INT_OR_IDENTIFIER:
                    return 'intOrIdentifier';

                case baseTypeEnum.COORDS:
                case baseTypeEnum.ANY:
                    if (operator) {
                        return 'any';
                    } else {
                        return 'coords';
                    }

                case baseTypeEnum.SAME:
                    return 'same';

                default:
                    return false;
            }
        }
    }).assign(baseTypeEnum).value();

    return baseTypeHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * The Cardinality enumeration (port of \qtism\common\enums\Cardinality).
 *
 * From IMS QTI:
 *
 * An expression or itemVariable can either be single-valued or multi-valued. A multi-valued
 * expression (or variable) is called a container. A container contains a list of values,
 * this list may be empty in which case it is treated as NULL. All the values in a multiple
 * or ordered container are drawn from the same value set, however, containers may contain
 * multiple occurrences of the same value. In other words, [A,B,B,C] is an acceptable value
 * for a container. A container with cardinality multiple and value [A,B,C] is equivalent
 * to a similar one with value [C,B,A] whereas these two values would be considered distinct
 * for containers with cardinality ordered. When used as the value of a response variable
 * this distinction is typified by the difference between selecting choices in a multi-response
 * multi-choice task and ranking choices in an order objects task. In the language of [ISO11404]
 * a container with multiple cardinality is a "bag-type", a container with ordered cardinality
 * is a "sequence-type" and a container with record cardinality is a "record-type".
 *
 * The record container type is a special container that contains a set of independent values
 * each identified by its own identifier and having its own base-type. This specification
 * does not make use of the record type directly however it is provided to enable
 * customInteractions to manipulate more complex responses and customOperators to
 * return more complex values, in addition to the use for detailed information about
 * numeric responses described in the stringInteraction abstract class.
 *
 * @author Jérôme Bogaerts <jerome@taotesting.com>
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/cardinality',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * The list of QTI cardinalities
     * @type {Object}
     */
    var cardinalityEnum = {
        /**
         * Single term cardinality
         *
         * @type {Number}
         */
        SINGLE: 0,

        /**
         * Multiple terms cardinality
         *
         * @type {Number}
         */
        MULTIPLE: 1,

        /**
         * Ordered terms cardinality
         *
         * @type {Number}
         */
        ORDERED: 2,

        /**
         * Record term cardinality
         *
         * @type {Number}
         */
        RECORD: 3,

        /**
         * Express that all the expressions involved in an operator have
         * the same cardinality.
         *
         * @type {Number}
         */
        SAME: 4,

        /**
         * Express that all the expressions involved in an operator may
         * have any cardinality.
         *
         * @type {Number}
         */
        ANY: 5
    };

    var cardinalityHelper = _({
        /**
         * Gets the the list of QTI cardinalities
         * @returns {Object}
         */
        asArray: function asArray() {
            return cardinalityEnum;
        },

        /**
         * Gets a valid cardinality or the default
         * @param {String|Number} cardinality
         * @param {String|Number} [defaultCardinality]
         * @returns {*}
         */
        getValid: function getValid(cardinality, defaultCardinality) {
            if (_.isFinite(cardinality)) {
                if (!cardinalityHelper.getNameByConstant(cardinality)) {
                    cardinality = false;
                }
            } else {
                cardinality = cardinalityHelper.getConstantByName(cardinality);
            }

            if (false === cardinality) {
                if (!_.isUndefined(defaultCardinality) && defaultCardinality !== cardinalityEnum.SINGLE) {
                    cardinality = cardinalityHelper.getValid(defaultCardinality, cardinalityEnum.SINGLE);
                } else {
                    cardinality = cardinalityEnum.SINGLE;
                }
            }

            return cardinality;
        },

        /**
         * Get a constant value from its name.
         *
         * @param {String} name The name of the constant, as per QTI spec.
         * @return {Number|Boolean} The constant value or `false` if not found.
         */
        getConstantByName: function getConstantByName(name) {
            switch (String(name).trim().toLowerCase()) {
                case 'single':
                    return cardinalityEnum.SINGLE;

                case 'multiple':
                    return cardinalityEnum.MULTIPLE;

                case 'ordered':
                    return cardinalityEnum.ORDERED;

                case 'record':
                    return cardinalityEnum.RECORD;

                case 'same':
                    return cardinalityEnum.SAME;

                case 'any':
                    return cardinalityEnum.ANY;

                default:
                    return false;
            }
        },

        /**
         * Get the name of a constant from its value.
         *
         * @param {Number} constant The constant value to search the name for.
         * @return {String|Boolean} The name of the constant or false if not found.
         */
        getNameByConstant: function getNameByConstant(constant) {
            switch (constant) {
                case cardinalityEnum.SINGLE:
                    return 'single';

                case cardinalityEnum.MULTIPLE:
                    return 'multiple';

                case cardinalityEnum.ORDERED:
                    return 'ordered';

                case cardinalityEnum.RECORD:
                    return 'record';

                case cardinalityEnum.SAME:
                    return 'same';

                case cardinalityEnum.ANY:
                    return 'any';

                default:
                    return false;
            }
        }
    }).assign(cardinalityEnum).value();

    return cardinalityHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/outcomeValidator',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * The RegEx that validates outcome identifiers
     * @type {RegExp}
     */
    var identifierValidator = /^[a-zA-Z_][a-zA-Z0-9_\.-]*$/;

    /**
     * Checks the validity of an identifier
     * @param {String} identifier
     * @returns {Boolean}
     */
    function validateIdentifier(identifier) {
        return !!(identifier && _.isString(identifier) && identifierValidator.test(identifier));
    }

    /**
     * Checks if an object is a valid outcome
     * @param {Object} outcome
     * @param {Boolean} [checkIdentifier]
     * @param {String||String[]} [allowedTypes]
     * @returns {Boolean}
     */
    function validateOutcome(outcome, checkIdentifier, allowedTypes) {
        var validOutcome = _.isPlainObject(outcome) && validateIdentifier(outcome['qti-type']);
        var validIdentifier = !checkIdentifier || (outcome && validateIdentifier(outcome.identifier));

        if (allowedTypes) {
            allowedTypes = !_.isArray(allowedTypes) ? [allowedTypes] : allowedTypes;
            validOutcome =  validOutcome && _.indexOf(allowedTypes, outcome['qti-type']) >= 0;
        }

        return !!(validOutcome && validIdentifier);
    }

    /**
     * Checks if an array contains valid outcomes
     * @param {Array} outcomes
     * @param {Boolean} [checkIdentifier]
     * @param {String||String[]} [allowedTypes]
     * @returns {Boolean}
     */
    function validateOutcomes(outcomes, checkIdentifier, allowedTypes) {
        var valid = _.isArray(outcomes);
        _.forEach(outcomes, function(outcome) {
            if (!validateOutcome(outcome, checkIdentifier, allowedTypes)) {
                valid = false;
                return false;
            }
        });
        return valid;
    }

    return {
        validateIdentifier: validateIdentifier,
        validateOutcomes: validateOutcomes,
        validateOutcome: validateOutcome
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/qtiElement',[
    'lodash',
    'taoQtiTest/controller/creator/helpers/outcomeValidator'
], function (_, outcomeValidator) {
    'use strict';

    var qtiElementHelper = {
        /**
         * Creates a QTI element
         * @param {String} type - The QTI type of the element to create
         * @param {String|Object} [identifier] - An optional identifier, or a list of properties
         * @param {Object} [properties] - A list of additional properties
         * @returns {Object}
         * @throws {TypeError} if the type or the identifier is not valid
         */
        create: function create(type, identifier, properties) {
            var element = {
                'qti-type': type
            };

            if (!outcomeValidator.validateIdentifier(type)) {
                throw new TypeError('You must provide a valid QTI type!');
            }

            if (_.isPlainObject(identifier)) {
                properties = identifier;
                identifier = null;
            }

            if (identifier) {
                if (!outcomeValidator.validateIdentifier(identifier)) {
                    throw new TypeError('You must provide a valid identifier!');
                }
                element.identifier = identifier;
            }

            return _.assign(element, properties || {});
        },

        /**
         * Finds a QTI element in a collection, by its type.
         * The collection may also be a single object.
         * @param {Array|Object} collection
         * @param {Array|String} type
         * @returns {Object}
         */
        find: function find(collection, type) {
            var found = null;
            var types = forceArray(type);

            function checkType(qtiElement) {
                if (types.indexOf(qtiElement['qti-type']) >= 0) {
                    found = qtiElement;
                    return false;
                }
            }

            if (_.isArray(collection)) {
                _.forEach(collection, checkType);
            } else if (collection) {
                checkType(collection);
            }

            return found;
        },

        /**
         * Finds an element from a tree.
         * The path to the element is based on QTI types.
         * @param {Object} tree - The root of the tree from which get the property
         * @param {String|String[]} path - The path to the element, with QTI types separated by dot, like: "setOutcomeValue.gte.baseValue"
         * @param {String|String[]} nodeName - The name of the nodes that may contain subtrees
         * @returns {*}
         */
        lookupElement: function lookupElement(tree, path, nodeName) {
            var steps = _.isArray(path) ? path : path.split('.');
            var nodeNames = forceArray(nodeName);
            var len = steps.length;
            var i = 0;
            var key;

            while (tree && i < len) {
                tree = qtiElementHelper.find(tree, steps[i++]);
                if (tree && i < len) {
                    key = _.find(nodeNames, _.partial(_.has, tree));
                    tree = key && tree[key];
                }
            }

            return tree || null;
        },

        /**
         * Finds a property from a tree.
         * The path to the property is based on QTI types.
         * @param {Object} tree - The root of the tree from which get the property
         * @param {String|String[]} path - The path to the property, with QTI types separated by dot, like: "setOutcomeValue.gte.baseValue.value"
         * @param {String|String[]} nodeName - The name of the nodes that may contain subtrees
         * @returns {*}
         */
        lookupProperty: function lookupProperty(tree, path, nodeName) {
            var result = null;
            var steps = _.isArray(path) ? path : path.split('.');
            var propertyName = steps.pop();
            var element = qtiElementHelper.lookupElement(tree, steps, nodeName);

            if (element && element[propertyName]) {
                result = element[propertyName];
            }

            return result;
        }
    };

    /**
     * Ensures a value is an array
     * @param {*} value
     * @returns {Array}
     */
    function forceArray(value) {
        if (!value) {
            value = [];
        }
        if (!_.isArray(value)) {
            value = [value];
        }
        return value;
    }

    return qtiElementHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * Basic helper that is intended to manage outcomes inside a test model.
 *
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/outcome',[
    'lodash',
    'taoQtiTest/controller/creator/helpers/outcomeValidator',
    'taoQtiTest/controller/creator/helpers/qtiElement',
    'taoQtiTest/controller/creator/helpers/baseType',
    'taoQtiTest/controller/creator/helpers/cardinality'
], function (_, outcomeValidator, qtiElementHelper, baseTypeHelper, cardinalityHelper) {
    'use strict';

    var outcomeHelper = {
        /**
         * Gets a property from an outcome rule expression.
         * The path to the property is based on QTI types.
         * @param {Object} outcomeRule - The outcome rule from which get the property
         * @param {String|String[]} path - The path to the property, with QTI types separated by dot, like: "setOutcomeValue.gte.baseValue"
         * @returns {*}
         */
        getProcessingRuleExpression: function getProcessingRuleExpression(outcomeRule, path) {
            return qtiElementHelper.lookupElement(outcomeRule, path, ['expression', 'expressions']);
        },

        /**
         * Gets a property from an outcome rule expression.
         * The path to the property is based on QTI types.
         * @param {Object} outcomeRule - The outcome rule from which get the property
         * @param {String|String[]} path - The path to the property, with QTI types separated by dot, like: "setOutcomeValue.gte.baseValue.value"
         * @returns {*}
         */
        getProcessingRuleProperty: function getProcessingRuleProperty(outcomeRule, path) {
            return qtiElementHelper.lookupProperty(outcomeRule, path, ['expression', 'expressions']);
        },

        /**
         * Gets the identifier of an outcome
         * @param {Object|String} outcome
         * @returns {String}
         */
        getOutcomeIdentifier: function getOutcomeIdentifier(outcome) {
            return String(_.isObject(outcome) ? outcome.identifier : outcome);
        },

        /**
         * Gets the list of outcome declarations
         * @param {Object} testModel
         * @returns {Array}
         */
        getOutcomeDeclarations: function getOutcomeDeclarations(testModel) {
            var outcomes = testModel && testModel.outcomeDeclarations;
            return outcomes || [];
        },

        /**
         * Gets the list of outcome processing rules
         * @param {Object} testModel
         * @returns {Array}
         */
        getOutcomeProcessingRules: function getOutcomeProcessingRules(testModel) {
            var rules = testModel && testModel.outcomeProcessing && testModel.outcomeProcessing.outcomeRules;
            return rules || [];
        },

        /**
         * Applies a function on each outcome declarations
         * @param {Object} testModel
         * @param {Function} cb
         */
        eachOutcomeDeclarations: function eachOutcomeDeclarations(testModel, cb) {
            _.forEach(outcomeHelper.getOutcomeDeclarations(testModel), cb);
        },

        /**
         * Applies a function on each outcome processing rules. Does not take care of sub-expressions.
         * @param {Object} testModel
         * @param {Function} cb
         */
        eachOutcomeProcessingRules: function eachOutcomeProcessingRules(testModel, cb) {
            _.forEach(outcomeHelper.getOutcomeProcessingRules(testModel), cb);
        },

        /**
         * Applies a function on each outcome processing rules, take care of each sub expression.
         * @param {Object} testModel
         * @param {Function} cb
         */
        eachOutcomeProcessingRuleExpressions: function eachOutcomeProcessingRuleExpressions(testModel, cb) {
            function browseExpressions(processingRule) {
                if (_.isArray(processingRule)) {
                    _.forEach(processingRule, browseExpressions);
                } else if (processingRule) {
                    cb(processingRule);

                    if (processingRule.expression) {
                        browseExpressions(processingRule.expression);
                    } else if (processingRule.expressions) {
                        browseExpressions(processingRule.expressions);
                    }
                }
            }

            browseExpressions(outcomeHelper.getOutcomeProcessingRules(testModel));
        },

        /**
         * Lists all outcomes identifiers. An optional callback allows to filter the list
         * @param {Object} testModel
         * @param {Function} [cb]
         * @returns {Array}
         */
        listOutcomes: function listOutcomes(testModel, cb) {
            var outcomes = [];
            if (!_.isFunction(cb)) {
                cb = null;
            }
            outcomeHelper.eachOutcomeDeclarations(testModel, function (outcome) {
                if (!cb || cb(outcome)) {
                    outcomes.push(outcomeHelper.getOutcomeIdentifier(outcome));
                }
            });
            return outcomes;
        },

        /**
         * Removes the specified outcomes from the provided test model
         * @param {Object} testModel - The test model to clean up
         * @param {Function|String[]} outcomes - The list of outcomes identifiers to remove,
         *                                       or a callback that will match each outcome to remove
         */
        removeOutcomes: function removeOutcomes(testModel, outcomes) {
            var declarations = outcomeHelper.getOutcomeDeclarations(testModel);
            var rules = outcomeHelper.getOutcomeProcessingRules(testModel);
            var check;

            if (_.isFunction(outcomes)) {
                check = outcomes;
            } else {
                outcomes = _.indexBy(_.isArray(outcomes) ? outcomes : [outcomes], function (outcome) {
                    return outcome;
                });

                check = function checkIdentifier(outcome) {
                    return !!outcomes[outcomeHelper.getOutcomeIdentifier(outcome)];
                };
            }

            if (declarations) {
                _.remove(declarations, check);
            }

            if (rules) {
                _.remove(rules, check);
            }
        },

        /**
         * Creates an outcome declaration
         * @param {String} identifier
         * @param {String|Number|Boolean} [type] - The data type of the outcome, FLOAT by default
         * @param {Number} [cardinality] - The variable cardinality, default 0
         * @returns {Object}
         * @throws {TypeError} if the identifier is empty or is not a string
         */
        createOutcome: function createOutcome(identifier, type, cardinality) {

            if (!outcomeValidator.validateIdentifier(identifier)) {
                throw new TypeError('You must provide a valid identifier!');
            }

            return qtiElementHelper.create('outcomeDeclaration', identifier, {
                views: [],
                interpretation: '',
                longInterpretation: '',
                normalMaximum: false,
                normalMinimum: false,
                masteryValue: false,
                cardinality: cardinalityHelper.getValid(cardinality, cardinalityHelper.SINGLE),
                baseType: baseTypeHelper.getValid(type, baseTypeHelper.FLOAT)
            });
        },

        /**
         * Adds a processing rule into the test model
         *
         * @param {Object} testModel
         * @param {Object} processingRule
         * @returns {Object}
         * @throws {TypeError} if the processing rule is not valid
         */
        addOutcomeProcessing: function createOutcomeProcessing(testModel, processingRule) {
            var outcomeProcessing = testModel.outcomeProcessing;

            if (!outcomeValidator.validateOutcome(processingRule)) {
                throw new TypeError('You must provide a valid outcome processing rule!');
            }

            if (!outcomeProcessing) {
                outcomeProcessing = qtiElementHelper.create('outcomeProcessing', {
                    outcomeRules: []
                });
                testModel.outcomeProcessing = outcomeProcessing;
            } else if (!outcomeProcessing.outcomeRules) {
                outcomeProcessing.outcomeRules = [];
            }

            outcomeProcessing.outcomeRules.push(processingRule);
            return processingRule;
        },

        /**
         * Creates an outcome and adds it to the declarations
         * @param {Object} testModel
         * @param {Object} outcome - The outcome to add
         * @param {Object} [processingRule] - The processing rule attached to the outcome
         * @returns {Object}
         * @throws {TypeError} if one of the outcome or the processing rule is not valid
         */
        addOutcome: function addOutcome(testModel, outcome, processingRule) {
            var declarations = testModel.outcomeDeclarations;

            if (!outcomeValidator.validateOutcome(outcome, true, 'outcomeDeclaration')) {
                throw new TypeError('You must provide a valid outcome!');
            }

            if (processingRule) {
                if (!outcomeValidator.validateOutcome(processingRule) || processingRule.identifier !== outcome.identifier) {
                    throw new TypeError('You must provide a valid outcome processing rule!');
                }

                outcomeHelper.addOutcomeProcessing(testModel, processingRule);
            }

            if (!declarations) {
                declarations = [];
                testModel.outcomeDeclarations = declarations;
            }

            declarations.push(outcome);
            return outcome;
        },

        /**
         * Replaces the outcomes in a test model
         * @param {Object} testModel
         * @param {Object} outcomes
         * @throws {TypeError} if one of the outcomes or the processing rules are not valid
         */
        replaceOutcomes: function replaceOutcomes(testModel, outcomes) {
            if (_.isPlainObject(outcomes)) {
                if (_.isArray(outcomes.outcomeDeclarations)) {
                    if (!outcomeValidator.validateOutcomes(outcomes.outcomeDeclarations, true, 'outcomeDeclaration')) {
                        throw new TypeError('You must provide valid outcomes!');
                    }

                    testModel.outcomeDeclarations = [].concat(outcomes.outcomeDeclarations);
                }
                if (outcomes.outcomeProcessing && _.isArray(outcomes.outcomeProcessing.outcomeRules)) {
                    if (!outcomeValidator.validateOutcomes(outcomes.outcomeProcessing.outcomeRules)) {
                        throw new TypeError('You must provide valid processing rules!');
                    }

                    if (!testModel.outcomeProcessing) {
                        testModel.outcomeProcessing = qtiElementHelper.create('outcomeProcessing');
                    }
                    testModel.outcomeProcessing.outcomeRules = [].concat(outcomes.outcomeProcessing.outcomeRules);
                }
            }
        }
    };

    return outcomeHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * Helper that provides a way to browse all categories attached to a test model at the item level.
 *
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/category',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * Checks if a category is an option
     *
     * @param {String} category
     * @returns {Boolean}
     */
    function isCategoryOption(category) {
        return category && category.indexOf('x-tao-') === 0;
    }

    /**
     * Calls a function for each category in the test model
     * @param {Object} testModel
     * @param {Function} cb
     */
    function eachCategories(testModel, cb) {
        _.forEach(testModel.testParts, function (testPart) {
            _.forEach(testPart.assessmentSections, function (assessmentSection) {
                _.forEach(assessmentSection.sectionParts, function (itemRef) {
                    _.forEach(itemRef.categories, function(category) {
                        cb(category, itemRef);
                    });
                });
            });
        });
    }

    return {
        /**
         * Calls a function for each category in the test model
         * @function eachCategories
         * @param {Object} testModel
         * @param {Function} cb
         */
        eachCategories: eachCategories,

        /**
         * Gets the list of categories assigned to the items.
         * Discards special purpose categories like 'x-tao-...'
         *
         * @param {Object} testModel
         * @returns {Array}
         */
        listCategories: function listCategories(testModel) {
            var categories = {};
            eachCategories(testModel, function(category) {
                if (!isCategoryOption(category)) {
                    categories[category] = true;
                }
            });
            return _.keys(categories);
        },

        /**
         * Gets the list of options assigned to the items (special purpose categories like 'x-tao-...').
         *
         * @param {Object} testModel
         * @returns {Array}
         */
        listOptions: function listOptions(testModel) {
            var options = {};
            eachCategories(testModel, function(category) {
                if (isCategoryOption(category)) {
                    options[category] = true;
                }
            });
            return _.keys(options);
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/modelOverseer',[
    'lodash',
    'core/eventifier',
    'core/statifier',
    'taoQtiTest/controller/creator/helpers/baseType',
    'taoQtiTest/controller/creator/helpers/cardinality',
    'taoQtiTest/controller/creator/helpers/outcome',
    'taoQtiTest/controller/creator/helpers/category'
], function (_, eventifier, statifier, baseTypeHelper, cardinalityHelper, outcomeHelper, categoryHelper) {
    'use strict';

    /**
     * Wraps the test model in a manager, provides API to handle events and states
     * @param {Object} model
     * @param {Object} [config]
     * @returns {Object}
     */
    function modelOverseerFactory(model, config) {
        var modelOverseer = {
            /**
             * Gets the nested model
             * @returns {Object}
             */
            getModel: function getModel() {
                return model;
            },

            /**
             * Sets the nested model
             *
             * @param {Object} newModel
             * @returns {modelOverseer}
             * @fires setmodel
             */
            setModel: function setModel(newModel) {
                model = newModel;

                /**
                 * @event modelOverseer#setmodel
                 * @param {String} model
                 */
                modelOverseer.trigger('setmodel', model);
                return this;
            },

            /**
             * Gets the config set
             * @returns {Object}
             */
            getConfig: function getConfig() {
                return config;
            },



            /**
             * Gets the list of defined outcomes for the nested model. A descriptor is built for each outcomes:
             * {
             *      name: {String},
             *      type: {String},
             *      cardinality: {String}
             * }
             * @returns {Object[]}
             */
            getOutcomesList: function getOutcomesList() {
                return _.map(outcomeHelper.getOutcomeDeclarations(model), function(declaration) {
                    return {
                        name: declaration.identifier,
                        type: baseTypeHelper.getNameByConstant(declaration.baseType),
                        cardinality: cardinalityHelper.getNameByConstant(declaration.cardinality)
                    };
                });
            },

            /**
             * Gets the names of the defined outcomes for the nested model
             * @returns {Array}
             */
            getOutcomesNames: function getOutcomesNames() {
                return _.map(outcomeHelper.getOutcomeDeclarations(model), function(declaration) {
                    return declaration.identifier;
                });
            },

            /**
             * Gets the list of defined categories for the nested model
             * @returns {Array}
             */
            getCategories: function getCategories() {
                return categoryHelper.listCategories(model);
            },

            /**
             * Gets the list of defined options for the nested model
             * @returns {Array}
             */
            getOptions: function getOptions() {
                return categoryHelper.listOptions(model);
            }
        };

        config = _.isPlainObject(config) ? config : _.assign({}, config);

        return statifier(eventifier(modelOverseer));
    }

    return modelOverseerFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */
/**
 * This object holds a shared context for all of the test creator modules and allow them to communicate via events.
 * Its lifecycle is bound to the creator controller.
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/controller/creator/qtiTestCreator',[
    'jquery',
    'core/eventifier',
    'taoQtiTest/controller/creator/areaBroker',
    'taoQtiTest/controller/creator/modelOverseer'
], function($, eventifier, areaBrokerFactory, modelOverseerFactory) {
    'use strict';

    /**
     * @param {jQuery} $creatorContainer - root DOM element containing the creator
     * @param {Object} config - options that will be forwareded to the modelOverseer Factory
     * @returns {Object}
     */
    function testCreatorFactory($creatorContainer, config) {
        var testCreator;

        var $container,
            model,
            areaBroker,
            modelOverseer;

        /**
         * Create the model overseer with the given model
         * @returns {modelOverseer}
         */
        function loadModelOverseer() {
            if (! modelOverseer && model) {
                modelOverseer = modelOverseerFactory(model, config);
            }
            return modelOverseer;
        }

        /**
         * Set up the areaBroker mapping from the actual DOM
         * @returns {areaBroker} already mapped
         */
        function loadAreaBroker(){
            if (! areaBroker) {
                areaBroker = areaBrokerFactory($container, {
                    'creator': $container,
                    'itemSelectorPanel': $container.find('.test-creator-items'),
                    'contentCreatorPanel': $container.find('.test-creator-content'),
                    'propertyPanel': $container.find('.test-creator-props'),
                    'elementPropertyPanel': $container.find('.qti-widget-properties')
                });
            }
            return areaBroker;
        }

        if (! ($creatorContainer instanceof $)) {
            throw new TypeError('a valid $container must be given');
        }

        $container = $creatorContainer;

        testCreator = {
            setTestModel: function setTestModel(m) {
                model = m;
            },

            getAreaBroker: function getAreaBroker() {
                return loadAreaBroker();
            },

            getModelOverseer: function getModelOverseer() {
                return loadModelOverseer();
            }
        };
        return eventifier(testCreator);
    }

    return testCreatorFactory;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */

/**
 * The testItem data provider
 *
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/provider/testItems',[
    'lodash',
    'i18n',
    'util/url',
    'core/dataProvider/request'
], function (_, __, urlUtil, request) {
    'use strict';

    /**
     * Per function requests configuration.
     */
    var defaultConfig = {
        getItemClasses : {
            url : urlUtil.route('getItemClasses', 'Items', 'taoQtiTest')
        },
        getItems : {
            url : urlUtil.route('getItems', 'Items', 'taoQtiTest')
        },
        getItemClassProperties : {
            url : urlUtil.route('create', 'RestFormItem', 'taoItems')
        }
    };

    /**
     * Creates a configured testItem provider
     *
     * @param {Object} [config] - to override the default config
     * @returns {testItemProvider} the new provider
     */
    return function testItemProviderFactory(config){

        config = _.defaults(config || {}, defaultConfig);

        /**
         * @typedef {testItemProvider}
         */
        return {

            /**
             * Get the list of Items classes and sub classes
             * @returns {Promise} that resolves with the classes
             */
            getItemClasses: function getItemClasses(){
                return request(config.getItemClasses.url);
            },

            /**
             * Get QTI Items in different formats
             * @param {Object} [params] - the parameters to pass through the request
             * @returns {Promise} that resolves with the classes
             */
            getItems : function getItems(params){
                return request(config.getItems.url, params);
            },

            /**
             * Get the properties of a the given item class
             * @param {String} classUri - the item class URI
             * @returns {Promise} that resolves with the classes
             */
            getItemClassProperties: function getItemClassProperties(classUri) {
                return request(config.getItemClassProperties.url, { classUri : classUri });
            }
        };
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/item',[
    'jquery',
    'i18n',
    'core/logger',
    'taoQtiTest/provider/testItems',
    'ui/resource/selector',
    'ui/feedback'
], function($, __, loggerFactory, testItemProviderFactory, resourceSelector, feedback){
    'use strict';

   /**
    * Create a dedicated logger
    */
    var logger = loggerFactory('taoQtiTest/creator/views/item');

    /**
     * Let's you access the data
     */
    var testItemProvider = testItemProviderFactory();

    /**
     * Handles errors
     * @param {Error} err
     */
    var onError = function onError(err){
        logger.error(err);
        feedback.error(err.message || __('An error occured while retrieving items'));
    };

   /**
     * The ItemView setup items related components
     * @exports taoQtiTest/controller/creator/views/item
     * @param {jQueryElement} $container - where to append the view
     */
    return function itemView($container){

        var selectorConfig = {
            type : __('items'),
            selectionMode : resourceSelector.selectionModes.multiple
        };

        //load the classes hierarchy
        testItemProvider.getItemClasses()
            .then(function(classes){
                selectorConfig.classes = classes;
                selectorConfig.classUri = classes[0].uri;
            })
            .then(function(){
                //load the class properties
                return testItemProvider.getItemClassProperties(selectorConfig.classUri);
            })
            .then(function(filters){
                //set the filters from the properties
                selectorConfig.filters = filters;
            })
            .then(function(){
                //set up the resource selector
                resourceSelector($container, selectorConfig)
                    .on('render', function(){
                        var self = this;
                        $container.on('itemselected.creator', function(){
                            self.clearSelection();
                        });
                    })
                    .on('query', function(params){
                        var self = this;

                        //ask the server the item from the component query
                        testItemProvider.getItems(params)
                            .then(function(items){
                                //and update the item list
                                self.update(items, params);
                            })
                            .catch(onError);
                    })
                    .on('classchange', function(classUri){
                        var self = this;

                        //by changing the class we need to change the
                        //properties filters
                        testItemProvider
                            .getItemClassProperties(classUri)
                            .then(function(filters){
                                self.updateFilters(filters);
                            })
                            .catch(onError);
                    })
                    .on('change', function(values){

                        /**
                         * We've got a selection, triggered on the view container
                         *
                         * TODO replace jquery events by the eventifier
                         *
                         * @event jQuery#itemselect.creator
                         * @param {Object[]} values - the selection
                         */
                        $container.trigger('itemselect.creator', [values]);
                    });
            })
            .catch(onError);
    };
});


define('tpl!taoQtiTest/controller/creator/templates/testpart', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"testpart clearfix\">\n\n   <h1><span data-bind=\"identifier\">";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        <div class=\"actions\"> \n            <div class=\"tlb\">\n                <div class=\"tlb-top\">\n                    <span class=\"tlb-box\">\n                        <span class=\"tlb-bar\">\n                            <span class=\"tlb-start\"></span>\n                            <span class=\"tlb-group\">\n                                <a href=\"#\" class=\"tlb-button-off property-toggler\" title=\"Test Part Properties\"><span class=\"icon-settings\"></span></a>\n                                <span class=\"tlb-separator\"></span>\n                                <a href=\"#\" class=\"tlb-button-off move-up\" title=\"Move Up\"><span class=\"icon-up\"></span></a>\n                                <a href=\"#\" class=\"tlb-button-off move-down\" title=\"Move Down\"><span class=\"icon-down\"></span></a>\n                                <span class=\"tlb-separator\"></span> \n                                <a href=\"#\" class=\"tlb-button-off\" title=\"Remove Test Part\" data-delete=\"#";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"><span class=\"icon-bin\"></span></a>\n                            </span>\n                            <span class=\"tlb-end\"></span>\n                        </span>  \n                        <!--<span class=\"tlb-bar\">-->\n                            <!--<span class=\"tlb-start\"></span>-->\n                            <!--<span class=\"tlb-text-button-box\">-->\n                                <!--<a class=\"tlb-text-button-off section-adder\">-->\n                                    <!--<span class=\"icon-add\"></span>-->\n                                    <!--<span class=\"tlb-text\">New Section</span>-->\n                                <!--</a>-->\n                            <!--</span>-->\n                            <!--<span class=\"tlb-end\"></span>-->\n                        <!--</span>-->\n                    </span>   \n                </div>\n            </div>\n        </div>\n        <a href=\"#\" class=\"toggler opened\" data-toggle=\"#testpart-content-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></a>\n    </h1>\n    <div id=\"testpart-content-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"testpart-content\">\n        \n       <!-- assessmentTest/testPart/assessmentSections -->\n       <div class=\"sections\" data-bind-each=\"assessmentSections\" data-bind-tmpl=\"section\" data-bind-filter=\"isSection\"></div>\n\n        <button class=\"btn-info small section-adder\">\n            <span class=\"icon-add\"></span>New section\n        </button>\n    </div>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/section', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div id=\"";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"section\">\n\n<!-- assessmentTest/testPart/assessmentSection/title -->\n    <h2><span data-bind=\"title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        <div class=\"actions\">\n            <div class=\"tlb\">\n                <div class=\"tlb-top\">\n                    <span class=\"tlb-box\">\n                        <span class=\"tlb-bar\">\n                            <span class=\"tlb-start\"></span>\n                            <span class=\"tlb-group\">\n                                <a href=\"#\" class=\"tlb-button-off rub-toggler\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Manage Rubric Blocks", options) : helperMissing.call(depth0, "__", "Manage Rubric Blocks", options)))
    + "\" data-toggle=\"#rublocks-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" ><span class=\"icon-rubric\"></span></a>\n                                <span class=\"tlb-separator\"></span>\n                                <a href=\"#\" class=\"tlb-button-off property-toggler\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Section Properties", options) : helperMissing.call(depth0, "__", "Section Properties", options)))
    + "\"><span class=\"icon-settings\"></span></a>\n                                <span class=\"tlb-separator\"></span>\n                                <a href=\"#\" class=\"tlb-button-off move-up disabled\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Move Up", options) : helperMissing.call(depth0, "__", "Move Up", options)))
    + "\"><span class=\"icon-up\"></span></a>\n                                <a href=\"#\" class=\"tlb-button-off move-down disabled\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Move Down", options) : helperMissing.call(depth0, "__", "Move Down", options)))
    + "\"><span class=\"icon-down\"></span></a>\n                                <span class=\"tlb-separator\"></span>\n                                <a href=\"#\" class=\"tlb-button-off disabled\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Remove Section", options) : helperMissing.call(depth0, "__", "Remove Section", options)))
    + "\" data-delete=\":parent .section\"><span class=\"icon-bin\"></span></a>\n                            </span>\n                            <span class=\"tlb-end\"></span>\n                        </span>\n                    </span>\n                </div>\n            </div>\n        </div>\n    </h2>\n\n    <div id=\"rublocks-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"rublocks clearfix toggled\">\n        <h3>\n            <span class=\"title\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Rubric Blocks", options) : helperMissing.call(depth0, "__", "Rubric Blocks", options)))
    + "</span>\n        </h3>\n        <ol class=\"rubricblocks decimal\" data-bind-each=\"rubricBlocks\" data-bind-tmpl=\"rubricblock\"></ol>\n        <button class=\"btn-info small rublock-adder\">\n            <span class=\"icon-add\"></span>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "New Rubric Block", options) : helperMissing.call(depth0, "__", "New Rubric Block", options)))
    + "\n        </button>\n    </div>\n    <div class=\"itemrefs-wrapper\">\n        <h3>\n            <span class=\"title\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Items", options) : helperMissing.call(depth0, "__", "Items", options)))
    + "</span>\n        </h3>\n        <ol class=\"itemrefs decimal clearfix\" data-bind-each=\"sectionParts\" data-bind-tmpl=\"itemref\" data-bind-filter=\"isItemRef\" data-msg=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Add selected item(s) here.", options) : helperMissing.call(depth0, "__", "Add selected item(s) here.", options)))
    + "\"></ol>\n        <div class=\"itemref-placeholder\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Add selected item(s) here.", options) : helperMissing.call(depth0, "__", "Add selected item(s) here.", options)))
    + "\n        </div>\n    </div>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/rubricblock', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<li class=\"rubricblock\">\n    <div class=\"actions\">\n       <div class=\"tlb\">\n            <div class=\"tlb-top\">\n                <span class=\"tlb-box\">\n                    <span class=\"tlb-bar\">\n                        <span class=\"tlb-start\"></span>\n                        <span class=\"tlb-group\">\n                            <a href=\"#\" class=\"tlb-button-off property-toggler\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Rubric Block Properties", options) : helperMissing.call(depth0, "__", "Rubric Block Properties", options)))
    + "\"><span class=\"icon-settings\"></span></a>\n                            <span class=\"tlb-separator\"></span>\n                            <a href=\"#\" class=\"tlb-button-off\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Remove Rubric Block", options) : helperMissing.call(depth0, "__", "Remove Rubric Block", options)))
    + "\" data-delete=\":parent .rubricblock\"><span class=\"icon-bin\"></span></a>\n                        </span>\n                        <span class=\"tlb-end\"></span>\n                    </span>\n                </span>\n            </div>\n        </div>\n    </div>\n    <div class=\"rubricblock-content\"></div>\n</li>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/itemref', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<li id='";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "' data-uri='";
  if (helper = helpers.href) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.href); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "' class='itemref'>\n    <span class='title truncate'>";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    <div class=\"actions\"> \n        <div class=\"tlb\">\n            <div class=\"tlb-top\">\n                <span class=\"tlb-box\">\n                    <span class=\"tlb-bar\">\n                        <span class=\"tlb-start\"></span>\n                        <span class=\"tlb-group\">\n                            <a href=\"#\" class=\"tlb-button-off property-toggler\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Item Reference Properties", options) : helperMissing.call(depth0, "__", "Item Reference Properties", options)))
    + "\"><span class=\"icon-settings\"></span></a>\n                            <span class=\"tlb-separator\"></span>\n                            <a href=\"#\" class=\"tlb-button-off move-up\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Move Up", options) : helperMissing.call(depth0, "__", "Move Up", options)))
    + "\"><span class=\"icon-up\"></span></a>\n                            <a href=\"#\" class=\"tlb-button-off move-down\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Move Down", options) : helperMissing.call(depth0, "__", "Move Down", options)))
    + "\"><span class=\"icon-down\"></span></a>\n                            <span class=\"tlb-separator\"></span> \n                            <a href=\"#\" class=\"tlb-button-off\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Remove Item Reference", options) : helperMissing.call(depth0, "__", "Remove Item Reference", options)))
    + "\" data-delete=\":parent .itemref\"><span class=\"icon-bin\"></span></a>\n                        </span>\n                        <span class=\"tlb-end\"></span>\n                    </span>  \n                </span>   \n            </div>\n        </div>\n    </div>\n</li>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/outcomes', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"grid-row\">\n        <div class=\"col-6 line\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"col-3 line\">";
  if (helper = helpers.type) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.type); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"col-3 line\">";
  if (helper = helpers.cardinality) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.cardinality); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    </div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <div class=\"grid-row\">\n        <div class=\"col-12 line\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "no outcome declaration found", options) : helperMissing.call(depth0, "__", "no outcome declaration found", options)))
    + "</div>\n    </div>\n";
  return buffer;
  }

  buffer += "    <div class=\"grid-row\">\n        <div class=\"col-6 header\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + "</div>\n        <div class=\"col-3 header\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Type", options) : helperMissing.call(depth0, "__", "Type", options)))
    + "</div>\n        <div class=\"col-3 header\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Cardinality", options) : helperMissing.call(depth0, "__", "Cardinality", options)))
    + "</div>\n    </div>\n";
  stack1 = helpers['if'].call(depth0, depth0, {hash:{},inverse:self.program(4, program4, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/test-props', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    <div class=\"test-scoring toggled\">\n\n<!-- assessmentTest/scoring/outcomeProcessing -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"test-outcome-processing\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Outcome processing", options) : helperMissing.call(depth0, "__", "Outcome processing", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <select name=\"test-outcome-processing\" class=\"select2\" data-bind=\"scoring.outcomeProcessing\" data-bind-encoder=\"string\" data-has-search=\"false\">\n                ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.modes), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </select>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Select the way the responses of your test should be processed", options) : helperMissing.call(depth0, "__", "Select the way the responses of your test should be processed", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/scoring/categoryScore -->\n        <div class=\"grid-row test-category-score\">\n            <div class=\"col-5\">\n                <label for=\"test-category-score\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Category score", options) : helperMissing.call(depth0, "__", "Category score", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"test-category-score\" value=\"true\" data-bind=\"scoring.categoryScore\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Also compute the score per categories", options) : helperMissing.call(depth0, "__", "Also compute the score per categories", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/scoring/cutScore -->\n        <div class=\"grid-row test-cut-score\">\n            <div class=\"col-5\">\n                <label for=\"test-cut-score\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Cut score (pass ratio)", options) : helperMissing.call(depth0, "__", "Cut score (pass ratio)", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"test-cut-score\" value=\"0\" data-bind=\"scoring.cutScore\" data-bind-encoder=\"float\" data-validate=\"$numeric;\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the cut score (or pass score ratio) associated to the test. It must be a float between 0 and 1.", options) : helperMissing.call(depth0, "__", "Set the cut score (or pass score ratio) associated to the test. It must be a float between 0 and 1.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/scoring/weightIdentifier -->\n        <div class=\"grid-row test-weight-identifier\">\n            <div class=\"col-5\">\n                <label for=\"test-weight-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Weight", options) : helperMissing.call(depth0, "__", "Weight", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"test-weight-identifier\" data-bind=\"scoring.weightIdentifier\" data-validate=\"$pattern(pattern=^([a-zA-Z_][a-zA-Z0-9_\\.-]*)?$);\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the weight identifier used to process the score", options) : helperMissing.call(depth0, "__", "Set the weight identifier used to process the score", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/scoring/description -->\n        <div class=\"grid-row\">\n            <div class=\"col-12\">\n                ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.modes), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            </div>\n        </div>\n    </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                    <option value=\"";
  if (helper = helpers.key) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.key); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.selected), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</option>\n                ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return "selected=\"selected\"";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                <div class=\"feedback-info test-outcome-processing-description\" data-key=\"";
  if (helper = helpers.key) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.key); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                    <span class=\"icon-info\"></span>\n                    ";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n                </div>\n                ";
  return buffer;
  }

  buffer += "<div class=\"test-props props clearfix\">\n\n    <!-- test properties -->\n    <h3 data-bind=\"title\"></h3>\n\n<!-- assessmentTest/identifier -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"test-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"test-identifier\" data-bind=\"identifier\" data-validate=\"$notEmpty; $testIdFormat; $testIdAvailable;\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The principle identifier of the test.", options) : helperMissing.call(depth0, "__", "The principle identifier of the test.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/title -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"test-title\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Title", options) : helperMissing.call(depth0, "__", "Title", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"test-title\" data-bind=\"title\" data-validate=\"$notEmpty\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The test title.", options) : helperMissing.call(depth0, "__", "The test title.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .test-time-limits\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Time Limits", options) : helperMissing.call(depth0, "__", "Time Limits", options)))
    + "</h4>\n\n<!-- assessmentTest/timeLimits -->\n    <div class=\"test-time-limits toggled\">\n\n\n\n<!-- assessmentTest/timeLimits/maxTime -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"test-max-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum Duration", options) : helperMissing.call(depth0, "__", "Maximum Duration", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"max-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.maxTime\" data-bind-encoder=\"time\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum duration for the all test.", options) : helperMissing.call(depth0, "__", "Maximum duration for the all test.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/timeLimits/allowLateSubmission -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Late submission allowed", options) : helperMissing.call(depth0, "__", "Late submission allowed", options)))
    + "\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"test-allow-late-submission\" value=\"true\" data-bind=\"timeLimits.allowLateSubmission\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Whether a candidate's response that is beyond the maximum duration should still be accepted.", options) : helperMissing.call(depth0, "__", "Whether a candidate's response that is beyond the maximum duration should still be accepted.", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .test-scoring\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Scoring", options) : helperMissing.call(depth0, "__", "Scoring", options)))
    + "</h4>\n\n<!-- assessmentTest/scoring -->\n";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.scoring), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .test-outcome-declarations\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Outcome declarations", options) : helperMissing.call(depth0, "__", "Outcome declarations", options)))
    + "</h4>\n\n    <!-- assessmentTest/outcomeDeclarations -->\n    <div class=\"test-outcome-declarations panel toggled\">\n        <div class=\"grid-row test-outcomes-generate\">\n            <div class=\"col-12 align-right\">\n                <button class=\"btn-info small\" data-action=\"generate-outcomes\"><span class=\"icon icon-reset\"></span>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Regenerate", options) : helperMissing.call(depth0, "__", "Regenerate", options)))
    + "</button>\n            </div>\n        </div>\n        <div class=\"outcome-declarations\"></div>\n    </div>\n\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/testpart-props', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div id=\"testpart-props-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"testpart-props props clearfix\">\n    <h3>";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3>\n\n    <form autocomplete=\"off\">\n\n<!-- assessmentTest/testPart/identifier -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"testpart-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"testpart-identifier\" data-bind=\"identifier\" data-validate=\"$notEmpty; $idFormat; $testIdAvailable;\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The test part identifier.", options) : helperMissing.call(depth0, "__", "The test part identifier.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/navigationMode -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n               "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Navigation", options) : helperMissing.call(depth0, "__", "Navigation", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"radio\" name=\"testpart-navigation-mode\" value=\"0\" checked=\"checked\" data-bind=\"navigationMode\" data-bind-encoder=\"number\" />\n                    <span class=\"icon-radio\"></span>\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Linear", options) : helperMissing.call(depth0, "__", "Linear", options)))
    + "\n                </label>\n                <label>\n                    <input type=\"radio\" name=\"testpart-navigation-mode\" value=\"1\"  />\n                    <span class=\"icon-radio\"></span>\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Non Linear", options) : helperMissing.call(depth0, "__", "Non Linear", options)))
    + "\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The navigation mode determines the general paths that the candidate may take. A linear mode restricts the candidate to attempt each item in turn. Non Linear removes this restriction.", options) : helperMissing.call(depth0, "__", "The navigation mode determines the general paths that the candidate may take. A linear mode restricts the candidate to attempt each item in turn. Non Linear removes this restriction.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/submissionMode -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Submission", options) : helperMissing.call(depth0, "__", "Submission", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"radio\" name=\"testpart-submission-mode\" value=\"0\" checked=\"checked\" data-bind=\"submissionMode\" data-bind-encoder=\"number\" />\n                    <span class=\"icon-radio\"></span>\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Individual", options) : helperMissing.call(depth0, "__", "Individual", options)))
    + "\n                </label>\n                <label>\n                    <input type=\"radio\" name=\"testpart-submission-mode\" value=\"1\"  />\n                    <span class=\"icon-radio\"></span>\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Simultaneous", options) : helperMissing.call(depth0, "__", "Simultaneous", options)))
    + "\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The submission mode determines when the candidate's responses are submitted for response processing. A testPart in individual mode requires the candidate to submit their responses on an item-by-item basis. In simultaneous mode the candidate's responses are all submitted together at the end of the testPart.", options) : helperMissing.call(depth0, "__", "The submission mode determines when the candidate's responses are submitted for response processing. A testPart in individual mode requires the candidate to submit their responses on an item-by-item basis. In simultaneous mode the candidate's responses are all submitted together at the end of the testPart.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n        <h4 class=\"toggler closed\" data-toggle=\"~ .testpart-item-session-control\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Item Session Control", options) : helperMissing.call(depth0, "__", "Item Session Control", options)))
    + "</h4>\n\n\n<!-- assessmentTest/testPart/itemSessionControl -->\n        <div class=\"testpart-item-session-control toggled\">\n\n<!-- assessmentTest/testPart/itemSessionControl/maxAttempts -->\n            <div class=\"grid-row\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-max-attempts\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Max Attempts", options) : helperMissing.call(depth0, "__", "Max Attempts", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <input name=\"testpart-max-attempts\" type=\"text\" data-increment=\"1\" data-min=\"0\" value=\"1\" data-bind=\"itemSessionControl.maxAttempts\" data-bind-encoder=\"number\" />\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Controls the maximum number of attempts allowed. 0 means unlimited.", options) : helperMissing.call(depth0, "__", "Controls the maximum number of attempts allowed. 0 means unlimited.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n<!-- assessmentTest/testPart/itemSessionControl/showFeedback -->\n            <div class=\"grid-row pseudo-label-box\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-show-feedback\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Show Feedback", options) : helperMissing.call(depth0, "__", "Show Feedback", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <label>\n                        <input type=\"checkbox\" name=\"testpart-show-feedback\" value=\"true\" data-bind=\"itemSessionControl.showFeedback\" data-bind-encoder=\"boolean\" />\n                        <span class=\"icon-checkbox\" />\n                    </label>\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint affects the visibility of feedback after the end of the last attempt.", options) : helperMissing.call(depth0, "__", "This constraint affects the visibility of feedback after the end of the last attempt.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n\n\n\n\n<!-- assessmentTest/testPart/itemSessionControl/allowComment -->\n            <div class=\"grid-row pseudo-label-box\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-allow-comment\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Comment", options) : helperMissing.call(depth0, "__", "Allow Comment", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <label>\n                        <input type=\"checkbox\" name=\"testpart-allow-comment\" value=\"true\" data-bind=\"itemSessionControl.allowComment\" data-bind-encoder=\"boolean\" />\n                        <span class=\"icon-checkbox\" />\n                    </label>\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options) : helperMissing.call(depth0, "__", "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n<!-- assessmentTest/testPart/itemSessionControl/allowSkipping -->\n            <div class=\"grid-row pseudo-label-box\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-allow-skipping\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Skipping", options) : helperMissing.call(depth0, "__", "Allow Skipping", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <label>\n                        <input type=\"checkbox\" name=\"testpart-allow-skipping\" value=\"true\" checked=\"checked\"  data-bind=\"itemSessionControl.allowSkipping\" data-bind-encoder=\"boolean\"   />\n                        <span class=\"icon-checkbox\" />\n                    </label>\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "If the candidate can skip the item, without submitting a response (default is true).", options) : helperMissing.call(depth0, "__", "If the candidate can skip the item, without submitting a response (default is true).", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n<!-- assessmentTest/testPart/itemSessionControl/validateResponses -->\n            <div class=\"grid-row pseudo-label-box\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-validate-responses\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Validate Responses", options) : helperMissing.call(depth0, "__", "Validate Responses", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <label>\n                        <input type=\"checkbox\" name=\"testpart-validate-responses\" value=\"true\"  data-bind=\"itemSessionControl.validateResponses\" data-bind-encoder=\"boolean\"  />\n                        <span class=\"icon-checkbox\" />\n                    </label>\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The candidate is not allowed to submit invalid responses.", options) : helperMissing.call(depth0, "__", "The candidate is not allowed to submit invalid responses.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n        </div>\n\n        <h4 class=\"toggler closed\" data-toggle=\"~ .testpart-time-limits\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Time Limits", options) : helperMissing.call(depth0, "__", "Time Limits", options)))
    + "</h4>\n\n<!-- assessmentTest/testPart/timeLimits/minTime -->\n        <div class=\"testpart-time-limits toggled\">\n\n\n\n<!-- assessmentTest/testPart/timeLimits/maxTime -->\n            <div class=\"grid-row\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-max-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum Duration", options) : helperMissing.call(depth0, "__", "Maximum Duration", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <input type=\"text\" name=\"max-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.maxTime\" data-bind-encoder=\"time\" />\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum duration for this test part.", options) : helperMissing.call(depth0, "__", "Maximum duration for this test part.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n\n<!-- assessmentTest/testPart/timeLimits/allowLateSubmission -->\n            <div class=\"grid-row pseudo-label-box\">\n                <div class=\"col-5\">\n                    <label for=\"testpart-allow-late-submission\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Late submission allowed", options) : helperMissing.call(depth0, "__", "Late submission allowed", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <label>\n                        <input type=\"checkbox\" name=\"section-allow-late-submission\" value=\"true\" data-bind=\"timeLimits.allowLateSubmission\" data-bind-encoder=\"boolean\" />\n                        <span class=\"icon-checkbox\" />\n                    </label>\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Whether a candidate's response that is beyond the maximum duration of the test part should still be accepted.", options) : helperMissing.call(depth0, "__", "Whether a candidate's response that is beyond the maximum duration of the test part should still be accepted.", options)))
    + "\n                    </div>\n                </div>\n            </div>\n        </div>\n    </form>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/section-props', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <div class=\"grid-row pseudo-label-box\">\n        <div class=\"col-5\">\n            <label for=\"section-blueprint\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Associate Blueprint", options) : helperMissing.call(depth0, "__", "Associate Blueprint", options)))
    + "</label>\n        </div>\n\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"section-blueprint\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Associate a blueprint to a section allow you to validate this section against the specified blueprint.", options) : helperMissing.call(depth0, "__", "Associate a blueprint to a section allow you to validate this section against the specified blueprint.", options)))
    + "\n            </div>\n        </div>\n    </div>\n    ";
  return buffer;
  }

  buffer += "<div id=\"section-props-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"section-props props clearfix\">\n    <h3>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3>\n\n<!-- assessmentTest/testPart/assessmentSection/identifier -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"section-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"section-identifier\" data-bind=\"identifier\" data-validate=\"$notEmpty; $idFormat; $testIdAvailable;\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The identifier of the section.", options) : helperMissing.call(depth0, "__", "The identifier of the section.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/testPart/assessmentSection/title -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"section-title\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Title", options) : helperMissing.call(depth0, "__", "Title", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"section-title\" data-bind=\"title\" data-validate=\"$notEmpty\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The section title.", options) : helperMissing.call(depth0, "__", "The section title.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n\n\n\n\n<!-- assessmentTest/testPart/assessmentSection/visible -->\n    <div class=\"grid-row pseudo-label-box\">\n        <div class=\"col-5\">\n            <label for=\"section-visible\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Visible", options) : helperMissing.call(depth0, "__", "Visible", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <label>\n                <input type=\"checkbox\" name=\"section-visible\" value=\"true\" checked=\"checked\"  data-bind=\"visible\" data-bind-encoder=\"boolean\" />\n                <span class=\"icon-checkbox\"></span>\n            </label>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "A visible section is one that is identifiable by the candidate.", options) : helperMissing.call(depth0, "__", "A visible section is one that is identifiable by the candidate.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/testPart/assessmentSection/keepTogether -->\n    <div class=\"grid-row pseudo-label-box\">\n        <div class=\"col-5\">\n            <label for=\"section-keep-together\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Keep Together", options) : helperMissing.call(depth0, "__", "Keep Together", options)))
    + "</label>\n        </div>\n\n        <div class=\"col-6\">\n            <label>\n                <input type=\"checkbox\" name=\"section-keep-together\" value=\"true\" checked=\"checked\"  data-bind=\"keepTogether\" data-bind-encoder=\"boolean\" />\n                <span class=\"icon-checkbox\"></span>\n            </label>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "An invisible section with a parent that is subject to shuffling can specify whether or not its children, which will appear to the candidate as if they were part of the parent, are shuffled as a block or mixed up with the other children of the parent section.", options) : helperMissing.call(depth0, "__", "An invisible section with a parent that is subject to shuffling can specify whether or not its children, which will appear to the candidate as if they were part of the parent, are shuffled as a block or mixed up with the other children of the parent section.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasBlueprint), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <div class=\"categories\">\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"category-custom\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Categories", options) : helperMissing.call(depth0, "__", "Categories", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"category-custom\"/>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Section level category enables configuring the categories of its composing items all at once. A category in gray means that all items have that category. A category in white means that only a few items have that category.", options) : helperMissing.call(depth0, "__", "Section level category enables configuring the categories of its composing items all at once. A category in gray means that all items have that category. A category in white means that only a few items have that category.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n        <!-- some user features (Test Navigation, Test Taker Tools, etc.) are in fact implemented as categories. They will appear here: -->\n        <div class=\"category-presets\"></div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .section-selection\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Selection", options) : helperMissing.call(depth0, "__", "Selection", options)))
    + "</h4>\n\n<!-- assessmentTest/testPart/assessmentSection/selection -->\n    <div class=\"section-selection toggled\">\n\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-enable-selection\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Enable selection", options) : helperMissing.call(depth0, "__", "Enable selection", options)))
    + "</label>\n            </div>\n\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-enable-selection\"  />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/selection/select -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"section-select\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Select", options) : helperMissing.call(depth0, "__", "Select", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n            </div>\n            <div class=\"col-6\">\n                <input name=\"section-select\" type=\"text\" data-increment=\"1\" data-min=\"0\" value=\"0\" data-bind=\"selection.select\"  data-bind-encoder=\"number\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The number of child elements to be selected.", options) : helperMissing.call(depth0, "__", "The number of child elements to be selected.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/selection/withReplacement -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-with-replacement\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "With Replacement", options) : helperMissing.call(depth0, "__", "With Replacement", options)))
    + "</label>\n            </div>\n\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-with-replacement\" value=\"true\" data-bind=\"selection.withReplacement\"  data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "When selecting child elements each element is normally eligible for selection once only.", options) : helperMissing.call(depth0, "__", "When selecting child elements each element is normally eligible for selection once only.", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .section-ordering\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Ordering", options) : helperMissing.call(depth0, "__", "Ordering", options)))
    + "</h4>\n\n<!-- assessmentTest/testPart/assessmentSection/ordering -->\n    <div class=\"section-ordering toggled\">\n<!-- assessmentTest/testPart/assessmentSection/ordering/shuffle -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-shuffle\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Shuffle", options) : helperMissing.call(depth0, "__", "Shuffle", options)))
    + "</label>\n            </div>\n\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-shuffle\" value=\"true\" data-bind=\"ordering.shuffle\"  data-bind-encoder=\"boolean\"  />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "If set, it causes the order of the child elements to be randomized, otherwise it uses the order in which the child elements are defined.", options) : helperMissing.call(depth0, "__", "If set, it causes the order of the child elements to be randomized, otherwise it uses the order in which the child elements are defined.", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .section-item-session-control\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Item Session Control", options) : helperMissing.call(depth0, "__", "Item Session Control", options)))
    + "</h4>\n\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl -->\n    <div class=\"section-item-session-control toggled\">\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl/maxAttempts -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"section-max-attempts\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Max Attempts", options) : helperMissing.call(depth0, "__", "Max Attempts", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input name=\"section-max-attempts\" type=\"text\" data-increment=\"1\" data-min=\"0\" value=\"1\" data-bind=\"itemSessionControl.maxAttempts\" data-bind-encoder=\"number\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Controls the maximum number of attempts allowed. 0 means unlimited.", options) : helperMissing.call(depth0, "__", "Controls the maximum number of attempts allowed. 0 means unlimited.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl/showFeedback -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-show-feedback\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Show Feedback", options) : helperMissing.call(depth0, "__", "Show Feedback", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-show-feedback\" value=\"true\" data-bind=\"itemSessionControl.showFeedback\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint affects the visibility of feedback after the end of the last attempt.", options) : helperMissing.call(depth0, "__", "This constraint affects the visibility of feedback after the end of the last attempt.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n\n\n\n\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl/allowComment -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-allow-comment\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Comment", options) : helperMissing.call(depth0, "__", "Allow Comment", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-allow-comment\" value=\"true\"  data-bind=\"itemSessionControl.allowComment\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options) : helperMissing.call(depth0, "__", "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl/allowSkipping -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-allow-skipping\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Skipping", options) : helperMissing.call(depth0, "__", "Allow Skipping", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-allow-skipping\" value=\"true\" checked=\"checked\" data-bind=\"itemSessionControl.allowSkipping\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "If the candidate can skip the item, without submitting a response (default is true).", options) : helperMissing.call(depth0, "__", "If the candidate can skip the item, without submitting a response (default is true).", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/itemSessionControl/validateResponses -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-validate-responses\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Validate Responses", options) : helperMissing.call(depth0, "__", "Validate Responses", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-validate-responses\" value=\"true\" data-bind=\"itemSessionControl.validateResponses\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The candidate is not allowed to submit invalid responses.", options) : helperMissing.call(depth0, "__", "The candidate is not allowed to submit invalid responses.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .section-time-limits\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Time Limits", options) : helperMissing.call(depth0, "__", "Time Limits", options)))
    + "</h4>\n\n<!-- assessmentTest/timeLimits -->\n    <div class=\"section-time-limits toggled\">\n\n\n\n\n<!-- assessmentTest/testPart/assessmentSection/timeLimits/maxTime -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"section-max-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum Duration", options) : helperMissing.call(depth0, "__", "Maximum Duration", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"max-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.maxTime\" data-bind-encoder=\"time\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum duration for this section.", options) : helperMissing.call(depth0, "__", "Maximum duration for this section.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/timeLimits/allowLateSubmission -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"section-allow-late-submission\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Late submission allowed", options) : helperMissing.call(depth0, "__", "Late submission allowed", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"section-allow-late-submission\" value=\"true\" data-bind=\"timeLimits.allowLateSubmission\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Whether a candidate's response that is beyond the maximum duration of the section should still be accepted.", options) : helperMissing.call(depth0, "__", "Whether a candidate's response that is beyond the maximum duration of the section should still be accepted.", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/itemref-props', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  
  return "hidden";
  }

  buffer += "<div id=\"itemref-props-";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"itemref-props props clearfix\">\n\n    <h3>";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/identifier -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"itemref-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"itemref-identifier\" data-bind=\"identifier\" data-validate=\"$notEmpty; $testIdFormat; $testIdAvailable;\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The identifier of the item reference.", options) : helperMissing.call(depth0, "__", "The identifier of the item reference.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/href -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"itemref-href\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Reference", options) : helperMissing.call(depth0, "__", "Reference", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"itemref-href\" data-bind=\"href\" readonly=\"readonly\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The reference.", options) : helperMissing.call(depth0, "__", "The reference.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/required -->\n    <div class=\"grid-row pseudo-label-box\">\n        <div class=\"col-5\">\n            <label for=\"itemref-required\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required", options) : helperMissing.call(depth0, "__", "Required", options)))
    + "</label>\n        </div>\n        <div class=\"col-6\">\n            <label>\n                <input type=\"checkbox\" name=\"itemref-required\" value=\"true\" data-bind=\"required\" data-bind-encoder=\"boolean\" />\n                <span class=\"icon-checkbox\"></span>\n            </label>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "If required it must appear (at least once) in the selection.", options) : helperMissing.call(depth0, "__", "If required it must appear (at least once) in the selection.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/fixed -->\n    <div class=\"grid-row pseudo-label-box\">\n        <div class=\"col-5\">\n            <label for=\"itemref-fixed\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Fixed", options) : helperMissing.call(depth0, "__", "Fixed", options)))
    + "</label>\n        </div>\n        <div class=\"col-6\">\n            <label>\n                <input type=\"checkbox\" name=\"itemref-fixed\" value=\"true\" data-bind=\"fixed\" data-bind-encoder=\"boolean\" />\n                <span class=\"icon-checkbox\"></span>\n            </label>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n            "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Not shuffled, the position remains fixed.", options) : helperMissing.call(depth0, "__", "Not shuffled, the position remains fixed.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n    <div class=\"categories\">\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"category-custom\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Categories", options) : helperMissing.call(depth0, "__", "Categories", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "custom categories", options) : helperMissing.call(depth0, "__", "custom categories", options)))
    + "\" name=\"category-custom\"/>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Items can optionally be assigned to one or more categories.", options) : helperMissing.call(depth0, "__", "Items can optionally be assigned to one or more categories.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n        <!-- assessmentTest/testPart/assessmentSection/sectionPart/category -->\n        <textarea title=\"categories\" class=\"hidden\" type=\"text\" name=\"itemref-category\" data-bind=\"categories\" data-bind-encoder=\"str2array\"></textarea>\n\n        <!-- some user features (Test Navigation, Test Taker Tools, etc.) are in fact implemented as categories. They will appear here: -->\n        <div class=\"category-presets\"></div>\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .itemref-weights\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Weights", options) : helperMissing.call(depth0, "__", "Weights", options)))
    + "</h4>\n\n    <div class=\"itemref-weights toggled\">\n        <div class=\"grid-row \">\n            <div class=\"col-9\">\n                <strong>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + "</strong>\n            </div>\n            <div class=\"col-2\">\n                <strong>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Value", options) : helperMissing.call(depth0, "__", "Value", options)))
    + "</strong>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Controls the contribution of an individual item score to the overall test score.", options) : helperMissing.call(depth0, "__", "Controls the contribution of an individual item score to the overall test score.", options)))
    + "\n                </div>\n            </div>\n        </div>\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/weights -->\n        <div data-bind-each=\"weights\" data-bind-tmpl=\"itemrefweight\"></div>\n        <div class=\"grid-row\">\n            <div class=\"col-12\">\n                <a class=\"itemref-weight-add\"><span class=\"icon-add\"></span> "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "add a new weight", options) : helperMissing.call(depth0, "__", "add a new weight", options)))
    + "</a>\n            </div>\n        </div>\n    </div>\n\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .itemref-item-session-control\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Item Session Control", options) : helperMissing.call(depth0, "__", "Item Session Control", options)))
    + "</h4>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl -->\n    <div class=\"itemref-item-session-control toggled\">\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl/maxAttempts -->\n        <div class=\"grid-row\">\n            <div class=\"col-5\">\n                <label for=\"itemref-max-attempts\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Max Attempts", options) : helperMissing.call(depth0, "__", "Max Attempts", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input name=\"itemref-max-attempts\" type=\"text\" data-increment=\"1\" data-min=\"0\" value=\"1\" data-bind=\"itemSessionControl.maxAttempts\" data-bind-encoder=\"number\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Controls the maximum number of attempts allowed. 0 means unlimited.", options) : helperMissing.call(depth0, "__", "Controls the maximum number of attempts allowed. 0 means unlimited.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl/showFeedback -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"itemref-show-feedback\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Show Feedback", options) : helperMissing.call(depth0, "__", "Show Feedback", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"itemref-show-feedback\" value=\"true\" data-bind=\"itemSessionControl.showFeedback\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint affects the visibility of feedback after the end of the last attempt.", options) : helperMissing.call(depth0, "__", "This constraint affects the visibility of feedback after the end of the last attempt.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n\n\n\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl/allowComment -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"itemref-allow-comment\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Comment", options) : helperMissing.call(depth0, "__", "Allow Comment", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"itemref-allow-comment\" value=\"true\"  data-bind=\"itemSessionControl.allowComment\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options) : helperMissing.call(depth0, "__", "This constraint controls whether or not the candidate is allowed to provide a comment on the item during the session. Comments are not part of the assessed responses.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl/allowSkipping -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"itemref-allow-skipping\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Allow Skipping", options) : helperMissing.call(depth0, "__", "Allow Skipping", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"itemref-allow-skipping\" value=\"true\" checked=\"checked\" data-bind=\"itemSessionControl.allowSkipping\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "If the candidate can skip the item, without submitting a response (default is true).", options) : helperMissing.call(depth0, "__", "If the candidate can skip the item, without submitting a response (default is true).", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/itemSessionControl/validateResponses -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"itemref-validate-responses\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Validate Responses", options) : helperMissing.call(depth0, "__", "Validate Responses", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"itemref-validate-responses\" value=\"true\" data-bind=\"itemSessionControl.validateResponses\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "The candidate is not allowed to submit invalid responses.", options) : helperMissing.call(depth0, "__", "The candidate is not allowed to submit invalid responses.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n    </div>\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .itemref-time-limits\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Time Limits", options) : helperMissing.call(depth0, "__", "Time Limits", options)))
    + "</h4>\n\n<!-- assessmentTest/timeLimits -->\n    <div class=\"itemref-time-limits toggled\">\n\n        <div class=\"lockedtime-container hidden\">\n\n            <div class=\"grid-row\">\n                <div class=\"col-5\">\n                    <label for=\"itemref-max-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum Duration", options) : helperMissing.call(depth0, "__", "Maximum Duration", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <input type=\"text\" name=\"max-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.maxTime\" data-bind-encoder=\"time\" />\n                </div>\n                <div class=\"col-1 help\">\n                    <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                    <div class=\"tooltip-content\">\n                        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Minimum duration : enforces the test taker to stay on the item for the given duration.", options) : helperMissing.call(depth0, "__", "Minimum duration : enforces the test taker to stay on the item for the given duration.", options)))
    + "<br>\n                        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum duration : the items times out when the duration reaches 0.", options) : helperMissing.call(depth0, "__", "Maximum duration : the items times out when the duration reaches 0.", options)))
    + "<br>\n                        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Locked duration  : guided navigation. The test transition to the next item once the duration reaches 0.", options) : helperMissing.call(depth0, "__", "Locked duration  : guided navigation. The test transition to the next item once the duration reaches 0.", options)))
    + "<br>\n                    </div>\n                </div>\n            </div>\n            <div class=\"locker\">\n                <button class=\"unlocked\" title='"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Link durations to activate the guided navigation", options) : helperMissing.call(depth0, "__", "Link durations to activate the guided navigation", options)))
    + "' ><span class=\"icon-unlink\"></span></button>\n            </div>\n            <div class=\"grid-row\">\n                <div class=\"col-5\">\n                    <label for=\"itemref-min-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Minimum Duration", options) : helperMissing.call(depth0, "__", "Minimum Duration", options)))
    + "</label>\n                </div>\n                <div class=\"col-6\">\n                    <input type=\"text\" name=\"min-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\"  data-bind=\"timeLimits.minTime\" data-bind-encoder=\"time\" />\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/timeLimits/maxTime -->\n        <div class=\"grid-row maxtime-container ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isLinear), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n            <div class=\"col-5\">\n                <label for=\"itemref-max-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum Duration", options) : helperMissing.call(depth0, "__", "Maximum Duration", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"max-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.maxTime\" data-bind-encoder=\"time\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Maximum duration for this item.", options) : helperMissing.call(depth0, "__", "Maximum duration for this item.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/timeLimits/minTime -->\n        <div class=\"grid-row mintime-container ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.isLinear), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n            <div class=\"col-5\">\n                <label for=\"min-time\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Minimum Duration", options) : helperMissing.call(depth0, "__", "Minimum Duration", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"min-time\" value=\"00:00:00\" data-duration=\"HH:mm:ss\" data-bind=\"timeLimits.minTime\" data-bind-encoder=\"time\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Minimum duration for this item.", options) : helperMissing.call(depth0, "__", "Minimum duration for this item.", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n<!-- assessmentTest/testPart/assessmentSection/sectionPart/timeLimits/allowLateSubmission -->\n        <div class=\"grid-row pseudo-label-box\">\n            <div class=\"col-5\">\n                <label for=\"itemref-allow-late-submission\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Late submission allowed", options) : helperMissing.call(depth0, "__", "Late submission allowed", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"itemref-allow-late-submission\" value=\"true\" data-bind=\"timeLimits.allowLateSubmission\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Whether a candidate's response that is beyond the maximum duration of the item should still be accepted.", options) : helperMissing.call(depth0, "__", "Whether a candidate's response that is beyond the maximum duration of the item should still be accepted.", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/itemref-props-weight', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"grid-row itemref-weight\">\n    <div class=\"col-9\">\n        <input data-bind=\"identifier\" data-validate=\"$notEmpty; $testIdFormat; $testIdAvailable(original=";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ");\" type=\"text\" value=\"";
  if (helper = helpers.identifier) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.identifier); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n    </div>\n    <div class=\"col-2\">\n        <input data-bind=\"value\" data-validate=\"$notEmpty; $numeric;\" type=\"text\" value=\"";
  if (helper = helpers.value) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.value); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-bind-encoder=\"float\" />\n    </div>\n    <div class=\"col-1\">\n        <a class=\"itemref-weight-remove\" data-delete=\":parent .itemref-weight\">\n            <span class=\"icon-bin\"></span>\n        </a>\n    </div>\n</div>";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/rubricblock-props', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <div class=\"rubric-feedback toggled\">\n\n        <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/feedback/activated -->\n        <div class=\"grid-row rubric-feedback-activated\">\n            <div class=\"col-5\">\n                <label for=\"activated\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Activated", options) : helperMissing.call(depth0, "__", "Activated", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <label>\n                    <input type=\"checkbox\" name=\"activated\" value=\"true\" data-bind=\"feedback.activated\" data-bind-encoder=\"boolean\" />\n                    <span class=\"icon-checkbox\"></span>\n                </label>\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the rubric block as a feedback block", options) : helperMissing.call(depth0, "__", "Set the rubric block as a feedback block", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n        <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/feedback/outcome -->\n        <div class=\"grid-row rubric-feedback-outcome\">\n            <div class=\"col-5\">\n                <label for=\"feedback-outcome\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Outcome", options) : helperMissing.call(depth0, "__", "Outcome", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"feedback-outcome\" data-bind=\"feedback.outcome\" data-bind-encoder=\"string\" data-validate=\"$pattern(pattern=^([a-zA-Z_][a-zA-Z0-9_\\.-]*)?$);\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set outcome identifier the feedback block is related to", options) : helperMissing.call(depth0, "__", "Set outcome identifier the feedback block is related to", options)))
    + "\n                </div>\n            </div>\n        </div>\n\n        <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/feedback/matchValue -->\n        <div class=\"grid-row rubric-feedback-match-value\">\n            <div class=\"col-5\">\n                <label for=\"feedback-match-value\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Match value", options) : helperMissing.call(depth0, "__", "Match value", options)))
    + "</label>\n            </div>\n            <div class=\"col-6\">\n                <input type=\"text\" name=\"feedback-match-value\" data-bind=\"feedback.matchValue\" data-bind-encoder=\"string\" data-validate=\"$pattern(pattern=^([a-zA-Z_][a-zA-Z0-9_\\.-]*)?$);\" />\n            </div>\n            <div class=\"col-1 help\">\n                <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n                <div class=\"tooltip-content\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the value of the outcome that will activate the feedback block", options) : helperMissing.call(depth0, "__", "Set the value of the outcome that will activate the feedback block", options)))
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"rubricblock-props props clearfix\">\n\n    <h3>"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Rubric Block", options) : helperMissing.call(depth0, "__", "Rubric Block", options)))
    + ": ";
  if (helper = helpers.orderIndex) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.orderIndex); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3>\n\n    <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/views -->\n    <!--\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"itemref-identifier\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Views", options) : helperMissing.call(depth0, "__", "Views", options)))
    + " <abbr title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Required field", options) : helperMissing.call(depth0, "__", "Required field", options)))
    + "\">*</abbr></label>\n        </div>\n        <div class=\"col-6\">\n            <select name=\"view\" multiple=\"multiple\" data-bind=\"views\">\n                <option value=\"author\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Author", options) : helperMissing.call(depth0, "__", "Author", options)))
    + "</option>\n                <option value=\"candidate\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Candidate", options) : helperMissing.call(depth0, "__", "Candidate", options)))
    + "</option>\n                <option value=\"proctor\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Proctor", options) : helperMissing.call(depth0, "__", "Proctor", options)))
    + "</option>\n                <option value=\"scorer\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Scorer", options) : helperMissing.call(depth0, "__", "Scorer", options)))
    + "</option>\n                <option value=\"testConstructor\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Test constructor", options) : helperMissing.call(depth0, "__", "Test constructor", options)))
    + "</option>\n                <option value=\"tutor\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Tutor", options) : helperMissing.call(depth0, "__", "Tutor", options)))
    + "</option>\n            </select>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Who can view the rubric block during the delivery.", options) : helperMissing.call(depth0, "__", "Who can view the rubric block during the delivery.", options)))
    + "\n            </div>\n        </div>\n    </div>\n    -->\n    <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/class -->\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"class\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Class", options) : helperMissing.call(depth0, "__", "Class", options)))
    + "</label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"class\" data-bind=\"class\" data-bind-encoder=\"string\" data-validate=\"$pattern(pattern=^([a-zA-Z_\\s][a-zA-Z0-9_\\s-]*)?$);\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the XHTML-QTI class of the rubric block.", options) : helperMissing.call(depth0, "__", "Set the XHTML-QTI class of the rubric block.", options)))
    + "\n            </div>\n        </div>\n    </div>\n\n    <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/id -->\n    <!--\n    <div class=\"grid-row\">\n        <div class=\"col-5\">\n            <label for=\"id\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Identifier", options) : helperMissing.call(depth0, "__", "Identifier", options)))
    + "</label>\n        </div>\n        <div class=\"col-6\">\n            <input type=\"text\" name=\"id\" data-bind=\"id\" data-bind-encoder=\"string\" data-validate=\"$pattern(pattern=^([a-zA-Z_\\s][a-zA-Z0-9_\\s-]*)?$);\" />\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Set the XHTML-QTI identifier of the rubric block.", options) : helperMissing.call(depth0, "__", "Set the XHTML-QTI identifier of the rubric block.", options)))
    + "\n            </div>\n        </div>\n    </div>\n    -->\n\n    <h4 class=\"toggler closed\" data-toggle=\"~ .rubric-feedback\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Feedback block", options) : helperMissing.call(depth0, "__", "Feedback block", options)))
    + "</h4>\n\n    <!--assessmentTest/testPart/assessmentSection/sectionPart/rubricBlock/feedback -->\n    ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.feedback), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;
  });
});


define('tpl!taoQtiTest/controller/creator/templates/category-presets', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n\n<h4 class=\"toggler closed\" data-toggle=\"~ .category-preset-group-";
  if (helper = helpers.groupId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.groupId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.groupLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.groupLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n\n<div class=\"category-preset-group-";
  if (helper = helpers.groupId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.groupId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " toggled\">\n    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.presets), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"grid-row pseudo-label-box category-preset\" data-qti-category=\"";
  if (helper = helpers.qtiCategory) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.qtiCategory); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        <div class=\"col-1\">\n            <label>\n                <input type=\"checkbox\" name=\"category-preset-";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" value=\"";
  if (helper = helpers.qtiCategory) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.qtiCategory); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n                <span class=\"icon-checkbox\"></span>\n            </label>\n        </div>\n        <div class=\"col-10\">\n            <label for=\"category-preset-";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</label>\n        </div>\n        <div class=\"col-1 help\">\n            <span class=\"icon-help\" data-tooltip=\"~ .tooltip-content\" data-tooltip-theme=\"info\"></span>\n            <div class=\"tooltip-content\">\n                ";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n            </div>\n        </div>\n    </div>\n    ";
  return buffer;
  }

  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });
});

define('taoQtiTest/controller/creator/templates/index',[
    'tpl!taoQtiTest/controller/creator/templates/testpart',
    'tpl!taoQtiTest/controller/creator/templates/section',
    'tpl!taoQtiTest/controller/creator/templates/rubricblock',
    'tpl!taoQtiTest/controller/creator/templates/itemref',
    'tpl!taoQtiTest/controller/creator/templates/outcomes',
    'tpl!taoQtiTest/controller/creator/templates/test-props',
    'tpl!taoQtiTest/controller/creator/templates/testpart-props',
    'tpl!taoQtiTest/controller/creator/templates/section-props',
    'tpl!taoQtiTest/controller/creator/templates/itemref-props',
    'tpl!taoQtiTest/controller/creator/templates/itemref-props-weight',
    'tpl!taoQtiTest/controller/creator/templates/rubricblock-props',
    'tpl!taoQtiTest/controller/creator/templates/category-presets'
],
function(
    testPart,
    section,
    rubricBlock,
    itemRef,
    outcomes,
    testProps,
    testPartProps,
    sectionProps,
    itemRefProps,
    itemRefPropsWeight,
    rubricBlockProps,
    categoryPresets
){
    'use strict';

    /**
     * Expose all the templates used by the test creator
     * @exports taoQtiTest/controller/creator/templates/index
     */
    return {
        'testpart'      : testPart,
        'section'       : section,
        'itemref'       : itemRef,
        'rubricblock'   : rubricBlock,
        'outcomes'      : outcomes,
        'properties'    : {
            'test'      : testProps,
            'testpart'  : testPartProps,
            'section'   : sectionProps,
            'itemref'   : itemRefProps,
            'itemrefweight'     : itemRefPropsWeight,
            'rubricblock'       : rubricBlockProps,
            'categorypresets'  : categoryPresets
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/property',[
    'jquery',
    'ui',
    'core/databinder',
    'taoQtiTest/controller/creator/templates/index'
],
function($, ui, DataBinder, templates){
    'use strict';

    /**
     * @callback PropertyViewCallback
     * @param {propertyView} propertyView - the view object
     */

    /**
     * The PropertyView setup the property panel component
     *
     * @exports taoQtiTest/controller/creator/views/property
     */
    var propView = function propView(tmplName, model){
        var $container = $('.test-creator-props');
        var template = templates.properties[tmplName];
        var $view;

        /**
         * Opens the view for the 1st time
         */
        var open = function propOpen(){
            var databinder,
                binderOptions = {
                    templates: templates.properties
                };
            $container.children('.props').hide().trigger('propclose.propview');
            $view = $(template(model)).appendTo($container).filter('.props');

            //start listening for DOM compoenents inside the view
            ui.startDomComponent($view);

            //start the data binding
            databinder = new DataBinder($view, model, binderOptions);
            databinder.bind();

            propValidation();

            $view.trigger('propopen.propview');
        };

       /**
        * Get the view container element
        * @returns {jQueryElement}
        */
        var getView = function propGetView(){
            return $view;
        };

       /**
        * Check wheter the view is displayed
        * @returns {boolean} true id opened
        */
        var isOpen = function propIsOpen(){
            return $view.css('display') !== 'none';
        };

       /**
        * Bind a callback on view open
        * @param {PropertyViewCallback} cb
        */
        var onOpen = function propOnOpen(cb){
            $view.on('propopen.propview', function(e){
                e.stopPropagation();
                cb();
            });
        };


        /**
         * Bind a callback on view close
         * @param {PropertyViewCallback} cb
         */
        var onClose = function propOnClose(cb){
            $view.on('propclose.propview', function(e){
                e.stopPropagation();
                cb();
            });
        };

        /**
         * Removes the property view
         */
        var destroy = function propDestroy(){
            $view.remove();
        };

        /**
         * Toggles the property view display
         */
        var toggle = function propToggle(){
            $container.children('.props').not($view).hide().trigger('propclose.propview');
            if(isOpen()){
                $view.hide().trigger('propclose.propview');
            } else {
                $view.show().trigger('propopen.propview');
            }
        };

       /**
        * Set up the validation on the property view
        * @private
        */
        function propValidation() {
            var $togglers;
            $view.on('validated.group', function(e, isValid){
                if(e.namespace === 'group'){
                    $togglers = $('#test-creator .property-toggler, #saver');
                    if(isValid === true){
                        $togglers.removeClass('disabled');
                    } else {
                        $togglers.addClass('disabled');
                    }
                }
            });
            $view.groupValidator();
        }

        return {
            open : open,
            getView : getView,
            isOpen : isOpen,
            onOpen : onOpen,
            onClose : onClose,
            destroy : destroy,
            toggle : toggle
        };
    };

    return propView;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/actions',[
'jquery',
'taoQtiTest/controller/creator/views/property'],
function($, propertyView){
    'use strict';

    var disabledClass = 'disabled';
    var activeClass = 'active';
    var btnOnClass = 'tlb-button-on';

    /**
     * Set up the property view for an element
     * @param {jQueryElement} $container - that contains the property opener
     * @param {String} template - the name of the template to give to the propertyView
     * @param {Object} model - the model to bind
     * @param {PropertyViewCallback} cb - execute at view setup phase
     */
    function properties ($container, template, model, cb) {
        var propView = null;
        $container.find('.property-toggler').on('click', function(e){
            e.preventDefault();
            var $elt = $(this);
            if(!$(this).hasClass(disabledClass)){

                $elt.blur(); //to remove the focus

                if(propView === null){

                    $container.addClass(activeClass);
                    $elt.addClass(btnOnClass);

                    propView = propertyView(template, model);
                    propView.open();

                    propView.onOpen(function(){
                        $container.addClass(activeClass);
                        $elt.addClass(btnOnClass);
                    });
                    propView.onClose(function(){
                        $container.removeClass(activeClass);
                        $elt.removeClass(btnOnClass);
                    });

                    if(typeof cb === 'function'){
                        cb(propView);
                    }
                } else {
                    propView.toggle();
                }
            }
        });
    }


    /**
     * Enable to move an element
     * @param {jQueryElement} $actionContainer - where the mover is
     * @param {String} containerClass - the cssClass of the element container
     * @param {String} elementClass - the cssClass to identify elements
     */
    function move ($actionContainer, containerClass, elementClass) {
        var $element = $actionContainer.parents('.' + elementClass);
        var $container = $element.parents('.' + containerClass );

        //move up an element
        $('.move-up', $actionContainer).click(function(e){
            var $elements, index;

            //prevent default and click during animation
            e.preventDefault();
            if($element.is(':animated')){
                return false;
            }

            //get the position
            $elements = $('.' + elementClass, $container);
            index = $elements.index($element);
            if (index > 0) {
                $element.fadeOut(200, function(){
                    $element
                        .insertBefore($('.' + elementClass + ' :eq(' + (index - 1) + ')', $container))
                        .fadeIn(400, function(){
                            $container.trigger('change');
                        });
                });
            }
        });

        //move down an element
        $('.move-down', $actionContainer).click(function(e){
            var $elements, index;

            //prevent default and click during animation
            e.preventDefault();
            if($element.is(':animated')){
                return false;
            }

            //get the position
            $elements = $('.' + elementClass, $container);
            index = $elements.index($element);
            if (index < ($elements.length - 1) && $elements.length > 1) {
                $element.fadeOut(200, function(){
                    $element
                        .insertAfter($('.' + elementClass + ' :eq(' + (index + 1) + ')', $container))
                        .fadeIn(400, function(){
                            $container.trigger('change');
                        });
                });
            }
        });
    }

    /**
     * Update the movable state of an element
     * @param {jQueryElement} $container - the movable elements (scopped)
     * @param {String} elementClass - the cssClass to identify elements
     * @param {String} actionContainerElt - the element name that contains the actions
     */
    function movable ($container, elementClass, actionContainerElt){
        $container.each(function(){
            var $elt = $(this);
            var $actionContainer = $(actionContainerElt, $elt);

            var index = $container.index($elt);
            var $moveUp = $('.move-up', $actionContainer);
            var $moveDown = $('.move-down', $actionContainer);

            //only one test part, no moving
            if( $container.length === 1 ){
                $moveUp.addClass(disabledClass);
                $moveDown.addClass(disabledClass);

            //testpart is the first, only moving down
            } else if(index === 0) {
                $moveUp.addClass(disabledClass);
                $moveDown.removeClass(disabledClass);

            //testpart is the lasst, only moving up
            } else if ( index >= ($container.length - 1) ) {
                $moveDown.addClass(disabledClass);
                $moveUp.removeClass(disabledClass);

            //or enable moving top/bottom
            } else {
                $moveUp.removeClass(disabledClass);
                $moveDown.removeClass(disabledClass);
            }
         });
    }

    /**
     * Update the removable state of an element
     * @param {jQueryElement} $container - that contains the removable action
     * @param {String} actionContainerElt - the element name that contains the actions
     */
    function removable ($container, actionContainerElt){
        $container.each(function(){
            var $elt = $(this);
            var $actionContainer = $(actionContainerElt, $elt);
            var $delete = $('[data-delete]', $actionContainer);

            if($container.length <= 1){
                $delete.addClass(disabledClass);
            } else {
                $delete.removeClass(disabledClass);
            }
        });
    }

    /**
     * Disable all the actions of the target
     * @param {jQueryElement} $container - that contains the the actions
     * @param {String} actionContainerElt - the element name that contains the actions
     */
    function disable($container, actionContainerElt){
        $container.find(actionContainerElt).find('[data-delete],.move-up,.move-down').addClass(disabledClass);
    }

    /**
     * Enable all the actions of the target
     * @param {jQueryElement} $container - that contains the the actions
     * @param {String} actionContainerElt - the element name that contains the actions
     */
    function enable($container, actionContainerElt){
        $container.find(actionContainerElt).find('[data-delete],.move-up,.move-down').removeClass(disabledClass);
    }

    /**
     * The actions gives you shared behavior for some actions.
     *
     * @exports taoQtiTest/controller/creator/views/actions
     */
    return {
        properties  : properties,
        move        : move,
        removable   : removable,
        movable     : movable,
        disable     : disable,
        enable      : enable
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */
/**
 * This helper manages the category selection UI:
 * - either via a text entry field that allow to enter any custom categories
 * - either via displaying grouped checkboxes that allow to select any categories presets
 * All categories are then grouped and given to this object's listeners, as they will later end up in the same model field.
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/categorySelector',[
    'jquery',
    'lodash',
    'i18n',
    'core/eventifier',
    'ui/tooltip',
    'taoQtiTest/controller/creator/templates/index',
    'select2'
], function($, _, __, eventifier, tooltip, templates) {
    'use strict';

    var allPresets = [],
        allQtiCategoriesPresets = [];


    function categorySelectorFactory($container) {
        var categorySelector,

            $presetsContainer = $container.find('.category-presets'),
            $presetsCheckboxes,
            $customCategoriesSelect = $container.find('[name=category-custom]');

        /**
         * Read the form state from the DOM and trigger an event with the result, so the listeners can update the item/section model
         * @fires categorySelector#category-change
         */
        function updateCategories() {
            var selectedCategories,
                indeterminatedCategories,

                presetSelected = $container
                    .find('.category-preset input:checked')
                    .toArray()
                    .map(function(categoryEl) {
                        return categoryEl.value;
                    }),
                presetIndeterminate = $container
                    .find('.category-preset input:indeterminate')
                    .toArray()
                    .map(function(categoryEl) {
                        return categoryEl.value;
                    }),
                customSelected = $customCategoriesSelect.siblings('.select2-container').find('.select2-search-choice').not('.partial')
                    .toArray()
                    .map(function(categoryEl) {
                        return categoryEl.textContent && categoryEl.textContent.trim();
                    }),
                customIndeterminate = $customCategoriesSelect.siblings('.select2-container').find('.select2-search-choice.partial')
                    .toArray()
                    .map(function(categoryEl) {
                        return categoryEl.textContent && categoryEl.textContent.trim();
                    });

            selectedCategories = presetSelected.concat(customSelected);
            indeterminatedCategories = presetIndeterminate.concat(customIndeterminate);

            /**
             * @event categorySelector#category-change
             * @param {String[]} allCategories
             * @param {String[]} indeterminate
             */
            this.trigger('category-change', selectedCategories, indeterminatedCategories);
        }

        categorySelector = {
            /**
             * Create the category selection form
             *
             * @param {Array} [currentCategories] - all categories currently associated to the item. If applied to a section,
             * contains all the categories applied to at least one item of the section.
             */
            createForm: function createForm(currentCategories) {
                var self = this,
                    presetsTpl = templates.properties.categorypresets,
                    customCategories = _.difference(currentCategories, allQtiCategoriesPresets);

                // add preset checkboxes
                $presetsContainer.append(
                    presetsTpl(allPresets)
                );

                $presetsContainer.on('click', function(e) {
                    var $preset = $(e.target).closest('.category-preset'),
                        $checkbox;

                    if ($preset.length) {
                        $checkbox = $preset.find('input');
                        $checkbox.prop('indeterminate', false);

                        _.defer(function() {
                            updateCategories.call(self);
                        });
                    }
                });

                // init custom categories field
                $customCategoriesSelect.select2({
                    width: '100%',
                    tags : customCategories,
                    multiple : true,
                    tokenSeparators: [",", " ", ";"],
                    formatNoMatches : function(){
                        return __('Enter a custom category');
                    },
                    maximumInputLength : 32
                }).on('change', function(){
                    updateCategories.call(self);
                });

                // enable help tooltips
                tooltip($container);
            },

            /**
             * Check/Uncheck boxes and fill the custom category field to match the new model
             * @param {String[]} selected - categories associated with an item, or with all the items of the same section
             * @param {String[]} [indeterminate] - categories in an indeterminate state at a section level
             */
            updateFormState: function updateFormState(selected, indeterminate) {
                var customCategories;

                indeterminate = indeterminate || [];

                customCategories = _.difference(selected.concat(indeterminate), allQtiCategoriesPresets);

                // Preset categories

                $presetsCheckboxes = $container.find('.category-preset input');
                $presetsCheckboxes.each(function() {
                    var category = this.value;

                    this.indeterminate = false;
                    this.checked = false;

                    if (indeterminate.indexOf(category) !== -1) {
                        this.indeterminate = true;
                    } else if (selected.indexOf(category) !== -1) {
                        this.checked = true;
                    }
                });

                // Custom categories

                $customCategoriesSelect.select2('val', customCategories);

                $customCategoriesSelect.siblings('.select2-container').find('.select2-search-choice').each(function(){
                    var $li = $(this);
                    var content = $li.find('div').text();
                    if(indeterminate.indexOf(content) !== -1){
                        $li.addClass('partial');
                    }
                });
            }
        };

        eventifier(categorySelector);

        return categorySelector;
    }

    /**
     * @param {Object[]} presets - expected format:
     * [
     *  {
     *      groupId: 'navigation',
     *      groupLabel: 'Test Navigation',
     *      presets: [
     *          {
     *              id: 'nextPartWarning',
     *              label: 'Next Part Warning',
     *              qtiCategory : 'x-tao-option-nextPartWarning',
     *              description : 'Displays a warning before the user finishes a part'
 *              },
     *          ...
     *      ]
     *  },
     *  ...
     * ]
     */
    categorySelectorFactory.setPresets = function setPresets(presets) {
        if (_.isArray(presets)) {
            allPresets = presets;
            allQtiCategoriesPresets = extractCategoriesFromPresets();
        }
    };

    /**
     * Extract the qtiCategory property of all presets of all groups
     * @returns {String[]}
     */
    function extractCategoriesFromPresets() {
        return allPresets.reduce(function (prev, current) {
            var groupIds = _.pluck(current.presets, 'qtiCategory');
            return prev.concat(groupIds);
        }, []);
    }

    return categorySelectorFactory;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA;
 */
define('taoQtiTest/controller/creator/helpers/sectionCategory',[
    'lodash',
    'i18n',
    'core/errorHandler'
], function (_, __, errorHandler){

    'use strict';

    var _ns = '.sectionCategory';

    /**
     * Check if the given object is a valid assessmentSection model object
     *
     * @param {object} model
     * @returns {boolean}
     */
    function isValidSectionModel(model){
        return (_.isObject(model) && model['qti-type'] === 'assessmentSection' && _.isArray(model.sectionParts));
    }

    /**
     * Set an array of categories to the section model (affect the childen itemRef)
     *
     * @param {object} model
     * @param {array} selected - all categories active for the whole section
     * @param {array} partial - only categories in an indeterminate state
     * @returns {undefined}
     */
    function setCategories(model, selected, partial){

        var toRemove,
            toAdd,
            currentCategories = getCategories(model);

        partial = partial || [];

        //the categories that are no longer in the new list of categories should be removed
        toRemove = _.difference(currentCategories.all, selected.concat(partial));

        //the categories that are not in the current categories collection should be added to the children
        toAdd = _.difference(selected, currentCategories.propagated);

        //process the modification
        addCategories(model, toAdd);
        removeCategories(model, toRemove);
    }

    /**
     * Get the categories assign to the section model, infered by its interal itemRefs
     *
     * @param {object} model
     * @returns {object}
     */
    function getCategories(model){
        var categories,
            arrays,
            union,
            propagated,
            partial;

        if(isValidSectionModel(model)){
            categories = _.map(model.sectionParts, function (itemRef){
                if(itemRef['qti-type'] === 'assessmentItemRef' && _.isArray(itemRef.categories)){
                    return _.compact(itemRef.categories);
                }
            });
            //array of categories
            arrays = _.values(categories);
            union = _.union.apply(null, arrays);

            //categories that are common to all itemRef
            propagated = _.intersection.apply(null, arrays);

            //the categories that are only partially covered on the section level : complementary of "propagated"
            partial = _.difference(union, propagated);

            return {
                all : union.sort(),
                propagated : propagated.sort(),
                partial : partial.sort()
            };
        }else{
            errorHandler.throw(_ns, 'invalid tool config format');
        }
    }

    /**
     * Add an array of categories to a section model (affect the childen itemRef)
     *
     * @param {object} model
     * @param {array} categories
     * @returns {undefined}
     */
    function addCategories(model, categories){
        if(isValidSectionModel(model)){
            _.each(model.sectionParts, function (itemRef){
                if(itemRef['qti-type'] === 'assessmentItemRef'){
                    if(!_.isArray(itemRef.categories)){
                        itemRef.categories = [];
                    }
                    itemRef.categories = _.union(itemRef.categories, categories);
                }
            });
        }else{
            errorHandler.throw(_ns, 'invalid tool config format');
        }
    }

    /**
     * Remove an array of categories from a section model (affect the childen itemRef)
     *
     * @param {object} model
     * @param {array} categories
     * @returns {undefined}
     */
    function removeCategories(model, categories){
        if(isValidSectionModel(model)){
            _.each(model.sectionParts, function (itemRef){
                if(itemRef['qti-type'] === 'assessmentItemRef' && _.isArray(itemRef.categories)){
                    itemRef.categories = _.difference(itemRef.categories, categories);
                }
            });
        }else{
            errorHandler.throw(_ns, 'invalid tool config format');
        }
    }

    return {
        isValidSectionModel : isValidSectionModel,
        setCategories : setCategories,
        getCategories : getCategories,
        addCategories : addCategories,
        removeCategories : removeCategories
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/qtiTest',[
    'lodash',
    'i18n',
    'taoQtiTest/controller/creator/helpers/outcome',
    'taoQtiTest/controller/creator/helpers/qtiElement'
], function(_, __, outcomeHelper, qtiElementHelper){
    'use strict';

    //Identifiers must be unique across
    //those QTI types
    var qtiTypesForUniqueIds = [
        'assessmentTest',
        'testPart',
        'assessmentSection',
        'assessmentItemRef'
    ];

    /**
     * Utility to manage the QTI Test model
     * @exports taoQtiTest/controller/creator/qtiTestHelper
     */
    var qtiTestHelper = {

        /**
         * Extracts the identifiers from a QTI model
         * @param {Object|Object[]} model - the JSON QTI model
         * @param {String[]} [includesOnlyTypes] - list of qti-type to include, exclusively
         * @param {String[]} [excludeTypes] - list of qti-type to exclude, it excludes the children too
         * @returns {Object[]} a collection of identifiers (with some meta), if the id is not unique it will appear multiple times, as extracted.
         */
        extractIdentifiers : function extractIdentifiers(model, includesOnlyTypes, excludeTypes){

            var identifiers = [];

            var extract = function extract( element ) {
                if(element && _.has(element, 'identifier') && _.isString(element.identifier)){
                    if(!includesOnlyTypes.length || _.contains(includesOnlyTypes, element['qti-type'])){
                        identifiers.push({
                            identifier : element.identifier.toUpperCase(),
                            originalIdentifier :  element.identifier,
                            type      : element['qti-type'],
                            label     : element.title || element.identifier
                        });
                    }
                }
                _.forEach(element, function(subElement) {
                    if(_.isPlainObject(subElement) || _.isArray(subElement)){
                        if(!excludeTypes.length || !_.contains(excludeTypes, subElement['qti-type']) ){
                            extract(subElement);
                        }
                    }
                });
            };

            if (_.isPlainObject(model) || _.isArray(model)) {
                excludeTypes = excludeTypes || [];
                includesOnlyTypes = includesOnlyTypes || [];

                extract(model);
            }
            return identifiers;
        },

        /**
         * Get the list of unique identifiers for the given model.
         * @param {Object|Object[]} model - the JSON QTI model
         * @param {String[]} [includesOnlyTypes] - list of qti-type to include, exclusively
         * @param {String[]} [excludeTypes] - list of qti-type to exclude, it excludes the children too
         * @returns {String[]} the list of unique identifiers
         */
        getIdentifiers : function getIdentifiers(model, includesOnlyTypes, excludeTypes){
            return _.uniq(_.pluck(this.extractIdentifiers(model, includesOnlyTypes, excludeTypes), 'identifier'));
        },

        /**
         * Get the list of identifiers for a given QTI type, only.
         * @param {Object|Object[]} model - the JSON QTI model
         * @param {String} qtiType - the type of QTI element to get the identifiers.
         * @returns {String[]} the list of unique identifiers
         */
        getIdentifiersOf : function getIdentifiersOf(model, qtiType){
            return this.getIdentifiers(model, [qtiType]);
        },

        /**
         * Get a valid and available QTI identifier for the given type
         * @param {Object|Object[]} model - the JSON QTI model to check the existing IDs
         * @param {String} qtiType - the type of element you want an id for
         * @param {String} [suggestion] - the default pattern body, we use the type otherwise
         * @returns {String} the generated identifier
         */
        getAvailableIdentifier : function getAvailableIdentifier(model, qtiType, suggestion){
            var index = 1;
            var glue =  '-';
            var identifier;
            var current;
            if(_.contains(qtiTypesForUniqueIds, qtiType)){
                current = this.getIdentifiers(model, qtiTypesForUniqueIds);
            } else {
                current = this.getIdentifiersOf(model, qtiType);
            }

            suggestion = suggestion || qtiType;

            do {
                identifier = suggestion +  glue + (index++);
            } while(_.contains(current, identifier.toUpperCase()));

            return identifier;
        },

        /**
         * Gives you a validator that check QTI id format
         * @returns {Object} the validator
         */
        idFormatValidator : function idFormatValidator(){
            var qtiIdPattern = /^[_a-zA-Z]{1}[a-zA-Z0-9\-._]{0,31}$/i;
            return {
                name : 'idFormat',
                message : __('is not a valid identifier (alphanum, underscore, dash and dots)'),
                validate : function(value, callback){
                    if(typeof callback === 'function'){
                        callback(qtiIdPattern.test(value));
                    }
                }
            };
        },

        /**
         * Gives you a validator that check QTI id format of the test (it is different from the others...)
         * @returns {Object} the validator
         */
        testidFormatValidator : function testidFormatValidator(){
            var qtiTestIdPattern = /^\S+$/;
            return {
                name : 'testIdFormat',
                message : __('is not a valid identifier (everything except spaces)'),
                validate : function(value, callback){
                    if(typeof callback === 'function'){
                        callback(qtiTestIdPattern.test(value));
                    }
                }
            };
        },

        /**
         * Gives you a validator that check if a QTI id is available
         * @param {Object} modelOverseer - let's you get the data model
         * @returns {Object} the validator
         */
        idAvailableValidator : function idAvailableValidator(modelOverseer){
            var self = this;

            return {
                name : 'testIdAvailable',
                message : __('is already used in the test.'),
                validate : function(value, callback){
                    var counts = {};
                    var key    = value.toUpperCase();
                    var identifiers = self.extractIdentifiers(modelOverseer.getModel(), qtiTypesForUniqueIds);
                    if(typeof callback === 'function'){
                        counts = _.countBy(identifiers, 'identifier');
                        //the identifier list always contains itself
                        //so we check if another one is identical (ie. >= 2)
                        callback(typeof counts[key] === 'undefined' || counts[key] < 2);
                    }
                }
            };
        },

        /**
         * Does the value contains the type type
         * @param {Object} value
         * @param {string} type
         * @returns {boolean}
         */
        filterQtiType : function filterQtiType (value, type){
            return value['qti-type'] && value['qti-type'] === type;
        },

        /**
         * Add the 'qti-type' properties to object that miss it, using the parent key name
         * @param {Object|Array} collection
         * @param {string} parentType
         */
        addMissingQtiType : function addMissingQtiType(collection, parentType) {
            var self = this;
            _.forEach(collection, function(value, key) {
                if (_.isObject(value) && !_.isArray(value) && !_.has(value, 'qti-type')) {
                    if (_.isNumber(key)) {
                        if (parentType) {
                            value['qti-type'] = parentType;
                        }
                    } else {
                        value['qti-type'] = key;
                    }
                }
                if (_.isArray(value)) {
                    self.addMissingQtiType(value, key.replace(/s$/, ''));
                } else if (_.isObject(value)) {
                    self.addMissingQtiType(value);
                }
            });
        },

        /**
         * Applies consolidation rules to the model
         * @param {Object} model
         * @returns {Object}
         */
        consolidateModel : function consolidateModel(model){
            if(model && model.testParts && _.isArray(model.testParts)){

                _.forEach(model.testParts, function(testPart) {

                    if(testPart.assessmentSections && _.isArray(testPart.assessmentSections)){

                        _.forEach(testPart.assessmentSections, function(assessmentSection) {

                            //remove ordering is shuffle is false
                            if(assessmentSection.ordering &&
                                typeof assessmentSection.ordering.shuffle !== 'undefined' && assessmentSection.ordering.shuffle === false){
                                delete assessmentSection.ordering;
                            }

                            // clean categories (QTI identifier can't be empty string)
                            if(assessmentSection.sectionParts && _.isArray(assessmentSection.sectionParts)) {
                                _.forEach(assessmentSection.sectionParts, function(part) {
                                    if(part.categories && _.isArray(part.categories) && (part.categories.length === 0 || part.categories[0].length === 0)) {
                                        part.categories = [];
                                    }
                                });
                            }

                            if(assessmentSection.rubricBlocks && _.isArray(assessmentSection.rubricBlocks)) {

                                //remove rubric blocks if empty
                                if (assessmentSection.rubricBlocks.length === 0 ||
                                    (assessmentSection.rubricBlocks.length === 1 && assessmentSection.rubricBlocks[0].content.length === 0) ) {

                                    delete assessmentSection.rubricBlocks;
                                }
                                //ensure the view attribute is present
                                else if(assessmentSection.rubricBlocks.length > 0){
                                    _.forEach(assessmentSection.rubricBlocks, function(rubricBlock){
                                        rubricBlock.views = ['candidate'];
                                        //change once views are supported
                                        //if(rubricBlock && rubricBlock.content && (!rubricBlock.views || (_.isArray(rubricBlock.views) && rubricBlock.views.length === 0))){
                                        //rubricBlock.views = ['candidate'];
                                        //}
                                    });
                                }
                            }
                        });
                    }
                });
            }
            return model;
        },

        /**
         * Validates the provided model
         * @param {Object} model
         * @throws {Error} if the model is not valid
         */
        validateModel: function validateModel(model) {
            var identifiers = this.extractIdentifiers(model, qtiTypesForUniqueIds);
            var nonUniqueIdentifiers = 0;
            var outcomes = _.indexBy(outcomeHelper.listOutcomes(model));
            var messageDetails = '';

            _(identifiers)
                .countBy('identifier')
                .forEach(function(count, id){
                    if(count > 1){
                        nonUniqueIdentifiers++;
                        messageDetails += '\n' + id.originalIdentifier + ' : ' +
                                          id.type + ' ' +
                                          id.label;
                    }
                });
            if(nonUniqueIdentifiers.length > 1){
                throw new Error(__('The following identifiers are not unique accross the test : %s', messageDetails));
            }

            _.forEach(model.testParts, function (testPart) {
                _.forEach(testPart.assessmentSections, function (assessmentSection) {
                    _.forEach(assessmentSection.rubricBlocks, function (rubricBlock) {
                        var feedbackBlock = qtiElementHelper.lookupElement(rubricBlock, 'rubricBlock.div.feedbackBlock', 'content');
                        if (feedbackBlock && !outcomes[feedbackBlock.outcomeIdentifier]) {
                            throw new Error(__('The outcome "%s" does not exist, but it is referenced by a feedback block!', feedbackBlock.outcomeIdentifier));
                        }
                    });
                });
            });
        }
    };

    return  qtiTestHelper;
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/itemref',[
    'jquery',
    'lodash',
    'i18n',
    'taoQtiTest/controller/creator/views/actions',
    'taoQtiTest/controller/creator/helpers/categorySelector',
    'taoQtiTest/controller/creator/helpers/sectionCategory',
    'taoQtiTest/controller/creator/helpers/qtiTest',
    'taoQtiTest/controller/creator/templates/index'
],
function(
    $,
    _,
    __,
    actions,
    categorySelectorFactory,
    sectionCategory,
    qtiTestHelper,
    templates
){
    'use strict';

    /**
     * We need to resize the itemref in case of long labels
     */
    var resize = _.throttle(function resize(){
        var $refs = $('.itemrefs').first();
        var $actions = $('.itemref .actions').first();
        var width = $refs.innerWidth() - $actions.outerWidth();
        $('.itemref > .title').width(width);
    }, 100);

    /**
     * Set up an item ref: init action behaviors. Called for each one.
     *
     * @param {Object} creatorContext
     * @param {Object} refModel - the data model to bind to the item ref
     * @param {Object} sectionModel - the parent data model to inherit
     * @param {Object} partModel - the model of the parent's test part
     * @param {jQueryElement} $itemRef - the itemRef element to set up
     */
    function setUp (creatorContext, refModel, sectionModel, partModel, $itemRef) {

        var modelOverseer = creatorContext.getModelOverseer();
        var config = modelOverseer.getConfig()  || {};
        var $actionContainer = $('.actions', $itemRef);

        // set item session control to use test part options if section level isn't set
        if (!refModel.itemSessionControl) {
            refModel.itemSessionControl = {};
        }
        _.defaults(refModel.itemSessionControl, sectionModel.itemSessionControl);

        refModel.isLinear = partModel.navigationMode === 0;

        actions.properties($actionContainer, 'itemref', refModel, propHandler);
        actions.move($actionContainer, 'itemrefs', 'itemref');

        resize();

        /**
         * Set up the time limits behaviors :
         *  - linear test part: display the minTime field
         *  - linear + guided nav option : display the minTime field + the lock
         *  - otherwise only the maxTime field
         * @param {propView} propView - the view object
         */
        function timeLimitsProperty(propView){
            var $view = propView.getView();

            //target elements
            var $minTimeContainer    = $('.mintime-container', $view);
            var $maxTimeContainer    = $('.maxtime-container', $view);
            var $lockedTimeContainer = $('.lockedtime-container', $view);
            var $locker              = $('.locker button', $lockedTimeContainer);
            var $durationFields      = $(':text[data-duration]', $lockedTimeContainer);
            var $minTimeField        = $(':text[name="min-time"]', $lockedTimeContainer);
            var $maxTimeField        = $(':text[name="max-time"]', $lockedTimeContainer);

            /**
             * Sync min value to max value, trigger change to sync the component.
             * Need to temporally remove the other handler to prevent infinite loop
             */
            var minToMaxHandler = _.throttle(function minToMax(){
                $maxTimeField.off('change.sync');
                $maxTimeField.val($minTimeField.val()).trigger('change');
                _.defer(function(){
                    $maxTimeField.on('change.sync', minToMaxHandler);
                });
            }, 200);

            /**
             * Sync max value to min value, trigger change to sync the component.
             * Need to temporally remove the other handler to prevent infinite loop
             */
            var maxToMinHandler = _.throttle(function maxToMin(){
                $minTimeField.off('change.sync');
                $minTimeField.val($maxTimeField.val()).trigger('change');
                _.defer(function(){
                    $minTimeField.on('change.sync', minToMaxHandler);
                });
            }, 200);

            /**
             * Lock the timers
             */
            var lockTimers = function lockTimers(){
                $locker.removeClass('unlocked')
                       .addClass('locked')
                       .attr('title', __('Unlink to use sperated durations'));

                //sync min to max
                $minTimeField.val($maxTimeField.val()).trigger('change');

                //keep both in sync
                $minTimeField.on('change.sync', minToMaxHandler);
                $maxTimeField.on('change.sync', maxToMinHandler);
            };

            /**
             * Unlock the timers
             */
            var unlockTimers = function unlockTimers(){
                $locker.removeClass('locked')
                       .addClass('unlocked')
                       .attr('title', __('Link durations to activate the guided navigation'));

                $durationFields.off('change.sync');
                $minTimeField.val('00:00:00').trigger('change');
            };

            /**
             * Toggle the timelimits modes max, min + max, min + max + locked
             */
            var toggleTimeContainers = function toggleTimeContainers(){
                refModel.isLinear = partModel.navigationMode === 0;
                if(refModel.isLinear && config.guidedNavigation){
                    $minTimeContainer.addClass('hidden');
                    $maxTimeContainer.addClass('hidden');
                    $lockedTimeContainer.removeClass('hidden');
                    if($minTimeField.val() === $maxTimeField.val() && $maxTimeField.val() !== '00:00:00'){
                        lockTimers();
                    }
                    $locker.on('click', function(e){
                        e.preventDefault();

                        if($locker.hasClass('locked')){
                            unlockTimers();
                        } else {
                            lockTimers();
                        }
                    });
                } else if (refModel.isLinear){
                    $lockedTimeContainer.addClass('hidden');
                    $minTimeContainer.removeClass('hidden');
                    $maxTimeContainer.removeClass('hidden');
                } else {
                    $lockedTimeContainer.addClass('hidden');
                    $minTimeContainer.addClass('hidden');
                    $maxTimeContainer.removeClass('hidden');
                }
            };

            //if the testpart changes it's navigation mode
            modelOverseer.on('testpart-change', function(){
                toggleTimeContainers();
            });

            toggleTimeContainers();

            //chek if min <= maw
            $durationFields.on('change.check', function(){
                if( refModel.timeLimits.minTime > 0 &&
                    refModel.timeLimits.maxTime > 0 &&
                    refModel.timeLimits.minTime > refModel.timeLimits.maxTime ) {

                    $minTimeField.parent('div').find('.duration-ctrl-wrapper').addClass('brd-danger');
                } else {
                    $minTimeField.parent('div').find('.duration-ctrl-wrapper').removeClass('brd-danger');
                }
            });
        }

        /**
         * Set up the category property
         * @private
         * @param {jQueryElement} $view - the $view object containing the $select
         */
        function categoriesProperty($view){
            var categorySelector = categorySelectorFactory($view),
                $categoryField = $view.find('[name="itemref-category"]');

            categorySelector.createForm();
            categorySelector.updateFormState(refModel.categories);

            $view.on('propopen.propview', function(){
                categorySelector.updateFormState(refModel.categories);
            });

            categorySelector.on('category-change', function(selected) {
                // Let the binder update the model by going through the category hidden field
                $categoryField.val(selected.join(','));
                $categoryField.trigger('change');

                modelOverseer.trigger('category-change', selected);
            });
        }

        /**
         * Setup the weights properties
         */
        function weightsProperty(propView) {
            var $view = propView.getView(),
                $weightList = $view.find('[data-bind-each="weights"]'),
                weightTpl = templates.properties.itemrefweight;

            $view.find('.itemref-weight-add').on('click', function(e) {
                var defaultData = {
                    value: 1,
                    'qti-type' : 'weight',
                    identifier: (refModel.weights.length === 0) ? 'WEIGHT' : qtiTestHelper.getAvailableIdentifier(refModel, 'weight', 'WEIGHT')
                };
                e.preventDefault();

                $weightList.append(weightTpl(defaultData));
                refModel.weights.push(defaultData);
                $weightList.trigger('add.internalbinder'); // trigger model update

                $view.groupValidator();
            });
        }

        /**
         * Perform some binding once the property view is create
         * @private
         * @param {propView} propView - the view object
         */
        function propHandler (propView) {

            var removePropHandler = function removePropHandler(){
                if(propView !== null){
                    propView.destroy();
                }
            };

            categoriesProperty(propView.getView());
            weightsProperty(propView);
            timeLimitsProperty(propView);

            $itemRef.parents('.testpart').on('delete', removePropHandler);
            $itemRef.parents('.section').on('delete', removePropHandler);
            $itemRef.on('delete', removePropHandler);
        }
    }

    /**
     * Listen for state changes to enable/disable . Called globally.
     */
    function listenActionState (){

        $('.itemrefs').each(function(){
            actions.movable($('.itemref', $(this)), 'itemref', '.actions');
        });

        $(document)
            .on('delete', function(e){
                var $parent;
                var $target = $(e.target);
                if($target.hasClass('itemref')){
                    $parent = $target.parents('.itemrefs');
                    actions.disable($parent.find('.itemref'), '.actions');
                }
            })
            .on('add change undo.deleter deleted.deleter', '.itemrefs',  function(e){
                var $parent;
                var $target = $(e.target);
                if($target.hasClass('itemref') || $target.hasClass('itemrefs')){
                    $parent = $('.itemref', $target.hasClass('itemrefs') ? $target : $target.parents('.itemrefs'));
                    actions.enable($parent, '.actions');
                    actions.movable($parent, 'itemref', '.actions');
                }
            });
    }

    /**
     * The itemrefView setup itemref related components and beahvior
     *
     * @exports taoQtiTest/controller/creator/views/itemref
     */
    return {
        setUp : setUp,
        listenActionState: listenActionState,
        resize : resize
    };

});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/encoders/dom2qti',[
    'jquery',
    'lodash',
    'taoQtiTest/controller/creator/helpers/qtiElement',
    'taoQtiTest/controller/creator/helpers/baseType'
], function ($, _, qtiElementHelper, baseType) {
    'use strict';

    /**
     * A mapping of QTI-XML node and attributes names in order to keep the camel case form
     * @type {Object}
     */
    var normalizedNodes = {
        feedbackblock: 'feedbackBlock',
        outcomeidentifier: 'outcomeIdentifier',
        showhide: 'showHide',
        printedvariable: 'printedVariable',
        powerform: 'powerForm',
        mappingindicator: 'mappingIndicator'
    };

    /**
     * Some Nodes have attributes that needs typing during decoding.
     * @type {Object}
     */
    var typedAttributes = {
        printedVariable: {
            identifier:       baseType.getConstantByName('identifier'),
            powerForm:        baseType.getConstantByName('boolean'),
            base:             baseType.getConstantByName('intOrIdentifier'),
            index:            baseType.getConstantByName('intOrIdentifier'),
            delimiter:        baseType.getConstantByName('string'),
            field:            baseType.getConstantByName('string'),
            mappingIndicator: baseType.getConstantByName('string')
        }
    };

    /**
     * Get the list of objects attributes to encode
     * @param {Object} object
     * @returns {Array}
     */
    function getAttributes(object) {
        return _.omit(object, [
            'qti-type',
            'content',
            'xmlBase',
            'lang',
            'label'
        ]);
    }

    /**
     * Encode object's properties to xml/html string attributes
     * @param {Object} attributes
     * @returns {String}
     */
    function attrToStr(attributes) {
        return _.reduce(attributes, function (acc, value, key) {
            if (_.isNumber(value) || _.isBoolean(value) || (_.isString(value) && !_.isEmpty(value))) {
                return acc + ' ' + key + '="' + value + '" ';
            }
            return acc;
        }, '');
    }

    /**
     * Ensures the nodeName has a normalized form:
     * - standard HTML tags are in lower case
     * - QTI-XML tags are in the right form
     * @param {String} nodeName
     * @returns {String}
     */
    function normalizeNodeName(nodeName) {
        var normalized = (nodeName) ? nodeName.toLocaleLowerCase() : '';
        return normalizedNodes[normalized] || normalized;
    }

    /**
     * This encoder is used to transform DOM to JSON QTI and JSON QTI to DOM.
     * It works now for the rubricBlocks components.
     * @exports creator/encoders/dom2qti
     */
    return {

        /**
         * Encode an object to a dom string
         * @param {Object} modelValue
         * @returns {String}
         */
        encode: function (modelValue) {
            var self = this,
                startTag;

            if (_.isArray(modelValue)) {
                return _.reduce(modelValue, function (result, value) {
                    return result + self.encode(value);
                }, '');
            } else if (_.isObject(modelValue) && modelValue['qti-type']) {
                if (modelValue['qti-type'] === 'textRun') {
                    return modelValue.content;
                }
                startTag = '<' + modelValue['qti-type'] + attrToStr(getAttributes(modelValue));
                if (modelValue.content) {
                    return startTag + '>' + self.encode(modelValue.content) + '</' + modelValue['qti-type'] + '>';
                } else {
                    return startTag + '/>';
                }
            }
            return '' + modelValue;
        },

        /**
         * Decode a string that represents a DOM to a QTI formatted object
         * @param {String} nodeValue
         * @returns {Array}
         */
        decode: function (nodeValue) {
            var self = this;
            var $nodeValue = (nodeValue instanceof $) ? nodeValue : $(nodeValue);
            var result = [];
            var nodeName;

            _.forEach($nodeValue, function (elt) {
                var object;
                if (elt.nodeType === 3) {
                    if (!_.isEmpty($.trim(elt.nodeValue))) {
                        result.push(qtiElementHelper.create('textRun', {
                            'content': elt.nodeValue,
                            'xmlBase': ''
                        }));
                    }
                } else if (elt.nodeType === 1) {
                    nodeName = normalizeNodeName(elt.nodeName);

                    object = _.merge(qtiElementHelper.create(nodeName, {
                        'id': '',
                        'class': '',
                        'xmlBase': '',
                        'lang': '',
                        'label': ''
                    }),
                    _.transform(elt.attributes, function (acc, value) {
                        var attrName = normalizeNodeName(value.nodeName);
                        if (attrName) {
                            if (typedAttributes[nodeName] && typedAttributes[nodeName][attrName]) {
                                acc[attrName] = baseType.getValue(typedAttributes[nodeName][attrName], value.nodeValue);
                            } else {
                                acc[attrName] = value.nodeValue;
                            }
                        }
                    }));
                    if (elt.childNodes.length > 0) {
                        object.content = self.decode(elt.childNodes);
                    }
                    result.push(object);
                }
            });
            return result;
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
define('taoQtiItem/qtiCommonRenderer/helpers/container',[
    'lodash',
    'jquery',
    'taoQtiItem/qtiItem/core/Element'
], function(_, $, Element){
    'use strict';

    //containers are cached, so do not forget to remove them.
    var _containers = {};
    var _$containerContext = $();

    /**
     * Build the selector for your element (from the element serial)
     * @private
     * @param {QtiElement} element
     * @returns {String} the selector
     */
    var _getSelector = function(element){

        var serial = element.getSerial(),
            selector = '[data-serial=' + serial + ']';

        if(Element.isA(element, 'choice')){
            selector = '.qti-choice' + selector;
        }else if(Element.isA(element, 'interaction')){
            selector = '.qti-interaction' + selector;
        }

        return selector;
    };

    /**
     * Helps you to retrieve the DOM element (as a jquery element)
     * @exports taoQtiItem/qtiCommonRenderer/helpers/containerHelper
     */
    var containerHelper =  {

        /**
         * Set a global scope to look for element container
         * @param {jQueryElement} [$scope] - if you want to retrieve the element in a particular scope or context
         */
        setContext : function($scope){
            _$containerContext = $scope;
        },

        /**
         * Get the container of the given element
         * @param {QtiElement} element - the QTI Element to find the container for
         * @param {jQueryElement} [$scope] - if you want to retrieve the element in a particular scope or context
         * @returns {jQueryElement} the container
         */
        get : function(element, $scope){

            var serial = element.getSerial();
            if($scope instanceof $ && $scope.length){

                //find in the given context
                return $scope.find(_getSelector(element));

            }else if(_$containerContext instanceof $ && _$containerContext.length){

                //find in the globally set context
                return _$containerContext.find(_getSelector(element));

            }else if(!_containers[serial] || !_containers[serial].length){

                //find in the global context
                _containers[serial] = $(_getSelector(element));
            }

            return _containers[serial];
        },

        /**
         * getContainer use a cache to store elements. This methods helps you to purge it.
         * @param {Element} element - find the container of this element
         */
        reset : function(element){
            if(element instanceof Element && _containers[element.getSerial()]){
                _containers = _.omit(_containers, element.getSerial());
            }
        },

        /**
         * Clear the containers cache
         */
        clear : function clear(){
            _containers = {};
            _$containerContext = $();
        },

        /**
         * Trigger an event on the element's container
         * @param {String} eventType - the name of the event
         * @param {QtiElement} element - find the container of this element
         * @param {Array} [data] - data to give to the event
         */
        trigger : function(eventType, element, data){
            if(eventType){
                if(data && !_.isArray(data)){
                    data = [data];
                }
                this.get(element).trigger(eventType, data);

            }
        },

        /**
         * Alias to trigger a responseChange Event from an interaction
         * @param {QtiElement} interaction - the interaction that had a response changed
         * @param {Object} [extraData] - additionnal data to give to the event
         */
        triggerResponseChangeEvent : function(interaction, extraData){
            this.trigger('responseChange', interaction, [{
                    interaction : interaction,
                    response : interaction.getResponse()
                },
                extraData
            ]);
        },

        /**
         * Make all links to opens in another tab/window
         * @param {jQueryElement} $container
         */
        targetBlank : function($container){

            $container.on('click', 'a', function(e) {
                e.preventDefault();
                var href = $(this).attr('href');
                if(href && href.match(/^http/i)){
                    window.open(href, '_blank');
                }
            });
        }
    };

    return containerHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
define('taoQtiItem/qtiCreator/helper/commonRenderer',[
    'lodash',
    'taoQtiItem/qtiCommonRenderer/renderers/Renderer',
    'taoQtiItem/qtiCommonRenderer/helpers/container'
], function(_, Renderer, containerHelper){
    "use strict";

    //store the current execution context of the common renderer (preview)
    var _$previousContext = null;

    //configure and instanciate once only:
    var _renderer;

    var commonRenderer = {
        render : function(item, $container){

            commonRenderer.setContext($container);

            return _renderer.load(function(){

                $container.append(item.render(this));
                item.postRender({}, '', this);

            }, item.getUsedClasses());
        },
        get : function(reset, config){
            if(!_renderer || reset){

                //create new instance of common renderer
                _renderer = new Renderer({
                    shuffleChoices : true
                });

                if(config){
                    //update the resolver baseUrl
                    _renderer.getAssetManager().setData({baseUrl : config.properties.baseUrl || '' });
                }
            }
            return _renderer;
        },
        getOption : function(name){
            return _renderer.getOption(name);
        },
        setOption : function(name, value){
            return _renderer.setOption(name, value);
        },
        setOptions : function(options){
            return _renderer.setOptions(options);
        },
        setContext : function($context){
            _$previousContext = $context;
            return containerHelper.setContext($context);
        },
        restoreContext : function(){
            containerHelper.setContext(_$previousContext);
             _$previousContext = null;
        },
        load : function(qtiClasses, done){
            var renderer = _renderer || this.get();
            return renderer.load(function(){
                if(_.isFunction(done)){
                    done.apply(this, arguments);
                }
            }, qtiClasses);
        }
    };

    return commonRenderer;

});

define('taoQtiItem/qtiCreator/model/helper/event',['jquery', 'lodash'], function($, _){
    "use strict";
    var _ns = '.qti-creator';
    var _ns_model = '.qti-creator';
    var eventList = [
        'containerBodyChange',
        'containerElementAdded',
        'elementCreated.qti-widget',
        'attributeChange.qti-widget',
        'choiceCreated.qti-widget',
        'correctResponseChange.qti-widget',
        'mapEntryChange.qti-widget',
        'mapEntryRemove.qti-widget',
        'deleted.qti-widget',
        'choiceTextChange.qti-widget',
        'responseTemplateChange.qti-widget',
        'mappingAttributeChange.qti-widget',
        'feedbackRuleConditionChange.qti-widget',
        'feedbackRuleCreated.qti-widget',
        'feedbackRuleRemoved.qti-widget',
        'feedbackRuleElseCreated.qti-widget',
        'feedbackRuleElseRemoved.qti-widget'
    ];

    var event = {
        choiceCreated : function(choice, interaction){
            $(document).trigger('choiceCreated.qti-widget', {choice : choice, interaction : interaction});
        },
        deleted : function(element, parent){

            if(element.isset()){
                element.unset();
            }

            $(document).off('.' + element.getSerial());
            $(document).trigger('deleted.qti-widget', {element : element, parent : parent});
        },
        getList : function(addedNamespace){
            var events = _.clone(eventList);
            if(addedNamespace){
                return _.map(events, function(e){
                    return e + '.' + addedNamespace;
                });
            }else{
                return events;
            }
        },
        initElementToWidgetListeners : function(){

            var ns = '.widget-container';

            //forward all event to the widget $container
            $(document).off(ns).on(event.getList(ns).join(' '), function(e, data){
                var element = data.element || data.container || null,
                    widget = data && element && element.data('widget');

                // for backward compatibility reasons, we only look for the widget in parent as the last resort
                if (!widget && data.parent) {
                    element = data.parent;
                    widget = element.data('widget');
                }

                if(widget){
                    widget.$container.trigger(e.type + _ns + _ns_model, data);
                }
            });

        },
        getNs : function(){
            return _ns;
        },
        getNsModel : function(){
            return _ns_model;
        }
    };

    return event;
});
define('taoQtiItem/qtiCreator/model/helper/invalidator',['lodash'], function(_){
    "use strict";
    var invalidator = {
        completelyValid : function(element){

            var item = element.getRootElement();
            var serial, invalidElements;
            if(item){
                serial = element.getSerial();
                invalidElements = item.data('invalid') || {};

                delete invalidElements[serial];
                item.data('invalid', invalidElements);
            }
        },
        valid : function(element, key){

            var item = element.getRootElement();
            var serial = element.getSerial();
            var invalidElements;

            if(item){
                invalidElements = item.data('invalid') || {};

                if(key){

                    if(invalidElements[serial] && invalidElements[serial][key]){
                        delete invalidElements[serial][key];
                        if(!_.size(invalidElements[serial])){
                            delete invalidElements[serial];
                        }

                        item.data('invalid', invalidElements);
                    }

                }else{
                    throw new Error('missing required argument "key"');
                }
            }
        },
        invalid : function(element, key, message, stateName){

            var item = element.getRootElement();
            var serial = element.getSerial();
            var invalidElements;

            if(item){
                invalidElements = item.data('invalid') || {};

                if(key){

                    if(!invalidElements[serial]){
                        invalidElements[serial] = {};
                    }

                    invalidElements[serial][key] = {
                        message : message || '',
                        stateName : stateName || 'active'
                    };
                    item.data('invalid', invalidElements);

                }else{
                    throw new Error('missing required arguments "key"');
                }
            }
        },
        isValid : function(element){

            var item = element.getRootElement();
            var serial = element.getSerial();
            var invalidElements;

            if(item){
                invalidElements = item.data('invalid') || {};
                return !invalidElements[serial];
            }
            return true;
        }
    };

    return invalidator;
});



/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA
 *
 */
define('taoQtiItem/qtiCreator/model/mixin/editable',[
    'lodash',
    'jquery',
    'core/encoder/entity',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiCreator/model/helper/event',
    'taoQtiItem/qtiCreator/model/helper/invalidator'
], function(_, $, entity, Element, event, invalidator){
    "use strict";

    var _removeSelf = function(element){

        var removed = false;
        var related = element.getRootElement();
        var found;
        var parent;

        if(related){

            found = related.find(element.getSerial());

            if(found){

                parent = found.parent;
                if(Element.isA(parent, 'interaction')){

                    if(element.qtiClass === 'gapImg'){
                        parent.removeGapImg(element);
                    }else if(Element.isA(element, 'choice')){
                        parent.removeChoice(element);
                    }
                    removed = true;

                }else if(found.location === 'body' && _.isFunction(parent.initContainer)){

                    if(_.isFunction(element.beforeRemove)){
                        element.beforeRemove();
                    }

                    parent.getBody().removeElement(element);
                    removed = true;

                }else if(Element.isA(parent, '_container')){

                    if(_.isFunction(element.beforeRemove)){
                        element.beforeRemove();
                    }

                    parent.removeElement(element);
                    removed = true;
                }

                if(removed){
                    //mark it instantly as removed in case its is being used somewhere else
                    element.data('removed', true);
                    invalidator.completelyValid(element);
                    event.deleted(element, parent);
                }
            }
        } else {
            throw new Error('no related item found');
        }

        return removed;
    };

    var _removeElement = function(element, containerPropName, eltToBeRemoved){
        var targetSerial = '',
            targetElt;

        if(element[containerPropName]){

            if(typeof (eltToBeRemoved) === 'string'){
                targetSerial = eltToBeRemoved;
                targetElt = Element.getElementBySerial(targetSerial);
            }else if(eltToBeRemoved instanceof Element){
                targetSerial = eltToBeRemoved.getSerial();
                targetElt = eltToBeRemoved;
            }

            if(targetSerial){
                invalidator.completelyValid(targetElt);
                delete element[containerPropName][targetSerial];
                Element.unsetElement(targetSerial);
            }
        }

        return element;
    };

    var methods = {
        init : function(serial, attributes){
            var attr = {};

            //init call in the format init(attributes)
            if(typeof (serial) === 'object'){
                attributes = serial;
                serial = '';
            }

            if(_.isFunction(this.getDefaultAttributes)){
                _.extend(attr, this.getDefaultAttributes());
            }
            _.extend(attr, attributes);

            this._super(serial, attr);
        },

        /**
         * Get or set an attribute
         * @param {String} key - the attribute name
         * @param {String} [value] - only to set the new value, let empty for a get
         * @returns {String} the attribute value
         */
        attr : function(key, value){
            var ret = this._super(key, value);

            if(typeof key !== 'undefined' && typeof value !== 'undefined'){
                $(document).trigger('attributeChange.qti-widget', {
                    'element' : this,
                    'key' : key,
                    'value' : entity.encode(value)
                });
            }
            return _.isString(ret) ? entity.decode(ret) : ret;
        },

        removeAttr : function(key){
            var ret = this._super(key);
            $(document).trigger('attributeChange.qti-widget', {'element' : this, 'key' : key, 'value' : null});
            return ret;
        },
        remove : function(){
            if(arguments.length === 0){
                return _removeSelf(this);
            }else if(arguments.length === 2){
                return _removeElement(this, arguments[0], arguments[1]);
            }else{
                throw new Error('invalid number of argument given');
            }
        }
    };

    return methods;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
define('taoQtiItem/qtiItem/core/Container',[
    'jquery',
    'lodash',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiItem/helper/rendererConfig'
], function($, _, Element, rendererConfig){
    'use strict';

    var Container = Element.extend({
        qtiClass : '_container',
        init : function(body){
            this._super();//generate serial, attributes array always empty
            if(body && typeof body !== 'string'){
                throw 'the body of a container must be a string';
            }
            this.bdy = body || '';
            this.elements = {};
        },
        body : function(body){
            if(typeof body === 'undefined'){
                return this.bdy;
            }else{
                if(typeof body === 'string'){
                    this.bdy = body;
                    $(document).trigger('containerBodyChange', {
                        body : body,
                        container : this,
                        parent : this.parent()
                    });
                }else{
                    throw 'body must be a string';
                }
            }
        },
        setElements : function(elements, body){
            var returnValue = false;

            for(var i in elements){
                var elt = elements[i];
                if(elt instanceof Element){

                    body = body || this.bdy;
                    if(body.indexOf(elt.placeholder()) === -1){
                        body += elt.placeholder();//append the element if no placeholder found
                    }

                    elt.setRootElement(this.getRootElement() || null);
                    this.elements[elt.getSerial()] = elt;
                    $(document).trigger('containerElementAdded', {
                        element : elt,
                        container : this
                    });

                    returnValue = true;
                }else{
                    returnValue = false;
                    throw 'expected a qti element';
                }
            }

            this.body(body);

            return returnValue;
        },
        setElement : function(element, body){
            return this.setElements([element], body);
        },
        removeElement : function(element){
            var serial = '';
            if(typeof(element) === 'string'){
                serial = element;
            }else if(element instanceof Element){
                serial = element.getSerial();
            }
            delete this.elements[serial];
            this.body(this.body().replace('{{' + serial + '}}', ''));
            return this;
        },
        getElements : function(qtiClass){
            var elts = {};
            if(typeof(qtiClass) === 'string'){
                for(var serial in this.elements){
                    if(Element.isA(this.elements[serial], qtiClass)){
                        elts[serial] = this.elements[serial];
                    }
                }
            }else{
                elts = _.clone(this.elements);
            }
            return elts;
        },
        getElement : function(serial){
            return this.elements[serial] ? this.elements[serial] : null;
        },
        getComposingElements : function(){
            var elements = this.getElements();
            var elts = {};
            for(var serial in elements){
                elts[serial] = elements[serial];//pass individual object by ref, instead of the whole list(object)
                elts = _.extend(elts, elements[serial].getComposingElements());
            }
            return elts;
        },
        render : function(){

            var args = rendererConfig.getOptionsFromArguments(arguments),
                renderer = args.renderer || this.getRenderer(),
                elementsData = [],
                tpl = this.body();

            for(var serial in this.elements){
                var elt = this.elements[serial];
                if(typeof elt.render === 'function'){
                    if(elt.qtiClass === '_container'){
                        //@todo : container rendering merging, to be tested
                        tpl = tpl.replace(elt.placeholder(), elt.render(renderer));
                    }else{
                        tpl = tpl.replace(elt.placeholder(), '{{{' + serial + '}}}');
                        elementsData[serial] = elt.render(renderer);
                    }
                }else{
                    throw 'render() is not defined for the qti element: ' + serial;
                }
            }

            if(renderer.isRenderer){
                return this._super({
                    body : renderer.renderDirect(tpl, elementsData),
                    contentModel : this.contentModel || 'flow'
                }, renderer, args.placeholder);
            }else{
                throw 'invalid qti renderer for qti container';
            }
        },
        postRender : function(data, altClassName, renderer){
            renderer = renderer || this.getRenderer();

            var res = _(this.elements)
                .filter( function(elt){
                    return typeof elt.postRender === 'function';
                })
                .map(function(elt){
                    return elt.postRender(data, '', renderer);
                })
                .flatten(true)
                .value()
                .concat(this._super(data, altClassName, renderer));
            return res;
        },
        toArray : function(){
            var arr = {
                serial : this.serial,
                body : this.bdy,
                elements : {}
            };

            for(var serial in this.elements){
                arr.elements[serial] = this.elements[serial].toArray();
            }

            return arr;
        },
        find : function(serial, parent){

            var found = null;

            if(this.elements[serial]){

                found = {parent : parent || this, element : this.elements[serial], location : 'body'};

            }else{

                _.each(this.elements, function(elt){

                    found = elt.find(serial);
                    if(found){
                        return false;//break loop
                    }
                });
            }

            return found;
        },
        isEmpty : function(){
            return !this.bdy;
        }
    });

    return Container;
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA
 *
 */
define('taoQtiItem/qtiCreator/model/Container',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/Container'
], function(_, editable, Container){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        afterCreate : function(){
            this.body('<p>Lorem ipsum dolor sit amet, consectetur adipisicing ...</p>');
        },
        beforeRemove : function(){
            _.each(this.getComposingElements(), function(element){
                if(_.isFunction(element.beforeRemove)){
                    element.beforeRemove();
                }
            });
        }
    });
    return Container.extend(methods);
});
/**
 * Define the location of all qti classes used in the QTI Creator
 */
define('taoQtiItem/qtiCreator/model/qtiClasses',['lodash', 'taoQtiItem/qtiItem/core/qtiClasses'], function(_, qtiClasses){
    "use strict";
    //clone the qtiClasses instead of modifying it by direct extend:
    return _.defaults({
        'assessmentItem' : 'taoQtiItem/qtiCreator/model/Item',
        '_container' : 'taoQtiItem/qtiCreator/model/Container',
        'img' : 'taoQtiItem/qtiCreator/model/Img',
        'math' : 'taoQtiItem/qtiCreator/model/Math',
        'object' : 'taoQtiItem/qtiCreator/model/Object',
        'table' : 'taoQtiItem/qtiCreator/model/Table',
        'rubricBlock' : 'taoQtiItem/qtiCreator/model/RubricBlock',
        'modalFeedback' : 'taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback',
        'choiceInteraction' : 'taoQtiItem/qtiCreator/model/interactions/ChoiceInteraction',
        'orderInteraction' : 'taoQtiItem/qtiCreator/model/interactions/OrderInteraction',
        'associateInteraction' : 'taoQtiItem/qtiCreator/model/interactions/AssociateInteraction',
        'matchInteraction' : 'taoQtiItem/qtiCreator/model/interactions/MatchInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiCreator/model/interactions/InlineChoiceInteraction',
        'simpleChoice' : 'taoQtiItem/qtiCreator/model/choices/SimpleChoice',
        'simpleAssociableChoice' : 'taoQtiItem/qtiCreator/model/choices/SimpleAssociableChoice',
        'inlineChoice' : 'taoQtiItem/qtiCreator/model/choices/InlineChoice',
        'mediaInteraction' : 'taoQtiItem/qtiCreator/model/interactions/MediaInteraction',
        'uploadInteraction' : 'taoQtiItem/qtiCreator/model/interactions/UploadInteraction',
        'textEntryInteraction' : 'taoQtiItem/qtiCreator/model/interactions/TextEntryInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCreator/model/interactions/SliderInteraction',
        'extendedTextInteraction' : 'taoQtiItem/qtiCreator/model/interactions/ExtendedTextInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiCreator/model/interactions/HotspotInteraction',
        'selectPointInteraction' : 'taoQtiItem/qtiCreator/model/interactions/SelectPointInteraction',
        'graphicInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicOrderInteraction',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicAssociateInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicGapMatchInteraction',
        'graphicOrderInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GraphicOrderInteraction',
        'hotspotChoice' : 'taoQtiItem/qtiCreator/model/choices/HotspotChoice',
        'gapImg' : 'taoQtiItem/qtiCreator/model/choices/GapImg',
        'associableHotspot' : 'taoQtiItem/qtiCreator/model/choices/AssociableHotspot',
        'gapMatchInteraction' : 'taoQtiItem/qtiCreator/model/interactions/GapMatchInteraction',
        'hottextInteraction' : 'taoQtiItem/qtiCreator/model/interactions/HottextInteraction',
        'hottext' : 'taoQtiItem/qtiCreator/model/choices/Hottext',
        'gapText' : 'taoQtiItem/qtiCreator/model/choices/GapText',
        'gap' : 'taoQtiItem/qtiCreator/model/choices/Gap',
        'responseDeclaration' : 'taoQtiItem/qtiCreator/model/variables/ResponseDeclaration',
        'responseProcessing' : 'taoQtiItem/qtiCreator/model/ResponseProcessing',
        'customInteraction' : 'taoQtiItem/qtiCreator/model/interactions/PortableCustomInteraction',
        'endAttemptInteraction' : 'taoQtiItem/qtiCreator/model/interactions/EndAttemptInteraction',
        'infoControl' : 'taoQtiItem/qtiCreator/model/PortableInfoControl',
        'include' : 'taoQtiItem/qtiCreator/model/Include',
        'printedVariable' : 'taoQtiItem/qtiCreator/model/PrintedVariable',
        '_tooltip' : 'taoQtiItem/qtiCreator/model/Tooltip'
    }, qtiClasses);

});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014-2018 (original work) Open Assessment Technologies SA
 *
 */
define('taoQtiItem/qtiCreator/model/helper/container',['jquery', 'lodash', 'taoQtiItem/qtiCreator/model/qtiClasses'], function($, _, qtiClasses){
    "use strict";
    var methods = {
        createElements : function(container, body, callback){

            var regex = /{{([a-z_]+)\.?([a-z_]*):new}}/ig;

            //first pass to get required qti classes, but do not replace
            var required = {};
            body.replace(regex,
                function(original, qtiClass){
                    if(qtiClasses[qtiClass]){
                        required[qtiClass] = qtiClasses[qtiClass];
                    }else{
                        throw new Error('missing required class : ' + qtiClass);
                    }
                });

            //second pass after requiring classes:
            require(_.values(required), function(){

                //register and name all loaded classes:
                var Qti = _.reduce([].slice.call(arguments), function (acc, qtiClassElt) {
                    acc[qtiClassElt.prototype.qtiClass] = qtiClassElt;

                    return acc;
                }, {});
                var promises = [];
                var $doc = $(document);

                //create new elements
                var newElts = {};
                var newBody = body.replace(regex,
                    function(original, qtiClass, subClass){
                        var elt = new Qti[qtiClass]();
                        if(Qti[qtiClass]){
                            //create new element
                            if(container.getRenderer()){
                                elt.setRenderer(container.getRenderer());
                            }
                            newElts[elt.getSerial()] = elt;

                            //manage sub-classed qtiClass
                            if(subClass){
                                //@todo generalize it from customInteraction
                                elt.typeIdentifier = subClass;
                            }

                            return elt.placeholder();
                        }else{
                            return original;
                        }
                    });

                //insert them:
                container.setElements(newElts, newBody);

                //operations after insertions:
                _.each(newElts, function(elt){
                    if(_.isFunction(elt.buildIdentifier)){
                        elt.buildIdentifier();
                    }
                    if(_.isFunction(elt.afterCreate)){
                        promises.push(elt.afterCreate());
                    }
                });

                if(typeof(callback) === 'function'){
                    Promise.all(promises).then(function(){
                        _.each(newElts, function(elt){
                            $doc.trigger('elementCreated.qti-widget', {parent : container.parent(), element : elt});
                        });
                        callback.call(container, newElts);
                    }).catch(function(err){
                        container.getRenderer().getCreatorContext().trigger('error', err);
                    });
                }
            });

        }
    };

    return methods;
});

define('taoQtiItem/qtiCreator/model/mixin/editableContainer',['taoQtiItem/qtiCreator/model/helper/container'], function(containerHelper){
    "use strict";
    var methods = {
        createElements : function(body, callback){
            
            var _this = this;
            containerHelper.createElements(_this.getBody(), body, function(newElts){
                callback.call(_this, newElts);
            });

        }
    };

    return methods;
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA
 *
 */

/**
 * IdentifiedElement model
 * @author Sam Sipasseuth <sam@taotesting.com>
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiItem/qtiItem/core/IdentifiedElement',[
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiItem/helper/util'
], function(Element, util){
    'use strict';

    /**
     * IdentifiedElement model
     */
    var IdentifiedElement = Element.extend({

        /**
         * Generates and assign an identifier
         * @param {String} prefix - identifier prefix
         * @param {Boolean} [useSuffix = true] - add a "_ + index" to the identifier
         * @returns {Object} for chaining
         */
        buildIdentifier : function buildIdentifier(prefix, useSuffix){
            var item = this.getRootElement();
            var id = util.buildIdentifier(item, prefix || this.qtiClass, useSuffix);
            if(id){
                this.attr('identifier', id);
            }
            return this;
        },

        /**
         * Get/set and identifier. It will be generated if it doesn't exists.
         * @param {String} [value] - set the value or get it if not set.
         * @returns {String} the identifier
         */
        id : function id(value){
            if(!value && !this.attr('identifier')){
                this.buildIdentifier(this.qtiClass, true);
            }
            return this.attr('identifier', value);
        }
    });

    /**
     * @exports taoQtiItem/qtiItem/core/IdentifiableElement
     */
    return IdentifiedElement;
});


define('taoQtiItem/qtiItem/mixin/Mixin',[],function(){
    
    //@todo : need refactoring of qti item mixin with lodash.mixin()
    return {
        augment : function(targetClass, methods, options){
            if(typeof(targetClass) === 'function' && typeof(methods) === 'object'){
                for(var methodName in methods){
                    if(!Object.hasOwnProperty(targetClass.prototype, methodName)){
                        targetClass.prototype[methodName] = methods[methodName];
                    }else{
                        if(options && options.append){
                            var _parent = targetClass.prototype[methodName];
                            targetClass.prototype[methodName] = function(){
                                methods[methodName].apply(this, arguments);
                                return _parent.apply(this, arguments);
                            }
                        }
                    }
                }
            }
        }
    }
});
define('taoQtiItem/qtiItem/mixin/Container',['taoQtiItem/qtiItem/mixin/Mixin', 'taoQtiItem/qtiItem/core/Container'], function(Mixin, Container){

    var methods = {
        initContainer : function(body){
            this.bdy = new Container(body || '');
            this.bdy.setRootElement(this.getRootElement() || null);
            this.bdy.contentModel = 'blockStatic';
        },
        getBody : function(){
            return this.bdy;
        },
        body : function(body){
            var ret = this.bdy.body(body);
            return (body) ? this : ret;//for method chaining on get
        },
        setElement : function(element, body){
            this.bdy.setElement(element, body);
            return this;
        },
        removeElement : function(element){
            return this.bdy.removeElement(element);
        },
        getElements : function(qtiClass){
            return this.bdy.getElements(qtiClass);
        },
        getElement : function(serial){
            return this.bdy.getElement(serial);
        }
    };

    return {
        augment : function(targetClass){
            Mixin.augment(targetClass, methods);
        },
        methods : methods
    };
});
define('taoQtiItem/qtiItem/mixin/ContainerItemBody',['taoQtiItem/qtiItem/mixin/Mixin', 'taoQtiItem/qtiItem/mixin/Container', 'lodash'], function(Mixin, Container, _){
    
    var methods = {};
    _.extend(methods, Container.methods);
    _.extend(methods, {
        initContainer:function(body){
            Container.methods.initContainer.call(this, body);
            this.bdy.contentModel = 'itemBody';
        }
    });

    return {
        augment : function(targetClass){
            Mixin.augment(targetClass, methods);
        },
        methods : methods
    };
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technlogies SA (under the project TAO-PRODUCT);
 *
 */

/**
 * QTI Item Element model
 *
 * @author Sam Sipasseuth <sam@taotesting.com>
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiItem/qtiItem/core/Item',[
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiItem/core/IdentifiedElement',
    'taoQtiItem/qtiItem/mixin/ContainerItemBody',
    'lodash',
    'jquery',
    'taoQtiItem/qtiItem/helper/util'
], function(Element, IdentifiedElement, Container, _, $, util){
    'use strict';

    var Item = IdentifiedElement.extend({
        qtiClass : 'assessmentItem',
        init : function init(serial, attributes){
            this._super(serial, attributes);
            this.rootElement = this;
            this.stylesheets = {};
            this.responses = {};
            this.outcomes = {};
            this.modalFeedbacks = {};
            this.namespaces = {};
            this.schemaLocations = {};
            this.responseProcessing = null;
            this.apipAccessibility = null;
        },
        getInteractions : function getInteractions(){
            var interactions = [];
            var elts = this.getComposingElements();
            for(var serial in elts){
                if(Element.isA(elts[serial], 'interaction')){
                    interactions.push(elts[serial]);
                }
            }
            return interactions;
        },
        addResponseDeclaration : function addResponseDeclaration(response){
            if(Element.isA(response, 'responseDeclaration')){
                response.setRootElement(this);
                this.responses[response.getSerial()] = response;
            }else{
                throw 'is not a qti response declaration';
            }
            return this;
        },
        getResponseDeclaration : function getResponseDeclaration(identifier){
            for(var i in this.responses){
                if(this.responses[i].attr('identifier') === identifier){
                    return this.responses[i];
                }
            }
            return null;
        },
        addOutcomeDeclaration : function addOutcomeDeclaration(outcome){
            if(Element.isA(outcome, 'outcomeDeclaration')){
                outcome.setRootElement(this);
                this.outcomes[outcome.getSerial()] = outcome;
            }else{
                throw 'is not a qti outcome declaration';
            }
            return this;
        },
        getOutcomeDeclaration : function getOutcomeDeclaration(identifier){
            var found;
            _.forEach(this.outcomes, function (outcome) {
                if (outcome.id() === identifier) {
                    found = outcome;
                    return false;
                }
            });
            return found;
        },
        getOutcomes : function getOutcomes(){
            return _.clone(this.outcomes);
        },
        removeOutcome : function removeOutcome(identifier){
            var outcome = this.getOutcomeDeclaration(identifier);
            if(outcome){
                this.outcomes = _.omit(this.outcomes, outcome.getSerial());
            }
        },
        addModalFeedback : function addModalFeedback(feedback){
            if(Element.isA(feedback, 'modalFeedback')){
                feedback.setRootElement(this);
                this.modalFeedbacks[feedback.getSerial()] = feedback;
            }else{
                throw 'is not a qti modal feedback';
            }
            return this;
        },
        getComposingElements : function getComposingElements(){
            var elts = this._super(), _this = this;
            _.forEach(['responses', 'outcomes', 'modalFeedbacks', 'stylesheets'], function(elementCollection){
                for(var i in _this[elementCollection]){
                    var elt = _this[elementCollection][i];
                    elts[i] = elt;
                    elts = _.extend(elts, elt.getComposingElements());
                }
            });
            if(this.responseProcessing instanceof Element){
                elts[this.responseProcessing.getSerial()] = this.responseProcessing;
            }
            return elts;
        },
        find : function find(serial){

            var found = this._super(serial);

            if(!found){
                found = util.findInCollection(this, ['responses', 'outcomes', 'modalFeedbacks', 'stylesheets'], serial);
            }

            return found;
        },
        getResponses : function getResponses(){
            return _.clone(this.responses);
        },
        getRootElement : function getRootElement(){
            return this;
        },
        addNamespace : function addNamespace(name, uri){
            this.namespaces[name] = uri;
        },
        setNamespaces : function setNamespaces(namespaces){
            this.namespaces = namespaces;
        },
        getNamespaces : function getNamespaces(){
            return _.clone(this.namespaces);
        },
        setSchemaLocations : function setSchemaLocations(locations){
            this.schemaLocations = locations;
        },
        getSchemaLocations : function getSchemaLocations(){
            return _.clone(this.schemaLocations);
        },
        setApipAccessibility : function setApipAccessibility(apip){
            this.apipAccessibility = apip || null;
        },
        getApipAccessibility : function getApipAccessibility(){
            return this.apipAccessibility;
        },
        addStylesheet : function addStylesheet(stylesheet){
            if(Element.isA(stylesheet, 'stylesheet')){
                stylesheet.setRootElement(this);
                this.stylesheets[stylesheet.getSerial()] = stylesheet;
            }else{
                throw 'is not a qti stylesheet declaration';
            }
            return this;
        },
        removeStyleSheet : function removeStyleSheet(stylesheet){
            delete this.stylesheets[stylesheet.getSerial()];
            return this;
        },
        stylesheetExists : function stylesheetExists(href){
            var exists = false;
            _.forEach(this.stylesheets, function(stylesheet){
                if(stylesheet.attr('href') === href){
                    exists = true;
                    return false;//break each loop
                }
            });
            return exists;
        },
        setResponseProcessing : function setResponseProcessing(rp){
            if(Element.isA(rp, 'responseProcessing')){
                rp.setRootElement(this);
                this.responseProcessing = rp;
            }else{
                throw 'is not a response processing';
            }
            return this;
        },
        toArray : function toArray(){
            var arr = this._super();
            var toArray = function(elt){
                return elt.toArray();
            };
            arr.namespaces = this.namespaces;
			arr.schemaLocations = this.schemaLocations;
            arr.outcomes = _.map(this.outcomes, toArray);
            arr.responses = _.map(this.responses, toArray);
            arr.stylesheets = _.map(this.stylesheets, toArray);
            arr.modalFeedbacks = _.map(this.modalFeedbacks, toArray);
            arr.responseProcessing = this.responseProcessing.toArray();
            return arr;
        },
        isEmpty : function isEmpty(){

            var body = this.body().trim();

            if(body){

                //hack to fix #2652
                var $dummy = $('<div>').html(body),
                    $children = $dummy.children();

                if($children.length === 1 && $children.hasClass('empty')){
                    return true;
                }else{
                    return false;
                }
            }else{
                return true;
            }
        },

        /**
         * Clean up an item rendering.
         * Ask the renderer to run destroy if exists.
         */
        clear : function clear(){
            var renderer = this.getRenderer();
            if(renderer){
                if(_.isFunction(renderer.destroy)){
                    renderer.destroy(this);
                }
            }
        },
    });

    Container.augment(Item);

    return Item;
});

define('taoQtiItem/qtiItem/core/Stylesheet',['taoQtiItem/qtiItem/core/Element', 'lodash', 'taoQtiItem/qtiItem/helper/rendererConfig'], function(Element, _, rendererConfig){

    var Stylesheet = Element.extend({
        qtiClass : 'stylesheet',
        render : function(){

            var args = rendererConfig.getOptionsFromArguments(arguments),
                renderer = args.renderer || this.getRenderer(),
                defaultData = {};

            defaultData.attributes = {href : renderer.resolveUrl(this.attr('href'))};

            return this._super(_.merge(defaultData, args.data), args.placeholder, args.subclass, renderer);
        }
    });

    return Stylesheet;
});

define('taoQtiItem/qtiCreator/model/Stylesheet',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/Stylesheet'
], function(_, editable, Stylesheet){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                href : 'css/tao-user-styles.css',
                title : '',
                type:'text/css',
                media:'all'
            };
        }
    });

    return Stylesheet.extend(methods);
});
define('taoQtiItem/qtiItem/core/ResponseProcessing',['taoQtiItem/qtiItem/core/Element', 'lodash'], function(Element, _){
    
    var ResponseProcessing = Element.extend({
        qtiClass : 'responseProcessing',
        processingType : '',
        xml : '',
        toArray : function(){
            var arr = this._super();
            arr.processingType = this.processingType;
            arr.xml = this.xml;
            return arr;
        }
    });
    
    return ResponseProcessing;
});
define('taoQtiItem/qtiCreator/model/ResponseProcessing',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/ResponseProcessing'
], function(_, editable, ResponseProcessing){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {};
        },
        setProcessingType : function(processingType){

            if(this.processingType !== processingType){

                if(this.processingType === 'custom'){

                    //change all response template to default : "correct"
                    _.each(this.getRootElement().getResponses(), function(r){
                         r.setTemplate('MATCH_CORRECT');
                    });
                }

                this.processingType = processingType;
            }

        }
    });

    return ResponseProcessing.extend(methods);
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014-2017 (original work) Open Assessment Technologies SA;
 *
 */
define('taoQtiItem/qtiItem/core/variables/VariableDeclaration',['taoQtiItem/qtiItem/core/IdentifiedElement'], function(IdentifiedElement){
    'use strict';
    /**
     * It is the top abstract class for all variable classes
     * (so not renderable and qtiClass undefined)
     */
    var VariableDeclaration = IdentifiedElement.extend({
        init : function init(serial, attributes){
            this._super(serial, attributes);
            this.defaultValue = null;
        },
        is : function is(qtiClass){
            return (qtiClass === 'variableDeclaration') || this._super(qtiClass);
        },
        toArray : function toArray(){
            var arr = this._super();
            arr.defaultValue = this.defaultValue;
            return arr;
        },
        setDefaultValue : function setDefaultValue(value){
            this.defaultValue = value;
        },
        getDefaultValue : function getDefaultValue(){
            return this.defaultValue;
        },
    });

    return VariableDeclaration;
});
define('taoQtiItem/qtiItem/core/variables/OutcomeDeclaration',['taoQtiItem/qtiItem/core/variables/VariableDeclaration'], function(VariableDeclaration){
    return  VariableDeclaration.extend({
        qtiClass : 'outcomeDeclaration'
    });
});
define('taoQtiItem/qtiCreator/model/variables/OutcomeDeclaration',['lodash', 'taoQtiItem/qtiCreator/model/mixin/editable', 'taoQtiItem/qtiItem/core/variables/OutcomeDeclaration'], function(_, editable, OutcomeDeclaration){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    return OutcomeDeclaration.extend(methods);
});

define('taoQtiItem/qtiItem/core/feedbacks/ModalFeedback',['taoQtiItem/qtiItem/core/IdentifiedElement', 'taoQtiItem/qtiItem/mixin/Container'], function(IdentifiedElement, Container){
    
    var ModalFeedback = IdentifiedElement.extend({
        'qtiClass' : 'modalFeedback',
        is : function(qtiClass){
            return (qtiClass === 'feedback') || this._super(qtiClass);
        }
    });
    
    Container.augment(ModalFeedback);
    
    return ModalFeedback;
});
define('taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiItem/core/feedbacks/ModalFeedback'
], function(_,editable,ModalFeedback){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                title : 'modal feedback title',
                showHide : 'show'
            };
        }
    });
    
    return ModalFeedback.extend(methods);
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 *
 */
define('taoQtiItem/qtiCreator/model/Item',[
    'lodash',
    'taoQtiItem/qtiCreator/model/mixin/editable',
    'taoQtiItem/qtiCreator/model/mixin/editableContainer',
    'taoQtiItem/qtiItem/core/Item',
    'taoQtiItem/qtiCreator/model/Stylesheet',
    'taoQtiItem/qtiCreator/model/ResponseProcessing',
    'taoQtiItem/qtiCreator/model/variables/OutcomeDeclaration',
    'taoQtiItem/qtiCreator/model/feedbacks/ModalFeedback'
], function(_, editable, editableContainer, Item, Stylesheet, ResponseProcessing, OutcomeDeclaration, ModalFeedback){
    "use strict";
    var methods = {};
    _.extend(methods, editable);
    _.extend(methods, editableContainer);
    _.extend(methods, {
        getDefaultAttributes : function(){
            return {
                identifier : 'myItem_1',
                title : 'Item title',
                adaptive : false,
                timeDependent : false,
                'xml:lang' : 'en-US'
            };
        },
        createResponseProcessing : function(){
            var rp = new ResponseProcessing();
            rp.processingType = 'templateDriven';
            this.setResponseProcessing(rp);
            return rp;
        },
        createStyleSheet : function(href){
            if(href && _.isString(href)){
                var stylesheet = new Stylesheet({href : href});
                stylesheet.setRenderer(this.getRenderer());
                this.addStylesheet(stylesheet);
                return stylesheet;
            }else{
                throw 'missing or invalid type for the required arg "href"';
                return null;
            }
        },
        createOutcomeDeclaration : function(attributes){

            var identifier = attributes.identifier || '';
            delete attributes.identifier;
            var outcome = new OutcomeDeclaration(attributes);

            this.addOutcomeDeclaration(outcome);
            outcome.buildIdentifier(identifier);

            return outcome;
        },
        getOutcomeDeclaration : function getOutcomeDeclaration(identifier){
            var found;
            _.forEach(this.outcomes, function (outcome) {
                if (outcome.id() === identifier) {
                    found = outcome;
                    return false;
                }
            });
            return found;
        },
        removeOutcome : function removeOutcome(identifier){
            var outcome = this.getOutcomeDeclaration(identifier);
            if(outcome){
                this.outcomes = _.omit(this.outcomes, outcome.getSerial());
            }
        },
        createModalFeedback : function(attributes, response){

            var identifier = attributes.identifier || '';
            delete attributes.identifier;
            var modalFeedback = new ModalFeedback(attributes);

            this.addModalFeedback(modalFeedback);
            modalFeedback.buildIdentifier(identifier);
            modalFeedback.body('Some feedback text.');
            if(response && response.qtiClass === 'responseDeclaration'){
                modalFeedback.data('relatedResponse', response);
            }
        
            return modalFeedback;
        },
        deleteResponseDeclaration : function(response){
            var self = this;
            var serial;
            if(_.isString(response)){
                serial = response;
            }else if(response && response.qtiClass === 'responseDeclaration'){
                serial = response.getSerial();
            }
            if(this.responses[serial]){
                //remove feedback rules:
                _.each(this.responses[serial].feedbackRules, function(rule){
                    var feedbacks = [];
                    if(rule.feedbackThen && rule.feedbackThen.is('modalFeedback')){
                        feedbacks.push(rule.feedbackThen.serial);  
                    }
                    if(rule.feedbackElse && rule.feedbackElse.is('modalFeedback')){
                        feedbacks.push(rule.feedbackElse.serial);
                    }
                    self.modalFeedbacks = _.omit(self.modalFeedbacks, feedbacks);
                    
                    if(rule.feedbackOutcome && rule.feedbackOutcome.is('outcomeDeclaration')){
                        self.outcomes = _.omit(self.outcomes, rule.feedbackOutcome.serial);
                    }
                });
                this.responses = _.omit(this.responses, serial);
            }
            return this;
        }
    });
    return Item.extend(methods);
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014-2015 (original work) Open Assessment Technlogies SA;
 *
 */

/**
 * Config of the QTI XML renderer
 *
 * @author Sam Sipasseuth <sam@taotesting.com>
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiItem/qtiXmlRenderer/renderers/config',[
    'taoItems/assets/manager'
], function(assetManagerFactory){
    'use strict';

    //all assets are normalized (relative)
    var assetManager = assetManagerFactory([{
        name : 'nomalize',
        handle: function normalizeStrategy(url){
            if(url){
                return url.toString().replace(/^\.?\//, '');
            }
        }
    }]);

    /**
     * The XML Renderer config
     */
    return {
        name : 'xmlRenderer',
        locations : {
            '_container' : 'taoQtiItem/qtiXmlRenderer/renderers/Container',
            'assessmentItem' : 'taoQtiItem/qtiXmlRenderer/renderers/Item',
            'stylesheet' : 'taoQtiItem/qtiXmlRenderer/renderers/Stylesheet',
            'responseDeclaration' : 'taoQtiItem/qtiXmlRenderer/renderers/ResponseDeclaration',
            'outcomeDeclaration' : 'taoQtiItem/qtiXmlRenderer/renderers/OutcomeDeclaration',
            'responseProcessing' : 'taoQtiItem/qtiXmlRenderer/renderers/ResponseProcessing',
            '_simpleFeedbackRule' : 'taoQtiItem/qtiXmlRenderer/renderers/responses/SimpleFeedbackRule',
            '_tooltip' : 'taoQtiItem/qtiXmlRenderer/renderers/Tooltip',
            'math' : 'taoQtiItem/qtiXmlRenderer/renderers/Math',
            'img' : 'taoQtiItem/qtiXmlRenderer/renderers/Img',
            'object' : 'taoQtiItem/qtiXmlRenderer/renderers/Object',
            'table' : 'taoQtiItem/qtiXmlRenderer/renderers/Table',
            'modalFeedback' : 'taoQtiItem/qtiXmlRenderer/renderers/feedbacks/ModalFeedback',
            'rubricBlock' : 'taoQtiItem/qtiXmlRenderer/renderers/RubricBlock',
            'associateInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/AssociateInteraction',
            'choiceInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/ChoiceInteraction',
            'extendedTextInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/ExtendedTextInteraction',
            'gapMatchInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/GapMatchInteraction',
            'graphicAssociateInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/GraphicAssociateInteraction',
            'graphicGapMatchInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/GraphicGapMatchInteraction',
            'graphicOrderInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/GraphicOrderInteraction',
            'hotspotInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/HotspotInteraction',
            'hottextInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/HottextInteraction',
            'inlineChoiceInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/InlineChoiceInteraction',
            'matchInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/MatchInteraction',
            'mediaInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/MediaInteraction',
            'orderInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/OrderInteraction',
            'selectPointInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/SelectPointInteraction',
            'sliderInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/SliderInteraction',
            'textEntryInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/TextEntryInteraction',
            'uploadInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/UploadInteraction',
            'prompt' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/Prompt',
            'associableHotspot' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/AssociableHotspot',
            'gap' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/Gap',
            'gapImg' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/GapImg',
            'gapText' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/GapText',
            'hotspotChoice' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/HotspotChoice',
            'hottext' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/Hottext',
            'inlineChoice' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/InlineChoice',
            'simpleAssociableChoice' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/SimpleAssociableChoice',
            'simpleChoice' : 'taoQtiItem/qtiXmlRenderer/renderers/choices/SimpleChoice',
            'customInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/PortableCustomInteraction',
            'endAttemptInteraction' : 'taoQtiItem/qtiXmlRenderer/renderers/interactions/EndAttemptInteraction',
            'infoControl' : 'taoQtiItem/qtiXmlRenderer/renderers/PortableInfoControl',
            'include' : 'taoQtiItem/qtiXmlRenderer/renderers/Include',
            'printedVariable' : 'taoQtiItem/qtiXmlRenderer/renderers/PrintedVariable'
        },
        options : {
            assetManager : assetManager
        }
    };
});

define('taoQtiItem/qtiXmlRenderer/renderers/Renderer',['taoQtiItem/qtiRunner/core/Renderer', 'taoQtiItem/qtiXmlRenderer/renderers/config'], function(Renderer, config){
    'use strict';

    return Renderer.build(config.locations, config.name, config.options);
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014-2017 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 *
 */
define('taoQtiItem/qtiItem/helper/response',['lodash'], function(_) {
    'use strict';

    var _templateNames = {
        'MATCH_CORRECT': 'http://www.imsglobal.org/question/qti_v2p1/rptemplates/match_correct',
        'MAP_RESPONSE': 'http://www.imsglobal.org/question/qti_v2p1/rptemplates/map_response',
        'MAP_RESPONSE_POINT': 'http://www.imsglobal.org/question/qti_v2p1/rptemplates/map_response_point',
        'NONE': 'no_response_processing'
    };

    return {
        isUsingTemplate: function isUsingTemplate(response, tpl) {
            if (_.isString(tpl)) {
                if (tpl === response.template || _templateNames[tpl] === response.template) {
                    return true;
                }
            }
            return false;
        },
        isValidTemplateName: function isValidTemplateName(tplName) {
            return !!this.getTemplateUriFromName(tplName);
        },
        getTemplateUriFromName: function getTemplateUriFromName(tplName) {
            if (_templateNames[tplName]) {
                return _templateNames[tplName];
            }
            return '';
        },
        getTemplateNameFromUri: function getTemplateNameFromUri(tplUri) {
            var tplName = '';
            _.forIn(_templateNames, function (uri, name) {
                if (uri === tplUri) {
                    tplName = name;
                    return false;
                }
            });
            return tplName;
        }
    };
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 *
 */
define('taoQtiItem/qtiItem/helper/maxScore',[
    'lodash',
    'lib/gamp/gamp',
    'taoQtiItem/qtiItem/helper/response',
    'taoQtiItem/qtiCreator/model/variables/OutcomeDeclaration'
], function(_, gamp, responseHelper, OutcomeDeclaration) {
    'use strict';

    /**
     * This variable allow to globally define if the minCHoice needs to be taken into consideration.
     * Standard-wise, it must definitely be considered.
     * However, the item delivery lifecycle currently does not consider the minChoice constraint during delivery.
     * It is thus currently set to true. After the correct behaviour is implemented, we should remove this variables.
     * @type {boolean}
     * @private
     */
    var _ignoreMinChoice = true;

    var pairExists = function pairExists(collection, pair){
        if(pair.length !== 2){
            return false;
        }
        return (collection[pair[0]+' '+pair[1]] || collection[pair[1]+' '+pair[0]]);
    };

    return {
        /**
         * Set the normal maximum to the item
         * @param {Object} item - the standard qti item model object
         */
        setNormalMaximum : function setNormalMaximum(item) {
            var normalMaximum,
                scoreOutcome = item.getOutcomeDeclaration('SCORE');

            //try setting the computed normal maximum only if the processing type is known, i.e. 'templateDriven'
            if (scoreOutcome && item.responseProcessing && item.responseProcessing.processingType === 'templateDriven') {
                normalMaximum = _.reduce(item.getInteractions(), function (acc, interaction) {
                    var interactionMaxScore = interaction.getNormalMaximum();
                    if(_.isNumber(interactionMaxScore)){
                        return gamp.add(acc, interactionMaxScore);
                    }else{
                        return false;
                    }
                }, 0);

                if(_.isNumber(normalMaximum)){
                    scoreOutcome.attr('normalMaximum', normalMaximum);
                }else{
                    scoreOutcome.removeAttr('normalMaximum');
                }
            }
        },

        /**
         * Set the maximum score of the item
         * @param {Object} item - the standard qti item model object
         */
        setMaxScore : function setMaxScore(item) {
            var hasInvalidInteraction = false,
                scoreOutcome = item.getOutcomeDeclaration('SCORE'),
                customOutcomes,
                maxScore,
                maxScoreOutcome;

            //try setting the computed normal maximum only if the processing type is known, i.e. 'templateDriven'
            if (scoreOutcome && item.responseProcessing && item.responseProcessing.processingType === 'templateDriven') {

                maxScore = _.reduce(item.getInteractions(), function (acc, interaction) {
                    var interactionMaxScore = interaction.getNormalMaximum();
                    if(_.isNumber(interactionMaxScore)){
                        return gamp.add(acc, interactionMaxScore);
                    }else{
                        hasInvalidInteraction = true;
                        return acc;
                    }
                }, 0);

                customOutcomes =  _(item.getOutcomes()).filter(function(outcome){
                    return (outcome.id() !== 'SCORE' && outcome.id() !== 'MAXSCORE');
                });

                if(customOutcomes.size()){
                    maxScore = customOutcomes.reduce(function (acc, outcome) {
                        return gamp.add(acc, parseFloat(outcome.attr('normalMaximum')||0));
                    }, maxScore);
                }

                if(!hasInvalidInteraction || customOutcomes.size()){
                    maxScoreOutcome = item.getOutcomeDeclaration('MAXSCORE');
                    if(!maxScoreOutcome){
                        //add new outcome
                        maxScoreOutcome = new OutcomeDeclaration({
                            cardinality : 'single',
                            baseType : 'float'
                        });

                        //attach the outcome to the item before generating item-level unique id
                        item.addOutcomeDeclaration(maxScoreOutcome);
                        maxScoreOutcome.buildIdentifier('MAXSCORE', false);
                    }
                    maxScoreOutcome.setDefaultValue(maxScore);
                }else{
                    //remove MAXSCORE:
                    item.removeOutcome('MAXSCORE');
                }
            }
        },

        /**
         * Sort an array of associable choices by its matchMax attr value
         * @param {Array} choiceCollection
         * @returns {Array}
         */
        getMatchMaxOrderedChoices : function getMatchMaxOrderedChoices(choiceCollection){
            return _(choiceCollection).map(function(choice){
                var matchMax = parseInt(choice.attr('matchMax'), 10);
                if(_.isNaN(matchMax)){
                    matchMax = 0;
                }
                return {
                    matchMax : matchMax === 0 ? Infinity : matchMax,
                    id: choice.id()
                };
            }).sortBy('matchMax').reverse().valueOf();
        },

        /**
         * Compute the maximum score of a "choice" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        choiceInteractionBased : function choiceInteractionBased(interaction, options){
            var responseDeclaration = interaction.getResponseDeclaration();
            var mapDefault = parseFloat(responseDeclaration.mappingAttributes.defaultValue||0);
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var max, maxChoice, minChoice, scoreMaps, requiredChoiceCount, totalAnswerableResponse, sortedMapEntries, i, missingMapsCount;

            options = _.defaults(options || {}, {maxChoices : 0, minChoices: 0});
            maxChoice = parseInt(interaction.attr('maxChoices')||options.maxChoices, 10);
            minChoice = _ignoreMinChoice ? 0 : parseInt(interaction.attr('minChoices')||options.minChoices, 10);
            if(maxChoice && minChoice && maxChoice < minChoice){
                return 0;
            }

            if (template === 'MATCH_CORRECT') {
                if(maxChoice && _.isArray(responseDeclaration.correctResponse) && (responseDeclaration.correctResponse.length > maxChoice || responseDeclaration.correctResponse.length < minChoice)){
                    //max choice does not enable selecting the correct responses
                    max = 0;
                }else if(!responseDeclaration.correctResponse || (_.isArray(responseDeclaration.correctResponse) && !responseDeclaration.correctResponse.length)){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = 1;
                }
            }else if(template === 'MAP_RESPONSE') {

                //at least a map entry is required to be valid QTI
                if(!responseDeclaration.mapEntries || !_.size(responseDeclaration.mapEntries)){
                    return 0;
                }

                //prepare constraint params
                requiredChoiceCount = minChoice;
                totalAnswerableResponse = (maxChoice === 0) ? Infinity : maxChoice;

                //sort the score map entries by the score
                scoreMaps = _.values(responseDeclaration.mapEntries);
                sortedMapEntries = _(scoreMaps).map(function (v) {
                    return parseFloat(v);
                }).sortBy().reverse().first(totalAnswerableResponse);

                //if there is not enough map defined, compared to the minChoice constraint, fill in the rest of required choices with the default map
                missingMapsCount = minChoice - sortedMapEntries.size();
                _.times(missingMapsCount, function(){
                    sortedMapEntries.push(mapDefault);
                });

                //if the map default is positive, the optimal strategy involves using as much mapDefault as possible
                if(mapDefault && mapDefault > 0){
                    if(maxChoice){
                        missingMapsCount = maxChoice - sortedMapEntries.size();
                    }else{
                        missingMapsCount = _.size(interaction.getChoices()) - sortedMapEntries.size();
                    }
                    if(missingMapsCount > 0){
                        _.times(missingMapsCount, function(){
                            sortedMapEntries.push(mapDefault);
                        });
                    }
                }

                //calculate the maximum reachable score by choice map
                max = sortedMapEntries.reduce(function (acc, v) {
                    var score = v;
                    if(score < 0 && requiredChoiceCount <= 0){
                        //if the score is negative check if we have the choice not to pick it
                        score = 0;
                    }
                    requiredChoiceCount--;
                    return gamp.add(acc, score);
                }, 0);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }else if(template === 'MAP_RESPONSE_POINT'){
                //map point response processing does not work on choice based interaction
                max = 0;
            }
            return max;
        },

        /**
         * Compute the maximum score of a "order" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        orderInteractionBased : function orderInteractionBased(interaction){
            var minChoice = _ignoreMinChoice ? 0 : parseInt(interaction.attr('minChoices')||0, 10);
            var maxChoice = parseInt(interaction.attr('maxChoices')||0, 10);
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var max;

            if(maxChoice && minChoice && maxChoice < minChoice){
                return 0;
            }

            if (template === 'MATCH_CORRECT') {
                if(_.isArray(responseDeclaration.correctResponse) && (maxChoice && responseDeclaration.correctResponse.length > maxChoice) || (minChoice && responseDeclaration.correctResponse.length < minChoice)){
                    //max choice does not enable selecting the correct responses
                    max = 0;
                }else if(!responseDeclaration.correctResponse || (_.isArray(responseDeclaration.correctResponse) && !responseDeclaration.correctResponse.length)){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = 1;
                }
            }else if(template === 'MAP_RESPONSE' || template === 'MAP_RESPONSE_POINT') {
                //map response processing does not work on order based interaction
                max = 0;
            }
            return max;
        },

        /**
         * Compute the maximum score of a "associate" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        associateInteractionBased : function associateInteractionBased(interaction, options){
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var maxAssoc = parseInt(interaction.attr('maxAssociations')||0, 10);
            var minAssoc = _ignoreMinChoice ? 0 : parseInt(interaction.attr('minAssociations')||0, 10);
            var mapDefault = parseFloat(responseDeclaration.mappingAttributes.defaultValue||0);
            var max, requiredAssoc, totalAnswerableResponse, usedChoices, choicesIdentifiers, sortedMapEntries, i, allPossibleMapEntries, infiniteScoringPair;

            options = _.defaults(options || {}, {possiblePairs : [], checkInfinitePair: false});

            if(maxAssoc && minAssoc && maxAssoc < minAssoc){
                return 0;
            }

            if (template === 'MATCH_CORRECT') {
                if(!responseDeclaration.correctResponse
                    || (_.isArray(responseDeclaration.correctResponse)
                    && (!responseDeclaration.correctResponse.length || maxAssoc && responseDeclaration.correctResponse.length > maxAssoc || minAssoc && responseDeclaration.correctResponse.length < minAssoc) )){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = 1;//is possible until proven otherwise

                    //get the list of choices used in map entries
                    choicesIdentifiers = [];
                    _.forEach(responseDeclaration.correctResponse, function(pair){
                        var choices;
                        if(!_.isString(pair)){
                            return;
                        }
                        choices = pair.trim().split(' ');
                        if(_.isArray(choices) && choices.length === 2){
                            choicesIdentifiers.push(choices[0].trim());
                            choicesIdentifiers.push(choices[1].trim());
                        }
                    });

                    //check if the choices usage are possible within the constraint defined in the interaction
                    _.forEach(_.countBy(choicesIdentifiers), function(count, identifier){
                        var matchMax;
                        var choice = interaction.getChoiceByIdentifier(identifier);
                        if(!choice){
                            max = 0;
                            return false;
                        }
                        matchMax = parseInt(choice.attr('matchMax'), 10);
                        if(matchMax && matchMax < count){
                            max = 0;
                            return false;
                        }
                    });
                }
            }else if(template === 'MAP_RESPONSE') {

                requiredAssoc = minAssoc;
                totalAnswerableResponse = (maxAssoc === 0) ? Infinity : maxAssoc;
                usedChoices = {};

                //at least a map entry is required to be valid QTI
                if(!responseDeclaration.mapEntries || !_.size(responseDeclaration.mapEntries)){
                    return 0;
                }

                allPossibleMapEntries = _.clone(responseDeclaration.mapEntries);
                if(mapDefault && mapDefault > 0){
                    _.forEachRight(options.possiblePairs, function(pair){
                        if(!pairExists(allPossibleMapEntries, pair)){
                            allPossibleMapEntries[pair[0]+' '+pair[1]] = mapDefault;
                        }
                    });
                }

                //get the sorted list of mapentries ordered by the score
                sortedMapEntries = _(allPossibleMapEntries).map(function(score, pair){
                    return {
                        score : parseFloat(score),
                        pair : pair
                    };
                }).sortBy('score').reverse().filter(function(mapEntry){
                    var pair = mapEntry.pair;
                    var choices, choiceId, choice, _usedChoices;

                    if(!_.isString(pair)){
                        return false;
                    }

                    //check that the pair is possible in term of matchMax
                    choices = pair.trim().split(' ');
                    if(_.isArray(choices) && choices.length === 2){
                        //clone the global used choices array to brings the changes in that object first before storing in the actual object
                        _usedChoices = _.cloneDeep(usedChoices);

                        for(i = 0; i < 2; i++){
                            choiceId = choices[i];

                            //collect choices usage to check if the pair is possible
                            if(!_usedChoices[choiceId]){
                                choice = interaction.getChoiceByIdentifier(choiceId);
                                if(!choice){
                                    //unexisting choice, skip
                                    return false;
                                }
                                _usedChoices[choiceId] = {
                                    used : 0,
                                    max: parseInt(choice.attr('matchMax'), 10)
                                };
                            }
                            if(_usedChoices[choiceId].max && _usedChoices[choiceId].used === _usedChoices[choiceId].max){
                                //skip
                                return false;
                            }else{
                                _usedChoices[choiceId].used ++;
                            }
                        }

                        //identify the edge case when we can get infinite association pair that create an infinite score
                        infiniteScoringPair = infiniteScoringPair || (options.checkInfinitePair
                            && mapEntry.score > 0
                            && _usedChoices[choices[0]].max === 0
                            && _usedChoices[choices[1]].max === 0);

                        //update the global used choices array
                        _.assign(usedChoices, _usedChoices);
                        return true;
                    }else{
                        //is not a correct response pair
                        return false;
                    }
                }).first(totalAnswerableResponse);

                //infinite score => no normalMaximum should be generated for it
                if(infiniteScoringPair){
                    return false;
                }

                //reduce the ordered list of map entries to calculate the max score
                max = sortedMapEntries.reduce(function (acc, v) {
                    var score = v.score;
                    if(v.score < 0 && requiredAssoc <= 0){
                        //if the score is negative check if we have the choice not to pick it
                        score = 0;
                    }
                    requiredAssoc--;
                    return gamp.add(acc, score);
                }, 0);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }else if(template === 'MAP_RESPONSE_POINT'){
                max = 0;
            }
            return max;
        },

        /**
         * Compute the maximum score of a "gap match" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        gapMatchInteractionBased : function gapMatchInteractionBased(interaction){
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var maxAssoc = 0;
            var minAssoc = 0;
            var mapDefault = parseFloat(responseDeclaration.mappingAttributes.defaultValue||0);
            var max, skippableWrongResponse, totalAnswerableResponse, usedChoices, usedGaps, group1, group2, allPossibleMapEntries;
            var getMatchMaxOrderedChoices = function getMatchMaxOrderedChoices(choiceCollection){
                return _(choiceCollection).map(function(choice){
                    return {
                        matchMax : choice.attr('matchMax') === 0 ? Infinity : choice.attr('matchMax') || 0,
                        id: choice.id()
                    };
                }).sortBy('matchMax').reverse().valueOf();
            };
            var calculatePossiblePairs = function calculatePossiblePairs(gapMatchInteraction){
                //get max number of pairs
                var pairs = [];
                var matchSet1 = getMatchMaxOrderedChoices(gapMatchInteraction.getChoices());
                var matchSet2 = getMatchMaxOrderedChoices(gapMatchInteraction.getGaps());

                _.forEach(matchSet1, function(choice1){
                    _.forEach(matchSet2, function(choice2){
                        pairs.push([choice1.id, choice2.id]);
                    });
                });

                return pairs;
            };

            if (template === 'MATCH_CORRECT') {
                if(!responseDeclaration.correctResponse || (_.isArray(responseDeclaration.correctResponse) && !responseDeclaration.correctResponse.length)){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = 1;//is possible until proven otherwise
                    group1 = [];
                    group2 = [];
                    _.forEach(responseDeclaration.correctResponse, function(pair){
                        var choices;
                        if(!_.isString(pair)){
                            return;
                        }
                        choices = pair.trim().split(' ');
                        if(_.isArray(choices) && choices.length === 2){
                            group1.push(choices[0].trim());
                            group2.push(choices[1].trim());
                        }
                    });

                    _.forEach(_.countBy(group1), function(count, identifier){
                        var choice = interaction.getChoiceByIdentifier(identifier);
                        var matchMax = parseInt(choice.attr('matchMax'), 10);
                        if(matchMax && matchMax < count){
                            max = 0;
                            return false;
                        }
                    });

                    _.forEach(_.countBy(group2), function(count){
                        var matchMax = 1;//match max for a gap is always 1
                        if(matchMax && matchMax < count){
                            max = 0;
                            return false;
                        }
                    });
                }
            }else if(template === 'MAP_RESPONSE') {

                skippableWrongResponse = (minAssoc === 0) ? Infinity : minAssoc;
                totalAnswerableResponse = (maxAssoc === 0) ? Infinity : maxAssoc;
                usedChoices = {};
                usedGaps = {};

                //at least a map entry is required to be valid QTI
                if(!responseDeclaration.mapEntries || !_.size(responseDeclaration.mapEntries)){
                    return 0;
                }

                allPossibleMapEntries = _.clone(responseDeclaration.mapEntries);
                if(mapDefault && mapDefault > 0){
                    _.forEachRight(calculatePossiblePairs(interaction), function(pair){
                        if(!pairExists(allPossibleMapEntries, pair)){
                            allPossibleMapEntries[pair[0]+' '+pair[1]] = mapDefault;
                        }
                    });
                }

                max = _(allPossibleMapEntries).map(function(score, pair){
                    return {
                        score : parseFloat(score),
                        pair : pair
                    };
                }).sortBy('score').reverse().filter(function(mapEntry){
                    var pair = mapEntry.pair;
                    var _usedChoices = _.cloneDeep(usedChoices);
                    var choices, choiceId, gapId, choice;

                    if(!_.isString(pair)){
                        return false;
                    }

                    choices = pair.trim().split(' ');
                    if(_.isArray(choices) && choices.length === 2){
                        choiceId = choices[0];
                        gapId = choices[1];
                        if(!_usedChoices[choiceId]){
                            choice = interaction.getChoiceByIdentifier(choiceId);
                            if(!choice){
                                //inexisting choice, skip
                                return false;
                            }
                            _usedChoices[choiceId] = {
                                used : 0,
                                max: parseInt(choice.attr('matchMax'), 10)
                            };
                        }
                        if(_usedChoices[choiceId].max && _usedChoices[choiceId].used === _usedChoices[choiceId].max){
                            //skip
                            return false;
                        }
                        _usedChoices[choiceId].used ++;

                        if(!usedGaps[gapId]){
                            usedGaps[gapId] = {
                                used : 0,
                                max: 1
                            };
                        }
                        if(usedGaps[gapId].max && usedGaps[gapId].used === usedGaps[gapId].max){
                            //skip
                            return false;
                        }
                        usedGaps[gapId].used ++;

                        //if an only if it is ok, we merge the temporary used choices array into the global one
                        _.assign(usedChoices, _usedChoices);
                        return true;
                    }else{
                        //is not a correct response pair
                        return false;
                    }
                }).first(totalAnswerableResponse).reduce(function (acc, v) {
                    var score = v.score;
                    if (score >= 0) {
                        return acc + score;
                    } else if (skippableWrongResponse > 0) {
                        skippableWrongResponse--;
                        return acc;
                    } else {
                        return acc + score;
                    }
                }, 0);

                //console.log(usedChoices, allPossibleMapEntries, sortedMaps);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }else if(template === 'MAP_RESPONSE_POINT'){
                max = false;
            }
            return max;
        },

        /**
         * Compute the maximum score of a "select point" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        selectPointInteractionBased : function selectPointInteractionBased(interaction){
            var maxChoice = parseInt(interaction.attr('maxChoices'), 10);
            var minChoice = _ignoreMinChoice ? 0 : parseInt(interaction.attr('minChoices'), 10);
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var max, skippableWrongResponse, totalAnswerableResponse;

            if (template === 'MATCH_CORRECT' || template === 'MAP_RESPONSE') {
                //such templates are not allowed
                return 0;
            }else if(template === 'MAP_RESPONSE_POINT'){
                //calculate the maximum reachable score by choice map
                skippableWrongResponse = (minChoice === 0) ? Infinity : minChoice;
                totalAnswerableResponse = (maxChoice === 0) ? Infinity : maxChoice;

                max = _(responseDeclaration.mapEntries).map(function (v) {
                    return parseFloat(v.mappedValue);
                }).sortBy().reverse().first(totalAnswerableResponse).reduce(function (acc, v) {
                    if (v >= 0) {
                        return acc + v;
                    } else if (skippableWrongResponse > 0) {
                        skippableWrongResponse--;
                        return acc;
                    } else {
                        return acc + v;
                    }
                }, 0);
                max = parseFloat(max);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }
            return max;
        },

        /**
         * Compute the maximum score of a "slider" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        sliderInteractionBased : function sliderInteractionBased(interaction){
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var max, scoreMaps;

            if (template === 'MATCH_CORRECT') {
                if(!responseDeclaration.correctResponse || (_.isArray(responseDeclaration.correctResponse) && !responseDeclaration.correctResponse.length)){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = 1;
                }
            }else if(template === 'MAP_RESPONSE') {

                //at least a map entry is required to be valid QTI
                if(!responseDeclaration.mapEntries || !_.size(responseDeclaration.mapEntries)){
                    return 0;
                }

                //calculate the maximum reachable score by choice map
                scoreMaps = _.values(responseDeclaration.mapEntries);
                max = _(scoreMaps).map(function (v) {
                    return parseFloat(v);
                }).max();
                max = parseFloat(max);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }else if(template === 'MAP_RESPONSE_POINT'){
                max = 0;
            }
            return max;
        },

        /**
         * Compute the maximum score of a "text entry" typed interaction
         * @param {Object} interaction - a standard interaction model object
         * @returns {Number}
         */
        textEntryInteractionBased : function textEntryInteractionBased(interaction){
            var responseDeclaration = interaction.getResponseDeclaration();
            var template = responseHelper.getTemplateNameFromUri(responseDeclaration.template);
            var max, scoreMaps;

            /**
             * Check that a response is possible or not according to the defined patternmask
             * @param {String} value
             * @returns {Boolean}
             */
            var isPossibleResponse = function isPossibleResponse(value){
                var patternMask = interaction.attr('patternMask');
                if(patternMask){
                    return !!value.match(new RegExp(patternMask));
                }else{
                    //no restriction by pattern so always possible
                    return true;
                }
            };

            if (template === 'MATCH_CORRECT') {
                if(!responseDeclaration.correctResponse || (_.isArray(responseDeclaration.correctResponse) && !responseDeclaration.correctResponse.length)){
                    //no correct response defined -> score always zero
                    max = 0;
                }else{
                    max = isPossibleResponse(responseDeclaration.correctResponse[0]) ? 1 : 0;
                }
            }else if(template === 'MAP_RESPONSE') {

                //at least a map entry is required to be valid QTI
                if(!responseDeclaration.mapEntries || !_.size(responseDeclaration.mapEntries)){
                    return 0;
                }

                //calculate the maximum reachable score by choice map
                scoreMaps = _.values(_.filter(responseDeclaration.mapEntries, function(score, key){
                    return isPossibleResponse(key);
                }));
                max = _(scoreMaps).map(function (v) {
                    return parseFloat(v);
                }).max();
                max = parseFloat(max);

                //compare the calculated maximum with the mapping upperbound
                if (responseDeclaration.mappingAttributes.upperBound) {
                    max = Math.min(max, parseFloat(responseDeclaration.mappingAttributes.upperBound||0));
                }
            }else if(template === 'MAP_RESPONSE_POINT'){
                max = 0;
            }
            return max;
        }
    };
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015-2017 (original work) Open Assessment Technologies SA ;
 */
define('taoQtiItem/qtiCreator/helper/xmlRenderer',[
    'core/logger',
    'taoQtiItem/qtiXmlRenderer/renderers/Renderer',
    'taoQtiItem/qtiItem/helper/maxScore',
    'taoQtiItem/qtiItem/core/Element'
], function(loggerFactory, XmlRenderer, maxScore, Element){
    'use strict';

    var logger = loggerFactory('taoQtiItem/qtiCreator/helper/xmlRenderer');

    var _xmlRenderer = new XmlRenderer({
        shuffleChoices : false
    }).load();

    var _render = function(element){
        var xml = '';
        try{
            if(element instanceof Element) {
                if (element.is('assessmentItem')) {
                    maxScore.setNormalMaximum(element);
                    maxScore.setMaxScore(element);
                }
                xml = element.render(_xmlRenderer);
            }
        }catch(e){
            logger.error(e);
        }
        return xml;
    };

    return {
        render : _render,
        get : function(){
            return _xmlRenderer;
        }
    };
});

define('taoQtiItem/qtiItem/helper/simpleParser',[
    'lodash',
    'jquery',
    'taoQtiItem/qtiItem/helper/util',
    'taoQtiItem/qtiItem/core/Loader'
], function(_, $, util, Loader){
    "use strict";

    var _parsableElements = ['img', 'object', 'printedVariable'];
    var _qtiClassNames = {
        rubricblock : 'rubricBlock',
        printedvariable : 'printedVariable'
    };
    var _qtiAttributesNames = {
        powerform: 'powerForm',
        mappingindicator: 'mappingIndicator'
    };

    var _defaultOptions = {
        ns : {
            math : '',
            include : 'xi'
        },
        loaded : null,
        model : null
    };

    var parser;

    function _getElementSelector(qtiClass, ns){
        return ns ? ns + "\\:" + qtiClass + ','+qtiClass : qtiClass;
    }

    function getQtiClassFromXmlDom($node){

        var qtiClass = $node.prop('tagName').toLowerCase();

        //remove ns :
        qtiClass = qtiClass.replace(/.*:/, '');

        return _qtiClassNames[qtiClass] ? _qtiClassNames[qtiClass] : qtiClass;
    }

    function buildElement($elt){

        var qtiClass = getQtiClassFromXmlDom($elt);

        var elt = {
            qtiClass : qtiClass,
            serial : util.buildSerial(qtiClass + '_'),
            attributes : {}
        };

        $.each($elt[0].attributes, function(){
            var attrName;
            if(this.specified){
                attrName = _qtiAttributesNames[this.name] || this.name;
                elt.attributes[attrName] = this.value;
            }
        });

        return elt;
    }

    function buildMath($elt, options){

        var elt = buildElement($elt);

        //set annotations:
        elt.annotations = {};
        $elt.find(_getElementSelector('annotation', options.ns.math)).each(function(){
            var $annotation = $(this);
            var encoding = $annotation.attr('encoding');
            if(encoding){
                elt.annotations[encoding] = _.unescape($annotation.html());
            }
            $annotation.remove();
        });

        //set math xml
        elt.mathML = $elt.html();

        //set ns:
        elt.ns = {
            name : 'm',
            uri : 'http://www.w3.org/1998/Math/MathML'//@todo : remove hardcoding there
        };

        return elt;
    }

    function buildTooltip(targetHtml, contentId, contentHtml){
        var qtiClass = '_tooltip';

        return {
            elements : {},
            qtiClass : qtiClass,
            serial : util.buildSerial(qtiClass + '_'),
            attributes : {
                'aria-describedby': contentId
            },
            content: contentHtml,
            body: {
                elements : {},
                serial: util.buildSerial('container'),
                body: targetHtml
            }

        };
    }

    function parseContainer($container, options){

        var ret = {
            serial : util.buildSerial('_container_'),
            body : '',
            elements : {}
        };

        _.each(_parsableElements, function(qtiClass){

            $container.find(qtiClass).each(function(){

                var $qtiElement = $(this);
                var element = buildElement($qtiElement, options);

                ret.elements[element.serial] = element;
                $qtiElement.replaceWith(_placeholder(element));

            });

        });

        $container.find(_getElementSelector('math', options.ns.math)).each(function(){

            var $qtiElement = $(this);
            var element = buildMath($qtiElement, options);

            ret.elements[element.serial] = element;
            $qtiElement.replaceWith(_placeholder(element));

        });

        $container.find(_getElementSelector('include', options.ns.include)).each(function(){

            var $qtiElement = $(this);
            var element = buildElement($qtiElement, options);

            ret.elements[element.serial] = element;
            $qtiElement.replaceWith(_placeholder(element));

        });

        $container.find('[data-role="tooltip-target"]').each(function(){
            var element,
                $target = $(this),
                $content,
                contentId = $target.attr('aria-describedBy'),
                contentHtml;

            if (contentId) {
                $content = $container.find('#' + contentId);
                if ($content.length) {
                    contentHtml = $content.html();

                    element = buildTooltip($target.html(), contentId, contentHtml);

                    ret.elements[element.serial] = element;
                    $target.replaceWith(_placeholder(element));
                    $content.remove();
                }
            }
        });

        ret.body = $container.html();

        return ret;
    }

    function _placeholder(element){
        return '{{' + element.serial + '}}';
    }

    parser = {
        parse : function(xmlStr, opts){
            var options = _.merge(_.clone(_defaultOptions), opts || {});

            var $container = $(xmlStr);

            var element = buildElement($container, options);

            var data = parseContainer($container, options);

            var loader;

            if(!_.isUndefined(data.body)){
                element.body = data;
            }

            if(_.isFunction(options.loaded) && options.model){
                loader = new Loader().setClassesLocation(options.model);
                loader.loadAndBuildElement(element, options.loaded);
            }

            return element;
        }
    };

    return parser;
});


/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA;
 */
define('taoQtiItem/qtiCreator/renderers/config',[
    'lodash',
    'context',
    'taoQtiItem/qtiCommonRenderer/renderers/config',
    'taoItems/assets/manager',
    'taoItems/assets/strategies'
], function(_,  context, commonRenderConfig, assetManagerFactory, assetStrategies){
    'use strict';

    //asset manager using base url
    var assetManager = assetManagerFactory([
        assetStrategies.taomedia,
        assetStrategies.external,
        assetStrategies.base64,
        assetStrategies.baseUrl
    ], {baseUrl : ''});

    var locations = _.defaults({
        '_container' : 'taoQtiItem/qtiCreator/renderers/Container',
        '_tooltip' : 'taoQtiItem/qtiCreator/renderers/Tooltip',
        'assessmentItem' : 'taoQtiItem/qtiCreator/renderers/Item',
        'rubricBlock' : 'taoQtiItem/qtiCreator/renderers/RubricBlock',
        'img' : 'taoQtiItem/qtiCreator/renderers/Img',
        'math' : 'taoQtiItem/qtiCreator/renderers/Math',
        'object' : 'taoQtiItem/qtiCreator/renderers/Object',
        'table' : 'taoQtiItem/qtiCreator/renderers/Table',
        'modalFeedback' : 'taoQtiItem/qtiCreator/renderers/ModalFeedback',
        'choiceInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/ChoiceInteraction',
        'orderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/OrderInteraction',
        'matchInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/MatchInteraction',
        'associateInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/AssociateInteraction',
        'inlineChoiceInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/InlineChoiceInteraction',
        'textEntryInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/TextEntryInteraction',
        'hotspotInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/HotspotInteraction',
        'selectPointInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/SelectPointInteraction',
        'graphicOrderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicOrderInteraction',
        'graphicAssociateInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicAssociateInteraction',
        'graphicGapMatchInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GraphicGapMatchInteraction',
        'mediaInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/MediaInteraction',
        'uploadInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/UploadInteraction',
        'sliderInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/SliderInteraction',
        'extendedTextInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/ExtendedTextInteraction',
        'simpleChoice.choiceInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleChoice.ChoiceInteraction',
        'simpleChoice.orderInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleChoice.OrderInteraction',
        'simpleAssociableChoice.associateInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleAssociableChoice.AssociateInteraction',
        'simpleAssociableChoice.matchInteraction' : 'taoQtiItem/qtiCreator/renderers/choices/SimpleAssociableChoice.MatchInteraction',
        'gapMatchInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/GapMatchInteraction',
        'hottextInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/HottextInteraction',
        'customInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/PortableCustomInteraction',
        'endAttemptInteraction' : 'taoQtiItem/qtiCreator/renderers/interactions/EndAttemptInteraction',
        'infoControl' : 'taoQtiItem/qtiCreator/renderers/PortableInfoControl',
        'include' : 'taoQtiItem/qtiCreator/renderers/Include',
        'gap' : 'taoQtiItem/qtiCreator/renderers/choices/Gap',
        'gapText' : 'taoQtiItem/qtiCreator/renderers/choices/GapText',
        'hottext' : 'taoQtiItem/qtiCreator/renderers/choices/Hottext',
        'printedVariable' : 'taoQtiItem/qtiCreator/renderers/PrintedVariable'
    }, commonRenderConfig.locations);

    return {
        name : 'creatorRenderer',
        locations : locations,
        options : {
            assetManager : assetManager
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA;
 */

/**
 * Define the Qti Item Creator Renderer
 */
define('taoQtiItem/qtiCreator/renderers/Renderer',[
    'taoQtiItem/qtiRunner/core/Renderer',
    'taoQtiItem/qtiCreator/renderers/config'
], function(Renderer, config){
    'use strict';

    return Renderer.build(config.locations, config.name, config.options);
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
define('taoQtiItem/qtiCreator/helper/creatorRenderer',[
    'jquery',
    'lodash',
    'taoQtiItem/qtiCreator/renderers/Renderer',
    'taoItems/assets/manager',
    'taoItems/assets/strategies',
    'util/dom'
], function($, _, Renderer, assetManagerFactory, assetStrategies, dom){
    "use strict";

    //configure and instanciate once only:
    var _creatorRenderer = null;

    //list of configurable interactions
    //some interactions allow additional non-standard but sometimes useful configuration
    var _configurableInteractions = ['endAttempt'];

    /**
     * Extract interaction-specific configuration from the main one
     *
     * @param {object} config - the configuration object of the creatorRenderer
     * @returns {module.exports.properties|Function.properties|config.properties}
     */
    var _extractInteractionsConfig = function _extractInteractionsConfig(config){
        var ret = {};
        if(config && config.properties){
            _.each(_configurableInteractions, function(interactionName){
                if(config.properties[interactionName]){
                    ret[interactionName] = config.properties[interactionName];
                }
            });
        }
        return ret;
    };

    /**
     * Get a preconfigured renderer singleton
     *
     * @param {Boolean} reset
     * @param {Object} config
     * @param {Object} areaBroker - the QtiCreator area broker
     * @returns {Object} - a configured instance of creatorRenderer
     */
    var get = function(reset, config, areaBroker){
        var $bodyEltForm;

        config = config || {};
        config.properties = config.properties || {};

        if(!_creatorRenderer || reset){

            $bodyEltForm = _creatorRenderer ? _creatorRenderer.getOption('bodyElementOptionForm') : null;
            if(reset ||
                !$bodyEltForm ||
                !$bodyEltForm.length ||
                !dom.contains($bodyEltForm)){

                _creatorRenderer = new Renderer({
                    //assetManager : assetManager,
                    lang : '',
                    uri : '',
                    shuffleChoices : false,
                    itemOptionForm : $('#item-editor-item-property-bar .panel'),
                    interactionOptionForm : $('#item-editor-interaction-property-bar .panel'),
                    choiceOptionForm : $('#item-editor-choice-property-bar .panel'),
                    responseOptionForm : $('#item-editor-response-property-bar .panel'),
                    bodyElementOptionForm : areaBroker.getElementPropertyPanelArea(),
                    textOptionForm : $('#item-editor-text-property-bar .panel'),
                    modalFeedbackOptionForm : $('#item-editor-modal-feedback-property-bar .panel'),
                    mediaManager : {
                        appendContainer : '#mediaManager',
                        browseUrl : config.properties.getFilesUrl,
                        uploadUrl : config.properties.fileUploadUrl,
                        deleteUrl : config.properties.fileDeleteUrl,
                        downloadUrl : config.properties.fileDownloadUrl,
                        fileExistsUrl : config.properties.fileExistsUrl,
                        mediaSourcesUrl : config.properties.mediaSourcesUrl
                    },
                    interactions : _extractInteractionsConfig(config),
                    qtiCreatorContext : config.qtiCreatorContext
                });

                //update the resolver baseUrl
                _creatorRenderer.getAssetManager().setData({baseUrl : config.properties.baseUrl || '' });

                _creatorRenderer.setAreaBroker(areaBroker);

                // extend creator renderer to give access to the creator context
                _.assign(_creatorRenderer, {
                    getCreatorContext: function getCreatorContext() {
                        return this.getOption('qtiCreatorContext');
                    }
                });
            }
        }

        return _creatorRenderer;
    };


    return {
        get : get,

        setOption : function(name, value){
            return get().setOption(name, value);
        },
        setOptions : function(options){
            return get().setOptions(options);
        },
        load : function(qtiClasses, done){
            return get().load(function(){
                if(_.isFunction(done)){
                    done.apply(this, arguments);
                }
            }, qtiClasses);
        }
    };

});

define('taoQtiItem/qtiItem/helper/xincludeLoader',[
    'jquery',
    'lodash', 
    'taoQtiItem/qtiItem/helper/simpleParser',
    'taoQtiItem/qtiItem/core/Loader'
], function($, _, simpleParser, Loader){

    function load(xinclude, baseUrl, callback){

        var href = xinclude.attr('href');
        if(href && baseUrl){

            //require xml :
            require(['text!' + baseUrl + href], function(stimulusXml){

                var $wrapper = $('<div>').html(stimulusXml);
                var $sampleXMLrootNode = $wrapper.children();
                var $stimulus = $('<include>').append($sampleXMLrootNode);
                var mathNs = 'm';//for 'http://www.w3.org/1998/Math/MathML'
                var data = simpleParser.parse($stimulus, {
                    ns : {
                        math : mathNs
                    }
                });

                (new Loader()).loadElement(xinclude, data, function(){
                    if(_.isFunction(callback)){
                        var loadedClasses = this.getLoadedClasses();
                        loadedClasses.push('_container');//the _container class is always required
                        callback(xinclude, data, loadedClasses);
                    }
                });

            }, function(err){
                //in case the file does not exist
                callback(xinclude, false, []);
            });

        }
    }

    return {
        load : load
    };

});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
define('taoQtiItem/qtiCreator/helper/xincludeRenderer',[
    'lodash',
    'taoQtiItem/qtiCreator/helper/commonRenderer',
    'taoQtiItem/qtiItem/helper/xincludeLoader'
], function(_, commonRenderer, xincludeLoader){
    'use strict';

    return {
        /**
         * Render (or re-render) the xinclude widget based on the current href and givenBaseUrl
         *
         * @param {Object} xincludeWidget
         * @param {String} baseUrl
         * @returns {undefined}
         */
        render : function render(xincludeWidget, baseUrl, newHref){

            var xinclude = xincludeWidget.element;
            if(newHref){
                xinclude.attr('href', newHref);
            }

            xincludeLoader.load(xinclude, baseUrl, function(xi, data, loadedClasses){
                if(data){
                    //loading success :
                    commonRenderer.get().load(function(){

                        //set commonRenderer to the composing elements only (because xinclude is "read-only")
                        _.each(xinclude.getComposingElements(), function(elt){
                            elt.setRenderer(commonRenderer.get());
                        });

                        //reload the wiget to rfresh the rendering with the new href
                        xincludeWidget.refresh();

                    }, loadedClasses);
                }else{
                    //loading failure :
                    xinclude.removeAttr('href');
                }
            });
        }
    };
});

define('taoQtiItem/qtiCreator/editor/gridEditor/config',[],function(){
    "use strict";
    return {
        min : {
            interaction : 2,
            text : 1,
            rubricBlock : 12
        },
        throttle : {
            resize : 100
        }
    };
});



define('taoQtiItem/qtiCreator/editor/gridEditor/helper',[],function(){
    "use strict";
    var helpers = {
        getColUnits : function getColUnits($elt){

            var cssClasses = $elt.attr('class');
            if(!cssClasses){
                throw new Error('the element has no css class');
            }

            var colMatch = cssClasses.match(/col-([\d]+)/);
            if(colMatch && colMatch.length){
                return parseInt(colMatch.pop());
            }else{
                throw 'the element has no col-* class';
            }
        },
        setUnitsFromClass : function setUnitsFromClass($el){
            var units = helpers.getColUnits($el);
            $el.attr('data-units', units);
            return units;
        }
    };

    return helpers;
});

define('taoQtiItem/qtiCreator/editor/gridEditor/resizable',[
    'lodash',
    'jquery',
    'taoQtiItem/qtiCreator/editor/gridEditor/config',
    'taoQtiItem/qtiCreator/editor/gridEditor/helper',
    'taoQtiItem/qtiCreator/helper/qtiElements',
    'jqueryui'
], function(_, $, config, helper, qtiElements){
    "use strict";
    var _syncHandleHeight = function($row){
        var h = $row.height() - parseFloat($row.children('[class^="col-"], [class*=" col-"]').css('margin-bottom'));
        $row.find('.grid-edit-resizable-zone').height(h);
    };

    var _createResizables = function createResizables($el){

        var marginWidth = parseFloat($el.find('[class^="col-"]:last, [class*=" col-"]:last').css('margin-left')),
            activeWidth = 20;



        $el.find('[class^="col-"], [class*=" col-"]').each(function(){

            var $col = $(this);

            //@todo this should be more generic
            //see draggable etc for more references
            if($col.parent().hasClass('fixed-grid-row')) {
                return true;
            }

            if($col.children('.grid-edit-resizable-zone').length){
                //already created, next !
                return true;
            }

            var $nextCol = $col.next(),
                $row = $col.parent('.grid-row'),
                offset = $col.offset(),
                max = 12,
                min = qtiElements.is($col.data('qti-class'), 'interaction') ? config.min.interaction : config.min.text,
                nextMin = qtiElements.is($nextCol.data('qti-class'), 'interaction') ? config.min.interaction : config.min.text,
                unitWidth = $row.width() / max;

            var activeHeight = $row.height() - parseFloat($col.css('margin-bottom'));
            var $activeZone = $('<div>', {'class' : 'grid-edit-resizable-zone grid-edit-resizable-zone-active'}).css({top : 0, right : -(marginWidth + (activeWidth - marginWidth) / 2), width : activeWidth, height : activeHeight});
            var $handle = $('<span>', {'class' : 'grid-edit-resizable-handle'});
            $activeZone.append($handle);
            $col.append($activeZone);

            var _syncOutlineHeight = function(){
                var h = $row.height() - parseFloat($col.css('margin-bottom'));
                $col.find('.grid-edit-resizable-outline').height(h);
                $activeZone.height(h);
            };

            $activeZone.draggable({
                containment : $nextCol.length ? [
                    offset.left + min * unitWidth - marginWidth * 2 + 10,
                    offset.top,
                    offset.left + $col.outerWidth() + marginWidth + $nextCol.outerWidth() - nextMin * unitWidth - activeWidth / 2 - 10,
                    offset.top + $col.height()
                ] : [
                    offset.left + min * unitWidth - marginWidth - activeWidth / 2 - 10,
                    offset.top,
                    $row.offset().left + $row.outerWidth() - marginWidth - activeWidth / 2 - 12,
                    offset.top + $col.height()
                ],
                axis : 'x',
                cursor : 'col-resize',
                start : function(){

                    $col.trigger('resizestart.gridEdit');

                    var $overlay = $('<div>', {'class' : 'grid-edit-resizable-outline'});
                    if($nextCol.length){
                        $overlay.width(parseFloat($col.outerWidth()) + marginWidth + parseFloat($nextCol.outerWidth()));
                    }else{
                        $overlay.css({'width' : '100%', 'border-right-width' : 0});
                    }
                    //store in memory for quick access during resize:
                    $(this).data('overlay', $overlay);
                    $col.append($overlay);
                    $handle.addClass('grid-edit-resizable-active');
                    $el.find('.grid-edit-resizable-zone-active').removeClass('grid-edit-resizable-zone-active');
                    _syncOutlineHeight();

                },
                drag : _.throttle(function(){

                    var width = ($(this).offset().left + activeWidth / 2) - offset.left,
                        units = helper.getColUnits($col),
                        nextUnits = $nextCol.length ? helper.getColUnits($nextCol) : 0;

                    if(!$nextCol.length){
                        //need to resize the outline element:
                        $col.find('.grid-edit-resizable-outline').width($handle.offset().left - offset.left);
                    }

                    if(width + marginWidth * 0 < (units - 1) * unitWidth){//need to compensate for the width of the active zone
                        
                        units--;
                        _setColUnits($col, units);

                        if($nextCol.length){
                            nextUnits++;
                            _setColUnits($nextCol, nextUnits);
                        }

                        _syncOutlineHeight();
                        
                        $col.trigger('resize.gridEdit');
                        
                    }else if(width + marginWidth + 20 > (units + 1) * unitWidth){//need to compensate for the width of the active zone
                        
                        units++;
                        _setColUnits($col, units);

                        if($nextCol.length){
                            nextUnits--;
                            _setColUnits($nextCol, nextUnits);
                        }

                        _syncOutlineHeight();
                        
                        $col.trigger('resize.gridEdit');
                    }

                }, config.throttle.resize),
                stop : function(){

                    $col.find('.grid-edit-resizable-outline').remove();

                    _deleteResizables($el);
                    _createResizables($el);

                    $col.trigger('resizestop.gridEdit');
                }
            }).css('position', 'absolute');

        });

        $el.off('.gridEdit.resizable').on('dragoverstart.gridEdit.resizable', function(){

            _deleteResizables($el);

        }).on('dragoverstop.gridEdit.resizable', function(){

            _createResizables($el);

        }).on('contentChange.gridEdit.resizable', '.grid-row', function(){

            _deleteResizables($el);
            _createResizables($el);
        });

    };

    var _deleteResizables = function _deleteResizables($el){
        
        $el.find('.grid-edit-resizable-zone').remove();
    };

    var _setColUnits = function _setColUnits($elt, newUnits){
        
        if($elt.attr('class').match(/col-([\d]+)/)){
            
            var oldUnits = $elt.attr('data-units');
            var $parentRow = $elt.parent('.grid-row');
            var totalUnits = $parentRow.attr('data-units');
            $parentRow.attr('data-units', totalUnits - oldUnits + newUnits);//update parent
            $elt.attr('data-units', newUnits);//update element
            $elt.removeClass('col-' + oldUnits).addClass('col-' + newUnits);
            
        }else{
            
            throw $.error('the element is not a grid column');
        }
    };

    return {
        create : function($element){
            
            _createResizables($element);
            
            $(window).off('resize.qtiEdit.resizable').on('resize.qtiEdit.resizable', function(){
                
                _deleteResizables($element);
                _createResizables($element);
            });
        },
        destroy : function($element, preserveGlobalEvents){
            
            _deleteResizables($element);
            
            if(!preserveGlobalEvents){
                
                $(window).off('resize.qtiEdit.resizable');
            }
        },
        syncHandleHeight : function($row){
        
            if($row.hasClass('grid-row')){
                _syncHandleHeight($row);
            }else{
                $row.find('.grid-row').each(function(){
                    _syncHandleHeight($(this));
                });
            }
        }

    };
});
define('taoQtiItem/qtiCreator/widgets/helpers/textWrapper',['jquery'], function($){

    function getSelection(){

        var selection;

        if(window.getSelection){
            selection = window.getSelection();
        }else if(document.selection){
            selection = document.selection.createRange();
        }

        return selection;
    }

    function containElement(selection, range){

        if(range.commonAncestorContainer.nodeType === 1){
            var selectedChildNodes = range.cloneContents().childNodes;
            for (var i = 0; i < selectedChildNodes.length; i++){
                if(selectedChildNodes[i].className && 
                   selectedChildNodes[i].className.indexOf("qti-choice") > -1){
                    return true;
                }
            }
        }

        return false;
    }

    function wrapSelection(wrap){

        var sel = getSelection();
        if(sel.rangeCount){
            var range = sel.getRangeAt(0).cloneRange();
            if(range.startOffset !== range.endOffset && //prevent empty selection
                range.toString().trim() && //prevent empty selection
                !containElement(sel, range)
                ){
                        
                range.surroundContents(wrap);
                sel.removeAllRanges();
                sel.addRange(range);
                return true;
            }
        }

        return false;
    }

    function unwrapSelection($editable){

        var $wrapper = $editable.find('#selection-wrapper');

        $editable.trigger('beforeunwrap');

        $wrapper.find('[data-role]').remove();
        $wrapper.replaceWith(function(){
            return $(this).html();
        });

        $editable.trigger('unwrapped');
    }

    var textWrapper = {
        create : function($editable){

            //reset it first:
            textWrapper.destroy($editable);

            //add listeners:
            $editable.on('mouseup.textwrapper', function(e){

                var $target = $(e.target);
                if($target.hasClass('html-editable-shield') || $target.hasClass('widget-box')){
                    return;
                }

                var $wrapper = $('<span>', {id : 'selection-wrapper', 'class' : 'inline-text-wrapper'});
                if(wrapSelection($wrapper[0])){
                    var wrappedText = $wrapper.text().trim();
                    $editable.trigger('wrapped', [$wrapper, wrappedText]);
                }

            }).on('mousedown.textwrapper', function(){

                unwrapSelection($editable);

            });

        },
        destroy : function($editable){

            unwrapSelection($editable);
            $editable.off('.textwrapper');
        },
        unwrap : function($editable){
            unwrapSelection($editable);
        }
    };

    return textWrapper;
});
define('taoQtiItem/qtiCreator/editor/gridEditor/content',[
    'jquery',
    'lodash',
    'taoQtiItem/qtiCreator/editor/gridEditor/resizable',
    'taoQtiItem/qtiCreator/widgets/helpers/textWrapper'
], function($, _, resizable, textWrapper){
    "use strict";
    var contentHelper = {};

    /**
     * Get html string content for a qti container
     * 
     * @param {string|domelement|jquery} element
     * @returns {string}
     */
    contentHelper.getContent = function(element, opts){

        var options = _.defaults({
            inner : true
        }, opts);

        var $body = options.inner ? $(element).clone() : $('<div>', {'class' : 'col-fictive content-helper-wrapper'}).append($(element).clone());

        contentHelper.destroyGridWidgets($body, true);//working on clone only, so destroyGridWidgetsClone

        contentHelper.serializeElements($body);
        
        return $body.html();
    };

    /**
     * Create a callback function for the ck edit:
     * 
     * @param {object} container
     */
    contentHelper.getChangeCallback = function(container){

        return _.throttle(function(data){

            var $pseudoContainer = $('<div>').html(data),
                newBody = contentHelper.getContent($pseudoContainer);

            container.body(newBody);

        }, 800);
    };

    /**
     * Create a callback function for the ck edit (special case of blockstatic content
     * 
     * @param {object} container
     */
    contentHelper.getChangeCallbackForBlockStatic = function(container){

        return _.throttle(function(data){

            var $pseudoContainer = $('<div>').html(data);
            
            $pseudoContainer.contents().each(function(){
                
                if(this.nodeType === 3 && this.nodeValue.trim()){
                    
                    //use jquery to wrap all content by a <p> 
                    $pseudoContainer.wrapInner('<p>');
                    
                    //... transform it into valid html :  <p><p>aaa</p></p> becomes <p></p><p>aaa</p><p></p>
                    $pseudoContainer = $('<div>').html($pseudoContainer.html());
                    
                    return false;//breaks jquery each loop
                }
            });

            textWrapper.unwrap($pseudoContainer);

            container.body(contentHelper.getContent($pseudoContainer));

        }, 800);
    };

    contentHelper.serializeElements = function($el){

        var existingElements = [];

        //select only the first level of ".widget-box" found
        $el.find('.widget-box:not(.widget-box *)').each(function(){

            var $qtiElementWidget = $(this);

            if($qtiElementWidget.data('serial')){

                //an existing qti element:
                var serial = $qtiElementWidget.data('serial');
                $qtiElementWidget.replaceWith('{{' + serial + '}}');

                //store existing element
                existingElements.push(serial);

            }else if($qtiElementWidget.data('new') && $qtiElementWidget.data('qti-class')){

                //a newly inserted qti element
                var qtiClass = $qtiElementWidget.data('qti-class');
                $qtiElementWidget.replaceWith('{{' + qtiClass + ':new}}');

            }else{

                throw 'unknown qti-widget type';
            }

        });

        return existingElements;
    };

    contentHelper.destroyGridWidgets = function($elt, inClone){

        $elt.removeData('qti-grid-options');

        $elt.find('.grid-row, [class*=" col-"], [class^="col-"]')
            .removeAttr('style')
            .removeAttr('data-active')
            .removeAttr('data-units');

        $elt.children('.ui-draggable-dragging').remove();

        resizable.destroy($elt, inClone);
        
        $elt.find('.contextual-popup').remove();
    };

    return contentHelper;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiItem/qtiCreator/helper/ckConfigurator',['lodash', 'ui/ckeditor/ckConfigurator', 'mathJax'], function(_, ckConfigurator, mathJax) {
    'use strict';

    var _defaults = {
        qtiImage : true,
        qtiMedia : true,
        qtiInclude : true,
        underline : true,
        mathJax : !!mathJax
    };

    /**
     * Generate a configuration object for CKEDITOR
     *
     * @param editor instance of ckeditor
     * @param toolbarType block | inline | flow | qtiBlock | qtiInline | qtiFlow | reset to get back to normal
     * @param {Object} [options] - is based on the CKEDITOR config object with some additional sugar
     *        Note that it's here you need to add parameters for the resource manager.
     *        Some options are not covered in http://docs.ckeditor.com/#!/api/CKEDITOR.config
     * @param [options.dtdOverrides] - @see dtdOverrides which pre-defines them
     * @param {Object} [options.positionedPlugins] - @see ckConfig.positionedPlugins
     * @param {Boolean} [options.qtiImage] - enables the qtiImage plugin
     * @param {Boolean} [options.qtiInclude] - enables the qtiInclude plugin
     * @param {Boolean} [options.underline] - enables the underline plugin
     * @param {Boolean} [options.mathJax] - enables the mathJax plugin
     *
     * @see http://docs.ckeditor.com/#!/api/CKEDITOR.config
     */
    var getConfig = function(editor, toolbarType, options){
        return ckConfigurator.getConfig(editor, toolbarType, _.defaults(options || {}, _defaults));
    };

    return {
        getConfig : getConfig
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
define('taoQtiItem/qtiCreator/widgets/helpers/content',[
    'jquery',
    'lodash',
    'taoQtiItem/qtiCreator/helper/creatorRenderer',
    'taoQtiItem/qtiCreator/model/helper/container',
    'taoQtiItem/qtiCreator/editor/gridEditor/content'
], function($, _, creatorRenderer, containerHelper, gridContentHelper){
    'use strict';

    var contentHelper = {};

    /**
     * Create elements from a widget box having the 'data-new=true' attribute
     *  - render the elements at their placeholder in $container
     *  - apply callback on each widget
     * @param container - element that will contain the new ones
     * @param $container - DOM container where the new elements are created
     * @param data - corresponding HTML (?)
     * @param callback - will be triggered for each new created element
     */
    contentHelper.createElements = function(container, $container, data, callback){

        var $dummy = $('<div>').html(data);

        containerHelper.createElements(container, gridContentHelper.getContent($dummy), function(newElts){

            creatorRenderer.get().load(function(){
                var serial,
                    elt,
                    $placeholder,
                    $widget,
                    widget;

                for(serial in newElts){

                    elt = newElts[serial];
                    $placeholder = $container.find('.widget-box[data-new][data-qti-class=' + elt.qtiClass + ']');

                    elt.setRenderer(this);
                    elt.render($placeholder);

                    //render widget
                    elt.postRender();

                    widget = elt.data('widget');
                    $widget = widget.$original;

                    //inform height modification
                    $widget.trigger('contentChange.gridEdit');

                    if(_.isFunction(callback)){
                        callback(widget);
                    }
                }

            }, this.getUsedClasses());
        });

    };

    contentHelper.changeInnerWidgetState = function _changeInnerWidgetState(outerWidget, state){

         var selector = [];
        _.each(['img', 'math', 'object', 'include'], function(qtiClass){
            selector.push('[data-html-editable] .widget-'+qtiClass);
        });

        outerWidget.$container.find(selector.join(',')).each(function(){
            var innerWidget = $(this).data('widget');
            if(innerWidget){
                innerWidget.changeState(state);
            }
        });
    };

    return contentHelper;
});


define('tpl!taoQtiItem/qtiCreator/tpl/notifications/deletingInfoBox', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "You have deleted an element", options) : helperMissing.call(depth0, "__", "You have deleted an element", options)))
    + ".\n    ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "You have deleted", options) : helperMissing.call(depth0, "__", "You have deleted", options)))
    + " ";
  if (helper = helpers.count) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.count); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "elements", options) : helperMissing.call(depth0, "__", "elements", options)))
    + ".\n    ";
  return buffer;
  }

  buffer += "<div class=\"feedback-info popup\" data-for=\"";
  if (helper = helpers.serial) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.serial); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <span class=\"icon-info\"></span>\n    ";
  stack1 = (helper = helpers.equal || (depth0 && depth0.equal),options={hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.count), 1, options) : helperMissing.call(depth0, "equal", (depth0 && depth0.count), 1, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <a class=\"undo\" href=\"#\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "undo", options) : helperMissing.call(depth0, "__", "undo", options)))
    + "</a>\n    <span title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Remove Message", options) : helperMissing.call(depth0, "__", "Remove Message", options)))
    + "\" class=\"icon-close close-trigger\"></span>\n</div>";
  return buffer;
  });
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technlogies SA
 *
 */
define('taoQtiItem/qtiCreator/widgets/helpers/deletingState',['lodash', 'jquery', 'tpl!taoQtiItem/qtiCreator/tpl/notifications/deletingInfoBox'], function(_, $, deletingInfoTpl){
    'use strict';

    var _timeout = 10000;

    var _destroy = function _destroy($messageBox){
        $('body').off('.deleting');
        $messageBox.remove();
    };

    var undo = function undo($messageBox){
        $messageBox.trigger('undo.deleting');
        _destroy($messageBox);
    };

    var _bindEvents = function _bindEvents($messageBox){

        $('body').on('mousedown.deleting keydown.deleting', function(e){

            if(e.ctrlKey || e.metaKey){
                //trigger undo callback if the standard keyboard shortcut ctrl+z is triggered
                if(e.keyCode == 90){//z-key
                    undo($messageBox);
                }
                e.preventDefault();
                return;
            }

            //confirm deleting whenever user interact with another object
            if(e.target !== $messageBox[0] && !$.contains($messageBox[0], e.target)){
                _confirmDeletion($messageBox, 400);
            }
        });
        
        $messageBox.find('a.undo').on('click', function(e){
            e.preventDefault();
            undo($messageBox);
        });

        $messageBox.find('.close-trigger').on('click', function(e){
            e.preventDefault();
            _confirmDeletion($messageBox, 0);
        });

        setTimeout(function(){
            _confirmDeletion($messageBox, 1000);
        }, _timeout);
    };

    var _confirmDeletion = function($messageBox, fadeDelay){
        //only allow deletion if the message has not already been deleted yet
        if($messageBox.length && $.contains(document, $messageBox[0])){
            $messageBox.trigger('confirm.deleting');
            $messageBox.fadeOut(fadeDelay, function(){
                _destroy($messageBox);
            });
        }
    };
    
    var deletingHelper = {
        createInfoBox : function(widgets){

            var $messageBox = $(deletingInfoTpl({
                serial : 'widgets',
                count : widgets.length
            }));

            $('body').append($messageBox);

            $messageBox.css({
                'display' : 'block',
                'position' : 'fixed',
                'top' : '50px',
                'left' : '50%',
                'margin-left' : '-200px',
                'width' : '400px',
                zIndex : 999999
            });
            
            _bindEvents($messageBox);
            
            _.each(widgets, function(w){
                w.on('beforeStateInit', function(){
                    _confirmDeletion($messageBox, 400);
                });
            });
        
            return $messageBox;
        }
    };

    return deletingHelper;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
define('taoQtiItem/qtiCreator/editor/ckEditor/htmlEditor',[
    'lodash',
    'i18n',
    'jquery',
    'ckeditor',
    'core/promise',
    'taoQtiItem/qtiCreator/helper/ckConfigurator',
    'taoQtiItem/qtiItem/core/Element',
    'taoQtiItem/qtiCreator/widgets/helpers/content',
    'taoQtiItem/qtiCreator/widgets/helpers/deletingState'
], function(
    _,
    __,
    $,
    CKEditor,
    Promise,
    ckConfigurator,
    Element,
    contentHelper,
    deletingHelper
){
    "use strict";

    var _defaults = {
        placeholder : __('some text ...'),
        shieldInnerContent : true,
        passthroughInnerContent : false,
        autofocus : true
    };

    var placeholderClass = 'cke-placeholder';

    var editorFactory;

    //prevent auto inline editor creation:
    CKEditor.disableAutoInline = true;

    /**
     * @param {JQuery} $editable - the element to be transformed into an editor
     * @param {JQuery} $editableContainer - the container of the editor
     * @param {Object} [options]
     * @param {String} [options.placeholder] - the place holder text
     * @param {Boolean} [options.shieldInnerContent] - define if the inner widget content should be protected or not
     * @param {Boolean} [options.passthroughInnerContent] - define if the inner widget content should be accessible directly or not
     * @param {String} [options.removePlugins] - a coma-separated list of plugins that should not be loaded: 'plugin1,plugin2,plugin3'
     * @param {Boolean} [options.autofocus] - automatically focus
     */
    function _buildEditor($editable, $editableContainer, options){

        var ckConfig,
            widget = (options.data || {}).widget,
            areaBroker = widget && widget.getAreaBroker && widget.getAreaBroker(),
            $toolbarArea = areaBroker && areaBroker.getToolbarArea && areaBroker.getToolbarArea();

        options = _.defaults(options, _defaults);

        if( !($editable instanceof $) || !$editable.length){
            throw new Error('invalid jquery element for $editable');
        }
        if( !($editableContainer instanceof $) || !$editableContainer.length){
            throw new Error('invalid jquery element for $editableContainer');
        }

        if (options.placeholder && options.placeholder !== '') {
            if ($editable.is('input')) {
                $editable.attr('placeholder', options.placeholder);
            } else {
                $editable.attr('data-placeholder', options.placeholder);
            }
        }

        ckConfig = {
            dtdMode : 'qti',
            autoParagraph : false,
            removePlugins : options.removePlugins || '',
            enterMode : options.enterMode || CKEditor.ENTER_P,
            floatSpaceDockedOffsetY : 10,
            sharedSpaces : {
                top: ($toolbarArea && $toolbarArea.attr('id')) || 'toolbar-top'
            },
            taoQtiItem : {
                /**
                 * @param {DOM} tempWidget - this contains the DOM nodes created by a ckEditor plugin,
                 *                           wrapped in a temporary widget container (= a widget container with a [data-new="true"] attribute)
                 */
                insert : function(tempWidget){
                    var $newContent = $(tempWidget).clone(); // we keep the original content for later use
                    if(options.data && options.data.container && options.data.widget){
                        contentHelper.createElements(options.data.container, $editable, _htmlEncode(this.getData()), function(createdWidget){
                            var createdElement = createdWidget.element;

                            if (_.isFunction(createdElement.initContainer)) {
                                createdElement.body($newContent.html());
                                createdWidget.rebuild();
                                createdWidget = createdElement.data('widget');
                            }
                            _activateInnerWidget(options.data.widget, createdWidget);
                        });
                    }
                }
            },
            on : {
                instanceReady : function(e){
                    var widgets = {},
                        editor = e.editor;

                    //store it in editable elt data attr
                    $editable.data('editor', editor);
                    $editable.data('editor-options', options);

                    //need to debounce the callback to prevent the changes made by undo to trigger the event change twice
                    editor.on('change', _.debounce(function markupChanged(){
                        _detectWidgetDeletion($editable, widgets, editor);
                        if(_.isFunction(options.change)){
                            options.change.call(editor, _htmlEncode(editor.getData()));
                        }
                    }, 100, {
                        leading: true
                    }));

                    managePlaceholder($editable, editor);

                    if(options.data && options.data.container){

                        //store in data-qti-container attribute the editor instance as soon as it is ready
                        $editable.data('qti-container', options.data.container);

                        //init editable
                        widgets = _rebuildWidgets(options.data.container, $editable, {
                            restoreState : true
                        });
                        if(options.shieldInnerContent){
                            _shieldInnerContent($editable, options.data.widget);
                        }
                    }

                    if (options.autofocus) {
                        _focus(editor);
                    }

                    $editable.trigger('editorready', [editor]);

                    $('.qti-item').trigger('toolbarchange');
                },
                blur : function() {
                    if ($toolbarArea) {
                        $toolbarArea.hide();
                    }
                },
                focus : function(){
                    if ($toolbarArea) {
                        $toolbarArea.show();
                    }

                    //callback:
                    if(_.isFunction(options.focus)){
                        options.focus.call(this, _htmlEncode(this.getData()));
                    }

                    $editable.trigger('editorfocus');

                    $('.qti-item').trigger('toolbarchange');
                },
                configLoaded : function(e){
                    //@todo : do we really have to wait here to initialize the config?
                    var toolbarType = '';
                    if(options.toolbar && _.isArray(options.toolbar)){
                        ckConfig.toolbar = options.toolbar;
                    }else{
                        toolbarType = getTooltypeFromContainer($editableContainer);
                    }

                    if(typeof options.qtiMedia !== 'undefined'){
                        ckConfig.qtiMedia = options.qtiMedia;
                    }
                    if(typeof options.qtiImage !== 'undefined'){
                        ckConfig.qtiImage = options.qtiImage;
                    }
                    if(typeof options.qtiInclude !== 'undefined'){
                        ckConfig.qtiInclude = options.qtiInclude;
                    }
                    if(typeof options.highlight !== 'undefined'){
                        ckConfig.highlight = options.highlight;
                    }

                    e.editor.config = ckConfigurator.getConfig(e.editor, toolbarType, ckConfig);
                },
                afterPaste : function(){
                    //@todo : we may add some processing on the editor after paste
                }
            }
        };

        return CKEditor.inline($editable[0], ckConfig);
    }

    /**
     * Handle the placeholder for non-input elements.
     * To avoid CK nasty side-effects of using the placeholder attribute on non-input elements,
     * we handle the placeholder with css.
     */
    function managePlaceholder($editable, editor) {
        if (!$editable.is('input')) {
            togglePlaceholder($editable);

            editor.on('change', function() {
                togglePlaceholder($editable);
            });
        }
    }

    /**
     * Toggle the placeholder class on the editable depending on its content
     */
    function togglePlaceholder($editable) {
        var nonEmptyContent = ['img', 'table', 'math', 'object', 'printedVariable', '.tooltip-target'];

        if ($editable.text().trim() === ''
            && ! $editable.find(nonEmptyContent.join(',')).length
        ) {
            $editable.addClass(placeholderClass);
        } else {
            removePlaceholder($editable);
        }
    }

    function removePlaceholder($editable) {
        $editable.removeClass(placeholderClass);
    }

    /**
     * Assess
     * @param {type} $editableContainer
     * @returns {String}
     */
    function getTooltypeFromContainer($editableContainer){

        var toolbarType = 'qtiFlow';
        // build parameter for toolbar
        if($editableContainer.hasClass('widget-blockInteraction') || $editableContainer.hasClass('widget-textBlock') || $editableContainer.hasClass('widget-rubricBlock')){
            toolbarType = 'qtiBlock';
        }else if($editableContainer.hasClass('qti-prompt-container') || $editableContainer.hasClass('widget-hottext')){
            toolbarType = 'qtiInline';
        }
        return toolbarType;
    }

    /**
     * Find an inner element by its data attribute name
     * @param {JQuery} $container
     * @param {String} dataAttribute
     */
    function _find($container, dataAttribute){

        var $collection;

        if($container.data(dataAttribute)){
            $collection = $container;
        }else{
            $collection = $container.find('[data-' + dataAttribute + '=true]');
        }
        return $collection;
    }

    /**
     * Rebuild all innerwidgets located inside a container
     *
     * @param {Object} container
     * @param {JQuery} $container
     * @param {Object} options
     */
    function _rebuildWidgets(container, $container, options){
        var widgets = {};
        options = options || {};

        //re-init all widgets:
        _.each(_.values(container.elements), function(elt){

            var widget = elt.data('widget'),
                currentState = widget.getCurrentState().name;

            widgets[elt.serial] = widget.rebuild({
                context : $container,
                ready : function(widget){
                    if(options.restoreState){
                        //restore current state
                        widget.changeState(currentState);
                    }
                }
            });
        });

        $container.trigger('widgetCreated', [widgets, container]);

        return widgets;
    }

    /**
     * Find the widget container by its serial
     *
     * @param {JQuery} $container
     * @param {String} serial
     */
    function _findWidgetContainer($container, serial){
        return $container.find('.widget-box[data-serial=' + serial + ']');
    }

    /**
     * Detect if an inner widget has been removed
     *
     * @param {JQuery} $container
     * @param {Array} widgets
     * @param {Object} editor
     * @returns {undefined}
     */
    function _detectWidgetDeletion($container, widgets, editor){

        var deleted = [];
        var container = $container.data('qti-container');
        var $widget;

        _.each(widgets, function(w){

            if(!w.element.data('removed')){
                $widget = _findWidgetContainer($container, w.serial);
                if(!$widget.length){
                    deleted.push(w);
                }
            }

        });

        if(deleted.length){
            var undoCmd = editor.getCommand( 'undo');
            var $messageBox = deletingHelper.createInfoBox(deleted);

            $messageBox.on('confirm.deleting', function(){

                _.each(deleted, function(w){
                    w.element.remove();
                    w.destroy();
                });

                editor.resetUndo();

            }).on('undo.deleting', function(){

                editor.undoManager.undo();

                //need to rebuild the inner widgets in case the undo restored some qti elements
                _rebuildWidgets(container, $container, {
                    restoreState : true
                });

                _shieldInnerContent($container, container.data('widget'));
            });

            if (undoCmd){
                //catch ckeditor's undo event to trigger the same behaviour as the undo action dialog
                undoCmd.on('afterUndo', function(){
                    $messageBox.find('a.undo').click();
                });
            }

        }
    }

    /**
     * @param {JQuery} $widget - the widget to be protected
     * @returns {JQuery} The added layer (shield)
     */
    function addShield($widget){
        var $shield = $('<button>', {
            'class' : 'html-editable-shield'
        });

        $widget.attr('contenteditable', false);
        $widget.append($shield);
        return $shield;
    }

    /**
     * Protect the inner widgets of a container
     *
     * @param {JQuery} $container
     * @param {Object} containerWidget
     * @returns {undefined}
     */
    function _shieldInnerContent($container, containerWidget){

        $container.find('.widget-box').each(function(){
            var $widget = $(this);

            addShield($widget).on('click', function(e){
                var innerWidget;

                //click on shield:
                //1. this.widget.changeState('sleep');
                //2. clicked widget.changeState('active');

                e.stopPropagation();

                innerWidget = $widget.data('widget');
                _activateInnerWidget(containerWidget, innerWidget);
            });
        });

    }

    /**
     * Activate the inner widget
     *
     * @param {Object} containerWidget
     * @param {Object} innerWidget
     * @returns {undefined}
     */
    function _activateInnerWidget(containerWidget, innerWidget){
        var listenToWidgetCreation;

        if(containerWidget && containerWidget.element && containerWidget.element.qtiClass){

            listenToWidgetCreation = function(){
                containerWidget.$container
                    .off('widgetCreated')
                    .one('widgetCreated', function(e, widgets){
                        var targetWidget = widgets[innerWidget.serial];
                        if(targetWidget){
                            //FIXME potential race condition ? (debounce the enclosing event handler ?)
                            _.delay(function(){
                                if(Element.isA(targetWidget.element, 'interaction')){
                                    targetWidget.changeState('question');
                                } else{
                                    targetWidget.changeState('active');
                                }
                            }, 100);
                        }
                    });

            };

            if(Element.isA(containerWidget.element, '_container') && !containerWidget.element.data('stateless')){

                //only _container that are NOT stateless need to change its state to sleep before activating the new one.
                listenToWidgetCreation();
                containerWidget.changeState('sleep');

            }else if(Element.isA(containerWidget.element, 'interaction')){

                listenToWidgetCreation();
                containerWidget.changeState('sleep');

            }else if(Element.isA(containerWidget.element, 'choice')){

                listenToWidgetCreation();
                containerWidget.changeState('question');

            }else if(Element.isA(containerWidget.element, 'table')){

                listenToWidgetCreation();
                containerWidget.changeState('sleep');

            }else if(Element.isA(innerWidget.element, 'choice')){

                innerWidget.changeState('choice');

            }else{

                innerWidget.changeState('active');
            }

        }else{

            innerWidget.changeState('active');
        }
    }

    /**
     * Special encoding of ouput html generated from ie8 : moved to xmlRenderer
     */
    function _htmlEncode(encodedStr){
        return encodedStr;
    }

    /**
     * Focus the editor and set the cursor to the end
     *
     * @param {Object} editor - the ckeditor instance
     * @returns {undefined}
     */
    function _focus(editor){
        var range;
        if (editor.editable() && editor.editable().$.parentNode){
            editor.focus();
            range = editor.createRange();
            range.moveToElementEditablePosition(editor.editable(), true);
            editor.getSelection().selectRanges([range]);
        }
    }

    editorFactory = {
        /**
         * Check if all data-html-editable has an editor
         *
         * @param {type} $container
         * @returns {undefined}
         */
        hasEditor : function($container){

            var hasEditor = false;

            _find($container, 'html-editable').each(function(){
                hasEditor = !!$(this).data('editor');
                return hasEditor; //continue if true, break if false
            });

            return hasEditor;
        },
        /**
         * Instanciate the editor
         *
         * @param {JQuery} $container
         * @param {Object} [editorOptions]
         * @param {String} [editorOptions.placeholder] - the place holder text
         * @param {Boolean} [editorOptions.shieldInnerContent] - define if the inner widget content should be protected or not
         * @param {Boolean} [editorOptions.passthroughInnerContent] - define if the inner widget content should be accessible directly or not
         * @param {Boolean} [editorOptions.enterMode] - what is the behavior of the "Enter" key (see ENTER_MODE_xxx in ckEditor configuration)
         * @returns {undefined}
         */
        buildEditor : function($container, editorOptions){
            var buildTasks = [];
            _find($container, 'html-editable-container').each(function(){

                var $editableContainer = $(this),
                    $editable = $editableContainer.find('[data-html-editable]');

                buildTasks.push(new Promise(function (resolve) {
                    //need to make the element html editable to enable ck inline editing:
                    $editable.attr('contenteditable', true);

                    //build it
                    _buildEditor($editable, $editableContainer, editorOptions);

                    $editable.on('editorready', resolve);
                }));
            });
            return Promise.all(buildTasks);
        },
        /**
         * Destroy the editor
         *
         * @param {JQuery} $container
         * @returns {undefined}
         */
        destroyEditor : function($container){
            var destructTasks = [];
            _find($container, 'html-editable-container').each(function(){

                var editor,
                    options,
                    $editableContainer = $(this),
                    $editable = $editableContainer.find('[data-html-editable]');

                $editable.removeAttr('contenteditable');
                if($editable.data('editor')){

                    destructTasks.push(new Promise(function (resolve) {
                        editor = $editable.data('editor');
                        options = $editable.data('editor-options');

                        //before destroying, ensure that data is stored
                        if(_.isFunction(options.change)){
                            options.change.call(editor, _htmlEncode(editor.getData()));
                        }

                        removePlaceholder($editable);

                        editor.on('destroy', function () {
                            $editable.removeData('editor').removeData('editor-options');
                            if($editable.data('qti-container')){
                                _rebuildWidgets($editable.data('qti-container'), $editable);
                            }

                            $editable.trigger('editordestroyed');
                            resolve();
                        });

                        editor.focusManager.blur(true);
                        editor.destroy();
                    }));
                }
            });
            return Promise.all(destructTasks);
        },
        /**
         * Get the editor content
         *
         * @param {JQuery} $editable
         */
        getData : function($editable){
            var editor = $editable.data('editor');
            if(editor){
                return _htmlEncode(editor.getData());
            }else{
                throw new Error('no editor attached to the DOM element');
            }
        },
        /**
         * Allow to set the editor content. Works only with plain text for now.
         *
         * @param {JQuery} $editable
         * @param {String} data
         */
        setData : function($editable, data) {
            var editor = $editable.data('editor');
            if(editor){
                if (_.isString(data)) {
                    editor.setData(_.escape(data));
                }
            }else{
                throw new Error('no editor attached to the DOM element');
            }
        },
        /**
         * Focus all the editors found in the given container
         *
         * @param {JQuery} $editable
         * @returns {undefined}
         */
        focus : function($editable){
            _find($editable, 'html-editable').each(function(){
                var editor = $(this).data('editor');
                if(editor){
                    _focus(editor);
                }
            });
        }
    };

    return editorFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014-2017 (original work) Open Assessment Technologies SA;
 *
 */
define('taoQtiItem/qtiCreator/editor/containerEditor',[
    'lodash',
    'jquery',
    'core/promise',
    'taoQtiItem/qtiItem/core/Loader',
    'taoQtiItem/qtiCreator/model/Container',
    'taoQtiItem/qtiCreator/model/Item',
    'taoQtiItem/qtiCreator/model/helper/event',
    'taoQtiItem/qtiCreator/model/qtiClasses',
    'taoQtiItem/qtiCreator/helper/commonRenderer',
    'taoQtiItem/qtiCreator/helper/xmlRenderer',
    'taoQtiItem/qtiItem/helper/simpleParser',
    'taoQtiItem/qtiCreator/helper/creatorRenderer',
    'taoQtiItem/qtiCreator/helper/xincludeRenderer',
    'taoQtiItem/qtiCreator/editor/gridEditor/content',
    'taoQtiItem/qtiCreator/editor/ckEditor/htmlEditor'
], function(_, $, Promise, Loader, Container, Item, event, allQtiClasses, commonRenderer, xmlRenderer, simpleParser, creatorRenderer, xincludeRenderer, content, htmlEditor){
    "use strict";

    var _ns = 'containereditor';

    var _defaults = {
        change : _.noop,
        markup : '',
        markupSelector : '',
        qtiMedia : false
    };

    event.initElementToWidgetListeners();

    function parser($container){

        //detect math ns :
        var mathNs = 'm';//for 'http://www.w3.org/1998/Math/MathML'

        //parse qti xml content to build a data object
        var data = simpleParser.parse($container.clone(), {
            ns : {
                math : mathNs
            }
        });

        if(data.body){
            return data.body;
        }else{
            throw new Error('invalid content for qti container');
        }
    }

    /**
     * Transform the given dom element into a rich-text editor
     *
     * @param {JQuery} $container - the container of the DOM element that is going to editable
     * @param {Object} [options]
     * @param {String} [options.markup] - the markup to be use as the initial editor content
     * @param {String} [options.markupSelector] - the element in $xontainer that holds the html to be used as the initial editor content
     * @param {Object} [options.related] - define the qti element object this editor is attached too. Very important to edit a picture or math element inside it because prevents leaving the editing state of the related element.
     * @param {Function} [options.change] - the callback called when the editor content has been modified
     * @param {String} [options.placeholder] - the placeholder text of the container editor when
     * @param {Array} [options.toolbar] - the ck toolbar
     * @param {Boolean} [options.qtiMedia=false] - allow insert media object
     * @param {Object} [options.areaBroker] - allow to set a custom areaBroker on the renderer
     * @param {String} [options.removePlugins] - a coma-separated plugin list that should not be loaded
     * @param {Object} [options.metadata] - some metadata to attach to the root element (ex: { myDataName: 'myDataValue' })
     * @param {Boolean} [options.resetRenderer] - force resetting the renderer
     * @param {Boolean} [options.autofocus] - automatically focus the editor
     * @returns {undefined}
     */
    function create($container, options){

        var html, htmls, data, loader;

        options = _.defaults(options || {}, _defaults);

        //assign proper markup
        if(options.markup){
            html = options.markup;
            if(options.markupSelector){
                htmls = extractHtmlFromMarkup(html, options.markupSelector);
                html = htmls[0] || '';
            }
            $container.html(html);
        }

        data = parser($container);
        loader = new Loader().setClassesLocation(allQtiClasses);
        loader.loadRequiredClasses(data, function(){

            var item,
                containerEditors,
                renderer,
                qtiClasses = ['img', 'object', 'math', 'include', 'printedVariable', '_container', '_tooltip'];

            //create a new container object
            var container = new Container();

            //tag the new container as statelss, which means that its state is not supposed to change
            container.data('stateless', true);

            $container.data('container', container);

            //need to attach a container to the item to enable innserElement.remove()
            //@todo fix this
            item = new Item().setElement(container);
            container.setRootElement(item);

            if (options.metadata) {
                _.each(options.metadata, function (value, name) {
                    item.data(name, value);
                });
            }

            //associate it to the interaction?
            if(options.related){
                containerEditors = options.related.data('container-editors') || [];
                containerEditors.push(container);
                options.related.data('container-editors', containerEditors);
            }

            this.loadContainer(container, data);

            //apply common renderer :
            renderer = creatorRenderer.get(options.resetRenderer, {}, options.areaBroker);
            renderer.load(function(){

                var baseUrl = this.getOption('baseUrl');
                container.setRenderer(this);
                $container.html(container.render());
                container.postRender();

                //resolve xinclude
                _.each(container.getComposingElements(), function(element){
                    if(element.qtiClass === 'include'){
                        xincludeRenderer.render(element.data('widget'), baseUrl);
                    }
                });

                buildContainer($container);
                buildEditor($container, container, {
                    placeholder : options.placeholder || undefined,
                    toolbar : options.toolbar || undefined,
                    qtiMedia : options.qtiMedia,
                    highlight : options.highlight,
                    removePlugins : options.removePlugins || '',
                    areaBroker : options.areaBroker,
                    autofocus : options.autofocus || false
                });

                $container
                    .off('.' + _ns)
                    .on(event.getList(_ns + event.getNs() + event.getNsModel()).join(' '), _.throttle(function(){
                        var editorContent = container.render(xmlRenderer.get());
                        $container.trigger('containerchange.' + _ns, [editorContent]);

                        if(_.isFunction(options.change)){
                            options.change(editorContent);
                        }
                    }, 600));

                $container.trigger('editorready.containereditor');

            }, qtiClasses);

        });

    }

    function buildContainer($container){

        $container.wrapInner($('<div>', {'class' : 'container-editor', 'data-html-editable' : true}));
    }

    function cleanup($container){
        var container = $container.data('container');
        return new Promise(function (resolve) {
            if(container){
                $(document).off('.' + container.serial);
                commonRenderer.load(['img', 'object', 'math', 'include', '_container', 'printedVariable', '_tooltip'], function(){
                    $container.html(container.render(this));
                    resolve();
                });

                $container.removeData('container');
            } else {
                resolve();
            }
        });
    }

    /**
     * create a false widget that is required in html editor
     *
     * @param {JQuery} $editableContainer
     * @param {Object} container
     * @param {Object} options
     * @param {Object} options.areaBroker
     * @returns {Object} The fake widget object
     */
    function createFakeWidget($editableContainer, container, options){

        var widget = {
            $container : $editableContainer,
            element : container,
            changeState : _.noop,
            getAreaBroker : function getAreaBroker() {
                return options.areaBroker;
            }
        };
        //associate the widget to the container
        container.data('widget', widget);

        return widget;
    }

    function buildEditor($editableContainer, container, options){

        $editableContainer.attr('data-html-editable-container', true);

        if(!htmlEditor.hasEditor($editableContainer)){

            htmlEditor.buildEditor($editableContainer, _.defaults(options || {}, {
                shieldInnerContent : false,
                passthroughInnerContent : false,
                change : content.getChangeCallback(container),
                data : {
                    widget : createFakeWidget($editableContainer, container, options),
                    container : container
                }
            }));
        }
    }

    function destroy($editableContainer){
        return htmlEditor.destroyEditor($editableContainer)
            .then(function() {
                $editableContainer.removeAttr('data-html-editable-container');
                return cleanup($editableContainer);
            });
    }

    function extractHtmlFromMarkup(markupStr, selector){
        var $found = $('<div>').html(markupStr).find(selector);
        var ret = [];
        $found.each(function(){
            ret.push($(this).html());
        });
        return ret;
    }

    return {
        create : create,
        destroy : destroy
    };
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA;
 */
/**
 * Instanciate a Wysiwyg editor to create QTI content.
 *
 * @author Christophe Noël <christophe@taotesting.com>
 */
define('taoQtiTest/controller/creator/qtiContentCreator',[
    'lodash',
    'jquery',
    'lib/uuid',
    'taoQtiItem/qtiCreator/helper/commonRenderer',
    'taoQtiItem/qtiCreator/editor/containerEditor'
], function(_, $, uuid, qtiCommonRenderer, containerEditor) {
    'use strict';

    return {
        create: function create(creatorContext, $container, options) {
            var self = this,
                editorId = uuid(),
                areaBroker = creatorContext.getAreaBroker(),
                modelOverseer = creatorContext.getModelOverseer();

            var removePlugins = [
                    'magicline',
                    'taoqtiimage',
                    'taoqtimedia',
                    'taoqtimaths',
                    'taoqtiinclude',
                    'taoqtitable',
                    'sharedspace' // That Ck instance still use floatingspace to position the toolbar, whereas the sharedspace plugin is used by the Item creator
                ].join(','),

                toolbar = [
                    {
                        name : 'basicstyles',
                        items : ['Bold', 'Italic', 'Subscript', 'Superscript']
                    }, {
                        name : 'insert',
                        items : ['SpecialChar', 'TaoQtiPrintedVariable']
                    }, {
                        name : 'links',
                        items : ['Link']
                    },
                    '/',
                    {
                        name : 'styles',
                        items : ['Format']
                    }, {
                        name : 'paragraph',
                        items : ['NumberedList', 'BulletedList', '-', 'Blockquote', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']
                    }
                ];

            qtiCommonRenderer.setContext(areaBroker.getContentCreatorPanelArea());

            containerEditor.create($container, {
                areaBroker: areaBroker,
                removePlugins: removePlugins,
                toolbar: toolbar,
                metadata: {
                    getOutcomes: function getOutcomes() {
                        return modelOverseer.getOutcomesNames();
                    }
                },
                change: options.change || _.noop,
                resetRenderer: true,
                autofocus: false
            });

            // destroying ckInstance on editor close
            creatorContext.on('creatorclose.' + editorId, function() {
                self.destroy(creatorContext, $container);
            });

            $container.data('editorId', editorId);
        },

        /**
         * @returns {Promise} - when editor is destroyed
         */
        destroy: function destroy(creatorContext, $container) {
            var editorId = $container.data('editorId');
            if (editorId) {
                creatorContext.off('.' + editorId);
            }
            return containerEditor.destroy($container);
        }
    };
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/rubricblock',[
    'jquery',
    'lodash',
    'i18n',
    'ui/hider',
    'ui/dialog/alert',
    'util/namespace',
    'taoQtiTest/controller/creator/views/actions',
    'helpers',
    'taoQtiTest/controller/creator/encoders/dom2qti',
    'taoQtiTest/controller/creator/helpers/qtiElement',
    'taoQtiTest/controller/creator/qtiContentCreator',
    'ckeditor',
], function ($, _, __, hider, dialogAlert, namespaceHelper, actions, helpers, Dom2QtiEncoder, qtiElementHelper, qtiContentCreator) {
    'use strict';

    /**
     * The rubriclockView setup RB related components and behavior
     *
     * @exports taoQtiTest/controller/creator/views/rubricblock
     */
    return {
        /**
         * Set up a rubric block: init action behaviors. Called for each one.
         *
         * @param {Object} creatorContext
         * @param {Object} rubricModel - the rubric block data
         * @param {jQueryElement} $rubricBlock - the rubric block to set up
         */
        setUp: function setUp(creatorContext, rubricModel, $rubricBlock) {
            var modelOverseer = creatorContext.getModelOverseer();
            var areaBroker = creatorContext.getAreaBroker();
            var $rubricBlockContent = $('.rubricblock-content', $rubricBlock);

            /**
             * Bind a listener only related to this rubric.
             * @param {jQuery} $el
             * @param {String} eventName
             * @param {Function} cb
             * @returns {jQuery}
             */
            function bindEvent($el, eventName, cb) {
                eventName = namespaceHelper.namespaceAll(eventName, rubricModel.uid);
                return $el.off(eventName).on(eventName, cb);
            }

            /**
             * Ensures an html content is wrapped by a container tag.
             * @param {String} html
             * @returns {String}
             */
            function ensureWrap(html) {
                html = (html || '').trim();
                if (html.charAt(0) !== '<' || html.charAt(html.length - 1) !== '>') {
                    html = '<div>' + html + '</div>';
                }
                if ($(html).length > 1) {
                    html = '<div>' + html + '</div>';
                }
                return html;
            }

            /**
             * Forwards the editor content into the model
             */
            function editorToModel(html) {
                var rubric = qtiElementHelper.lookupElement(rubricModel, 'rubricBlock', 'content');
                var wrapper = qtiElementHelper.lookupElement(rubricModel, 'rubricBlock.div.feedbackBlock', 'content');
                var content = Dom2QtiEncoder.decode(ensureWrap(html));

                if (wrapper) {
                    wrapper.content = content;
                } else {
                    rubric.content = content;
                }
            }

            /**
             * Forwards the model content into the editor
             */
            function modelToEditor() {
                var rubric = qtiElementHelper.lookupElement(rubricModel, 'rubricBlock', 'content') || {};
                var wrapper = qtiElementHelper.lookupElement(rubricModel, 'rubricBlock.div.feedbackBlock', 'content');
                var content = wrapper ? wrapper.content : rubric.content;
                var html = ensureWrap(Dom2QtiEncoder.encode(content));

                // Destroy any existing CKEditor instance
                qtiContentCreator.destroy(creatorContext, $rubricBlockContent).then(function() {
                    // update the editor content
                    $rubricBlockContent.html(html);

                    // Re-create the Qti-ckEditor instance
                    qtiContentCreator.create(creatorContext, $rubricBlockContent, {
                        change: function change(editorContent) {
                            editorToModel(editorContent);
                        }
                    });
                });
            }

            /**
             * Wrap/unwrap the rubric block in a feedback according to the user selection
             * @param {Object} feedback
             * @returns {Boolean}
             */
            function updateFeedback(feedback) {
                var activated = feedback && feedback.activated;
                var wrapper = qtiElementHelper.lookupElement(rubricModel, 'rubricBlock.div.feedbackBlock', 'content');

                if (activated) {
                    // wrap the actual content into a feedbackBlock if needed
                    if (!wrapper) {
                        rubricModel.content = [qtiElementHelper.create('div', {
                            content: [qtiElementHelper.create('feedbackBlock', {
                                outcomeIdentifier: feedback.outcome,
                                identifier: feedback.matchValue,
                                content: rubricModel.content
                            })]
                        })];
                    } else {
                        wrapper.outcomeIdentifier = feedback.outcome;
                        wrapper.identifier = feedback.matchValue;
                    }
                    modelToEditor();
                } else {
                    // remove the feedbackBlock wrapper, just keep the actual content
                    if (wrapper) {
                        rubricModel.content = wrapper.content;
                        modelToEditor();
                    }
                }

                return activated;
            }

            /**
             * Perform some binding once the property view is created
             * @private
             * @param {propView} propView - the view object
             */
            function propHandler(propView) {
                var $view = propView.getView();
                var $feedbackOutcomeLine = $('.rubric-feedback-outcome', $view);
                var $feedbackMatchLine = $('.rubric-feedback-match-value', $view);
                var $feedbackOutcome = $('[name=feedback-outcome]', $view);
                var $feedbackActivated = $('[name=activated]', $view);

                // toggle the feedback panel
                function changeFeedback(activated) {
                    hider.toggle($feedbackOutcomeLine, activated);
                    hider.toggle($feedbackMatchLine, activated);
                }

                // should be called when the properties panel is removed
                function removePropHandler() {
                    rubricModel.feedback = {};
                    if (propView !== null) {
                        propView.destroy();
                    }
                }

                // take care of changes in the properties view
                function changeHandler(e, changedModel) {
                    if (e.namespace === 'binder' && changedModel['qti-type'] === 'rubricBlock') {
                        changeFeedback(updateFeedback(changedModel.feedback));
                    }
                }

                // update the list of outcomes the feedback can target
                function updateOutcomes() {
                    var activated = rubricModel.feedback && rubricModel.feedback.activated;
                    // build the list of outcomes in a way select2 can understand
                    var outcomes = _.map(modelOverseer.getOutcomesNames(), function(name) {
                        return {
                            id: name,
                            text: name
                        };
                    });

                    // create/update the select field
                    $feedbackOutcome.select2({
                        minimumResultsForSearch: -1,
                        width: '100%',
                        data: outcomes
                    });

                    // update the UI to reflect the data
                    if (!activated) {
                        $feedbackActivated.removeAttr('checked');
                    }
                    changeFeedback(activated);
                }

                $('[name=type]', $view).select2({
                    minimumResultsForSearch: -1,
                    width: '100%'
                });

                $view.on('change.binder', changeHandler);
                bindEvent($rubricBlock.parents('.testpart'), 'delete', removePropHandler);
                bindEvent($rubricBlock.parents('.section'), 'delete', removePropHandler);
                bindEvent($rubricBlock, 'delete', removePropHandler);
                bindEvent($rubricBlock, 'outcome-removed', function() {
                    $feedbackOutcome.val('');
                    updateOutcomes();
                });
                bindEvent($rubricBlock, 'outcome-updated', function() {
                    updateFeedback(rubricModel.feedback);
                    updateOutcomes();
                });

                changeFeedback(rubricModel.feedback);
                updateOutcomes();
                rbViews($view);
            }

            /**
             * Set up the views select box
             * @private
             * @param {jQueryElement} $propContainer - the element container
             */
            function rbViews($propContainer) {
                var $select = $('[name=view]', $propContainer);

                bindEvent($select.select2({'width': '100%'}), "select2-removed", function () {
                    if ($select.select2('val').length === 0) {
                        $select.select2('val', [1]);
                    }
                });

                if ($select.select2('val').length === 0) {
                    $select.select2('val', [1]);
                }
            }

            rubricModel.orderIndex = (rubricModel.index || 0) + 1;
            rubricModel.uid = _.uniqueId('rb');
            rubricModel.feedback = {
                activated: !!qtiElementHelper.lookupElement(rubricModel, 'rubricBlock.div.feedbackBlock', 'content'),
                outcome: qtiElementHelper.lookupProperty(rubricModel, 'rubricBlock.div.feedbackBlock.outcomeIdentifier', 'content'),
                matchValue: qtiElementHelper.lookupProperty(rubricModel, 'rubricBlock.div.feedbackBlock.identifier', 'content')
            };

            modelOverseer
                .before('scoring-write.' + rubricModel.uid, function() {
                    var feedbackOutcome = rubricModel.feedback && rubricModel.feedback.outcome;
                    if (feedbackOutcome && _.indexOf(modelOverseer.getOutcomesNames(), feedbackOutcome) < 0) {
                        // the targeted outcome has been removed, so remove the feedback
                        modelOverseer.changedRubricBlock = (modelOverseer.changedRubricBlock || 0) + 1;
                        rubricModel.feedback.activated = false;
                        rubricModel.feedback.outcome = '';
                        updateFeedback(rubricModel.feedback);
                        $rubricBlock.trigger('outcome-removed');
                    } else {
                        // the tageted outcome is still here, just notify the properties panel to update the list
                        $rubricBlock.trigger('outcome-updated');
                    }
                })
                .on('scoring-write.' + rubricModel.uid, function() {
                    // will notify the user of any removed feedbacks
                    if (modelOverseer.changedRubricBlock) {
                        /** @todo: provide a way to cancel changes */
                        dialogAlert(__('Some rubric blocks have been updated to reflect the changes in the list of outcomes.'));
                        modelOverseer.changedRubricBlock = 0;
                    }
                });

            actions.properties($rubricBlock, 'rubricblock', rubricModel, propHandler);

            modelToEditor();

            // destroy CK instance on rubric bloc deletion.
            // todo: find a way to destroy CK upon destroying rubric bloc parent section/part
            bindEvent($rubricBlock, 'delete', function() {
                qtiContentCreator.destroy(creatorContext, $rubricBlockContent);
            });

            $rubricBlockContent.on('editorfocus', function() {
                // close all properties forms and turn off their related button
                areaBroker.getPropertyPanelArea().children('.props').hide().trigger('propclose.propview');
            });

            //change position of CKeditor toolbar on scroll
            areaBroker.getContentCreatorPanelArea().find('.test-content').on('scroll', function () {
                CKEDITOR.document.getWindow().fire('scroll');
            });
        }
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2016 (original work) Open Assessment Technologies SA;
 */
define('taoQtiTest/controller/creator/helpers/sectionBlueprints',[
    'lodash',
    'i18n',
    'core/errorHandler'
], function (_, __, errorHandler){

    'use strict';

    var _ns = '.sectionBlueprint';


    /**
     * Set an array of categories to the section model (affect the childen itemRef)
     *
     * @param {object} model
     * @param {string} blueprint
     * @returns {undefined}
     */
    function setBlueprint(model, blueprint){
        model.blueprint = blueprint;
    }

    /**
     * Get the categories assign to the section model, infered by its interal itemRefs
     *
     * @param {string} getUrl
     * @param {object} model
     * @returns {object}
     */
    function getBlueprint(getUrl, model){

        return $.ajax({
            url: getUrl,
            type: 'GET',
            data: {
                section: model.identifier
            },
            dataType: 'json'

        })
        .fail(function () {
            errorHandler.throw(_ns, 'invalid tool config format');
        });

    }

    return {
        setBlueprint : setBlueprint,
        getBlueprint : getBlueprint
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/section',[
    'jquery',
    'lodash',
    'uri',
    'i18n',
    'taoQtiTest/controller/creator/views/actions',
    'taoQtiTest/controller/creator/views/itemref',
    'taoQtiTest/controller/creator/views/rubricblock',
    'taoQtiTest/controller/creator/templates/index',
    'taoQtiTest/controller/creator/helpers/qtiTest',
    'taoQtiTest/controller/creator/helpers/categorySelector',
    'taoQtiTest/controller/creator/helpers/sectionCategory',
    'taoQtiTest/controller/creator/helpers/sectionBlueprints'
],
function(
    $,
    _,
    uri,
    __,
    actions,
    itemRefView,
    rubricBlockView,
    templates,
    qtiTestHelper,
    categorySelectorFactory,
    sectionCategory,
    sectionBlueprint
){
    'use strict';

    /**
     * Set up a section: init action behaviors. Called for each section.
     *
     * @param {Object} creatorContext
     * @param {Object} sectionModel - the data model to bind to the test section
     * @param {Object} partModel - the parent data model to inherit
     * @param {jQueryElement} $section - the section to set up
     */
    function setUp (creatorContext, sectionModel, partModel, $section) {

        var $actionContainer = $('h2', $section);
        var modelOverseer = creatorContext.getModelOverseer();
        var config = modelOverseer.getConfig();

        // set item session control to use test part options if section level isn't set
        if (!sectionModel.itemSessionControl) {
            sectionModel.itemSessionControl = {};
        }
        _.defaults(sectionModel.itemSessionControl, partModel.itemSessionControl);

        if(!_.isEmpty(config.routes.blueprintsById)){
            sectionModel.hasBlueprint = true;
        }
        actions.properties($actionContainer, 'section', sectionModel, propHandler);
        actions.move($actionContainer, 'sections', 'section');
        itemRefs();
        acceptItemRefs();
        rubricBlocks();
        addRubricBlock();

        //trigger for the case the section is added an a selection is ongoing

        /**
         * Perform some binding once the property view is create
         * @param {propView} propView - the view object
         */
        function propHandler (propView) {

            var $title;
            var $view = propView.getView();

            //enable/disable selection
            var $selectionSwitcher = $('[name=section-enable-selection]', $view);
            var $selectionSelect = $('[name=section-select]', $view);
            var $selectionWithRep = $('[name=section-with-replacement]', $view);

            var switchSelection = function switchSelection(){
                if($selectionSwitcher.prop('checked') === true){
                    $selectionSelect.incrementer('enable');
                    $selectionWithRep.removeClass('disabled');
                } else {
                    $selectionSelect.incrementer('disable');
                    $selectionWithRep.addClass('disabled');
                }
            };
            $selectionSwitcher.on('change', switchSelection);
            $selectionSwitcher.on('change', function updateModel(){
                if(!$selectionSwitcher.prop('checked')){
                    $selectionSelect.val(0);
                    $selectionWithRep.prop('checked', false);
                    delete sectionModel.selection;
                }
            });

            $selectionSwitcher.prop('checked', !!sectionModel.selection).trigger('change');

            //listen for databinder change to update the test part title
            $title =  $('[data-bind=title]', $section);
            $view.on('change.binder', function(e){
                if(e.namespace === 'binder' && sectionModel['qti-type'] === 'assessmentSection'){
                    $title.text(sectionModel.title);
                }
            });

            $section.parents('.testpart').on('deleted.deleter', removePropHandler);
            $section.on('deleted.deleter', removePropHandler);

            //section level category configuration
            categoriesProperty($view);

            if(typeof sectionModel.hasBlueprint !== 'undefined'){
                blueprintProperty($view);
            }

            function removePropHandler(){
                if(propView !== null){
                    propView.destroy();
                }
            }
        }

        /**
         * Set up the item refs that already belongs to the section
         * @private
         */
        function itemRefs(){

            if(!sectionModel.sectionParts){
                sectionModel.sectionParts = [];
            }
            $('.itemref', $section).each(function(){
                var $itemRef = $(this);
                var index = $itemRef.data('bind-index');
                if(!sectionModel.sectionParts[index]){
                    sectionModel.sectionParts[index] = {};
                }

                itemRefView.setUp(creatorContext, sectionModel.sectionParts[index], sectionModel, partModel, $itemRef);
                $itemRef.find('.title').text(
                    config.labels[uri.encode($itemRef.data('uri'))]
                );
            });
        }

        /**
         * Make the section to accept the selected items
         * @private
         * @fires modelOverseer#item-add
         */
        function acceptItemRefs(){
            var $itemsPanel = $('.test-creator-items .item-selection');

            //the item selector trigger a select event
            $itemsPanel.on('itemselect.creator', function(e, selection){

                var $placeholder = $('.itemref-placeholder', $section);
                var $placeholders = $('.itemref-placeholder');

                if(_.size(selection) > 0){
                    $placeholder.show().off('click').on('click', function(){

                        //prepare the item data
                        var categories,
                            defaultItemData = {};

                        if(sectionModel.itemSessionControl && !_.isUndefined(sectionModel.itemSessionControl.maxAttempts)){

                            //for a matter of consistency, the itemRef will "inherit" the itemSessionControl configuration from its parent section
                            defaultItemData.itemSessionControl = _.clone(sectionModel.itemSessionControl);
                        }

                        //the itemRef should also "inherit" the categories set at the item level
                        categories = sectionCategory.getCategories(sectionModel);
                        defaultItemData.categories = _.clone(categories.propagated) || [];

                        _.forEach(selection, function(item){
                            var itemData = _.defaults({
                                href        : item.uri,
                                label       : item.label,
                                'qti-type'  : 'assessmentItemRef'
                            }, defaultItemData);

                            if(_.isArray(item.categories)){
                                itemData.categories = item.categories.concat(itemData.categories);
                            }

                            addItemRef($('.itemrefs', $section), null, itemData);
                        });

                        $itemsPanel.trigger('itemselected.creator');

                        $placeholders.hide().off('click');
                    });
                } else {
                    $placeholders.hide().off('click');
                }
            });


            //we listen the event not from the adder but  from the data binder to be sure the model is up to date
            $(document)
                .off('add.binder', '#' + $section.attr('id') + ' .itemrefs')
                .on('add.binder', '#' + $section.attr('id') + ' .itemrefs', function(e, $itemRef){
                    var index, itemRefModel;
                    if(e.namespace === 'binder' && $itemRef.hasClass('itemref')){
                        index = $itemRef.data('bind-index');
                        itemRefModel = sectionModel.sectionParts[index];

                        //initialize the new item ref
                        itemRefView.setUp(creatorContext, itemRefModel, sectionModel, partModel, $itemRef);

                        /**
                         * @event modelOverseer#item-add
                         * @param {Object} itemRefModel
                         */
                        modelOverseer.trigger('item-add', itemRefModel);
                    }
                });
        }

        /**
         * Add a new item ref to the section
         * @param {jQueryElement} $refList - the element to add the item to
         * @param {Number} [index] - the position of the item to add
         * @param {Object} [itemData] - the data to bind to the new item ref
         */
        function addItemRef($refList, index, itemData){
            var $itemRef;
            var $items = $refList.children('li');
            index = index || $items.length;
            itemData.identifier = qtiTestHelper.getAvailableIdentifier(modelOverseer.getModel(), 'assessmentItemRef', 'item');
            itemData.index = index + 1;
            $itemRef = $(templates.itemref(itemData));
            if(index > 0){
                $itemRef.insertAfter($items.eq(index - 1));
            } else {
                $itemRef.appendTo($refList);
            }
            $refList.trigger('add', [$itemRef, itemData]);
        }


        /**
         * Set up the rubric blocks that already belongs to the section
         * @private
         */
        function rubricBlocks () {
            if(!sectionModel.rubricBlocks){
                sectionModel.rubricBlocks = [];
            }
            $('.rubricblock', $section).each(function(){
                var $rubricBlock = $(this);
                var index = $rubricBlock.data('bind-index');
                if(!sectionModel.rubricBlocks[index]){
                    sectionModel.rubricBlocks[index] = {};
                }

                rubricBlockView.setUp(creatorContext, sectionModel.rubricBlocks[index], $rubricBlock);
            });

            //opens the rubric blocks section if they are there.
            if(sectionModel.rubricBlocks.length > 0){
                $('.rub-toggler', $section).trigger('click');
            }
        }

        /**
         * Enable to add new rubric block
         * @private
         * @fires modelOverseer#rubric-add
         */
        function addRubricBlock () {

            $('.rublock-adder', $section).adder({
                target: $('.rubricblocks', $section),
                content : templates.rubricblock,
                templateData : function(cb){
                    cb({
                        'qti-type' : 'rubricBlock',
                        index  : $('.rubricblock', $section).length,
                        content : [],
                        views : [1]
                    });
                }
            });

            //we listen the event not from the adder but  from the data binder to be sure the model is up to date
            $(document).on('add.binder', '#' + $section.attr('id') + ' .rubricblocks', function(e, $rubricBlock){
                var index, rubricModel;
                if(e.namespace === 'binder' && $rubricBlock.hasClass('rubricblock')){
                    index = $rubricBlock.data('bind-index');
                    rubricModel = sectionModel.rubricBlocks[index] || {};

                    $('.rubricblock-binding', $rubricBlock).html('<p>&nbsp;</p>');
                    rubricBlockView.setUp(creatorContext, rubricModel, $rubricBlock);

                    /**
                     * @event modelOverseer#rubric-add
                     * @param {Object} rubricModel
                     */
                    modelOverseer.trigger('rubric-add', rubricModel);
                }
            });
        }

        /**
         * Set up the category property
         * @private
         * @param {jQueryElement} $view - the $view object containing the $select
         * @fires modelOverseer#category-change
         */
        function categoriesProperty($view){
            var categories = sectionCategory.getCategories(sectionModel),
                categorySelector = categorySelectorFactory($view);

            categorySelector.createForm(categories.all);
            updateFormState(categorySelector);

            $view.on('propopen.propview', function(){
                updateFormState(categorySelector);
            });

            categorySelector.on('category-change', function(selected, indeterminate) {
                sectionCategory.setCategories(sectionModel, selected, indeterminate);

                modelOverseer.trigger('category-change');
            });
        }

        function updateFormState(categorySelector) {
            var categories = sectionCategory.getCategories(sectionModel);
            categorySelector.updateFormState(categories.propagated, categories.partial);
        }

        /**
         * Set up the Blueprint property
         * @private
         * @param {jQueryElement} $view - the $view object containing the $select
         */
        function blueprintProperty($view){
            var $select = $('[name=section-blueprint]', $view);
            $select.select2({
                ajax:{
                    url: config.routes.blueprintsById,
                    dataType: 'json',
                    delay: 350,
                    method: 'POST',
                    data: function (params) {
                        return {
                            identifier: params // search term
                        };
                    },
                    results: function (data) {
                        return data;
                    }
                },
                minimumInputLength: 3,
                width: '100%',
                multiple : false,
                allowClear: true,
                placeholder: __('Select a blueprint'),
                formatNoMatches : function(){
                    return __('Enter a blueprint');
                },
                maximumInputLength : 32
            }).on('change', function(e){
                setBlueprint(e.val);
            });

            initBlueprint();
            $view.on('propopen.propview', function(){
                initBlueprint();
            });

            /**
             * Start the blueprint editing
             * @private
             */
            function initBlueprint(){

                if(typeof sectionModel.blueprint === 'undefined'){
                    sectionBlueprint
                        .getBlueprint(config.routes.blueprintByTestSection, sectionModel)
                        .success(function(data){
                            if(!_.isEmpty(data)){
                                if(sectionModel.blueprint !== ""){
                                    sectionModel.blueprint = data.uri;
                                    $select.select2('data', {id: data.uri, text: data.text});
                                    $select.trigger('change');
                                }
                            }
                        });
                }
            }

            /**
             * save the categories into the model
             * @private
             */
            function setBlueprint(blueprint){
                sectionBlueprint.setBlueprint(sectionModel, blueprint);
            }

        }
    }

    /**
     * Listen for state changes to enable/disable . Called globally.
     */
    function listenActionState (){

        var $sections;

        $('.sections').each(function(){
            $sections = $('.section', $(this));

            actions.removable($sections, 'h2');
            actions.movable($sections, 'section', 'h2');
        });

        $(document)
            .on('delete', function(e){
                var $parent;
                var $target = $(e.target);
                if($target.hasClass('section')){
                    $parent = $target.parents('.sections');
                    actions.disable($parent.find('.section'), 'h2');
                }
            })
            .on('add change undo.deleter deleted.deleter', function(e){
                var $target = $(e.target);
                if($target.hasClass('section') || $target.hasClass('sections')){
                    $sections = $('.section', $target.hasClass('sections') ? $target : $target.parents('.sections'));
                    actions.removable($sections, 'h2');
                    actions.movable($sections, 'section', 'h2');
                }
            })
            .on('open.toggler', '.rub-toggler', function(e){
                if(e.namespace === 'toggler'){
                    $(this).parents('h2').addClass('active');
                }
            })
            .on('close.toggler', '.rub-toggler', function(e){
                if(e.namespace === 'toggler'){
                    $(this).parents('h2').removeClass('active');
                }
            });
    }

    /**
     * The sectionView setup section related components and beahvior
     *
     * @exports taoQtiTest/controller/creator/views/section
     */
    return {
        setUp : setUp,
        listenActionState: listenActionState
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */

/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/testpart',[
    'jquery', 'lodash',
    'taoQtiTest/controller/creator/views/actions',
    'taoQtiTest/controller/creator/views/section',
    'taoQtiTest/controller/creator/templates/index',
    'taoQtiTest/controller/creator/helpers/qtiTest'],
function($, _, actions, sectionView, templates, qtiTestHelper){
    'use strict';

    /**
     * Set up a test part: init action behaviors. Called for each test part.
     *
     * @param {Object} creatorContext
     * @param {Object} partModel - the data model to bind to the test part
     * @param {jQueryElement} $testPart - the testpart container to set up
     */
    function setUp (creatorContext, partModel, $testPart){
        var $actionContainer = $('h1', $testPart);
        var modelOverseer = creatorContext.getModelOverseer();
        var config = modelOverseer.getConfig();

        //run setup methods
        actions.properties($actionContainer, 'testpart', partModel, propHandler);
        actions.move($actionContainer, 'testparts', 'testpart');
        sections();
        addSection();

        /**
         * Perform some binding once the property view is created
         * @private
         * @param {propView} propView - the view object
         */
        function propHandler (propView) {

            var $view = propView.getView();

            //listen for databinder change to update the test part title
            var $identifier =  $('[data-bind=identifier]', $testPart);
            $view.on('change.binder', function(e, model){
                if(e.namespace === 'binder' && model['qti-type'] === 'testPart'){
                    $identifier.text(model.identifier);

                    /**
                     * @event modelOverseer#section-add
                     * @param {Object} sectionModel
                     */
                    modelOverseer.trigger('testpart-change', partModel);

                }
            });

            //destroy it when it's testpart is removed
            $testPart.on('delete', function(){
                if(propView !== null){
                    propView.destroy();
                }
            });
        }

        /**
         * Set up sections that already belongs to the test part
         * @private
         */
        function sections(){
            if(!partModel.assessmentSections){
                partModel.assessmentSections = [];
            }
            $('.section', $testPart).each(function(){
                var $section = $(this);
                var index = $section.data('bind-index');
                if(!partModel.assessmentSections[index]){
                    partModel.assessmentSections[index] = {};
                }

                sectionView.setUp(creatorContext, partModel.assessmentSections[index], partModel, $section);
            });
        }

        /**
         * Enable to add new sections
         * @private
         * @fires modelOverseer#section-add
         */
        function addSection(){
            $('.section-adder', $testPart).adder({
                target: $('.sections', $testPart),
                content : templates.section,
                templateData : function(cb){

                    //create a new section model object to be bound to the template
                    var sectionIndex = $('.section', $testPart).length;
                    cb({
                        'qti-type' : 'assessmentSection',
                        identifier : qtiTestHelper.getAvailableIdentifier(modelOverseer.getModel(), 'assessmentSection'),
                        title : 'Section ' + (sectionIndex + 1),
                        index : 0,
                        sectionParts : []
                    });
                }
            });



            //we listen the event not from the adder but  from the data binder to be sure the model is up to date
            $(document)
                .off('add.binder', '#' + $testPart.attr('id') + ' .sections')
                .on ('add.binder', '#' + $testPart.attr('id') + ' .sections', function(e, $section){
                    var index, sectionModel;
                    if(e.namespace === 'binder' && $section.hasClass('section')){
                        index = $section.data('bind-index');
                        sectionModel = partModel.assessmentSections[index];

                        //initialize the new test part
                        sectionView.setUp(creatorContext, sectionModel, partModel, $section);

                        /**
                         * @event modelOverseer#section-add
                         * @param {Object} sectionModel
                         */
                        modelOverseer.trigger('section-add', sectionModel);
                    }
                });
        }
    }

    /**
     * Listen for state changes to enable/disable . Called globally.
     */
    function listenActionState (){

        var $testParts = $('.testpart');

        actions.removable($testParts, 'h1');
        actions.movable($testParts, 'testpart', 'h1');

        $('.testparts')
            .on('delete', function(e){
                var $target = $(e.target);
                if($target.hasClass('testpart')){
                    actions.disable($('.testpart'), 'h1');
                }
            })
            .on('add change undo.deleter deleted.deleter', function(e){
                var $target = $(e.target);

                if($target.hasClass('testpart') || $target.hasClass('testparts')){

                    //refresh
                    $testParts = $('.testpart');

                    //check state
                    actions.removable($testParts, 'h1');
                    actions.movable($testParts, 'testpart', 'h1');
                }
            });
    }

    /**
     * The testPartView setup testpart related components and beahvior
     *
     * @exports taoQtiTest/controller/creator/views/testpart
     */
    return {
        setUp : setUp,
        listenActionState: listenActionState
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/views/test',[
    'jquery', 'lodash', 'i18n', 'ui/hider', 'ui/feedback',
    'taoQtiTest/controller/creator/views/actions',
    'taoQtiTest/controller/creator/views/testpart',
    'taoQtiTest/controller/creator/templates/index',
    'taoQtiTest/controller/creator/helpers/qtiTest'
],
function($, _, __, hider, feedback, actions, testPartView, templates, qtiTestHelper){
    'use strict';

    /**
     * The TestView setup test related components and behavior
     *
     * @exports taoQtiTest/controller/creator/views/test
     * @param {Object} creatorContext
     */
    function testView (creatorContext) {
        var modelOverseer = creatorContext.getModelOverseer();
        var testModel = modelOverseer.getModel();

        actions.properties($('.test-creator-test > h1'), 'test', testModel, propHandler);
        testParts();
        addTestPart();

        /**
         * set up the existing test part views
         * @private
         */
        function testParts () {
            if(!testModel.testParts){
                testModel.testParts = [];
            }
            $('.testpart').each(function(){
                var $testPart = $(this);
                var index = $testPart.data('bind-index');
                if(!testModel.testParts[index]){
                    testModel.testParts[index] = {};
                }

                testPartView.setUp(creatorContext, testModel.testParts[index], $testPart);
            });
        }

        /**
         * Perform some binding once the property view is created
         * @private
         * @param {propView} propView - the view object
         * @fires modelOverseer#scoring-change
         */
        function propHandler(propView) {

            var $view = propView.getView();
            var $categoryScoreLine = $('.test-category-score', $view);
            var $cutScoreLine = $('.test-cut-score', $view);
            var $weightIdentifierLine = $('.test-weight-identifier', $view);
            var $descriptions = $('.test-outcome-processing-description', $view);
            var $generate = $('[data-action="generate-outcomes"]', $view);
            var $title = $('.test-creator-test > h1 [data-bind=title]');
            var scoringState = JSON.stringify(testModel.scoring);

            function changeScoring(scoring) {
                var noOptions = !!scoring && ['none', 'custom'].indexOf(scoring.outcomeProcessing) === -1;
                var newScoringState = JSON.stringify(scoring);

                hider.toggle($cutScoreLine, !!scoring && scoring.outcomeProcessing === 'cut');
                hider.toggle($categoryScoreLine, noOptions);
                hider.toggle($weightIdentifierLine, noOptions);
                hider.hide($descriptions);
                hider.show($descriptions.filter('[data-key="' + scoring.outcomeProcessing + '"]'));

                if (scoringState !== newScoringState) {
                    /**
                     * @event modelOverseer#scoring-change
                     * @param {Object} testModel
                     */
                    modelOverseer.trigger('scoring-change', testModel);
                }
                scoringState = newScoringState;
            }

            function updateOutcomes() {
                var $panel = $('.outcome-declarations', $view);

                $panel.html(templates.outcomes(modelOverseer.getOutcomesList()));
            }

            $('[name=test-outcome-processing]', $view).select2({
                minimumResultsForSearch: -1,
                width: '100%'
            });

            $generate.on('click', function() {
                $generate.addClass('disabled').attr('disabled', true);
                modelOverseer
                    .on('scoring-write.regenerate', function() {
                        modelOverseer.off('scoring-write.regenerate');
                        feedback().success(__('The outcomes have been regenerated!')).on('destroy', function() {
                            $generate.removeClass('disabled').removeAttr('disabled');
                        });
                    })
                    .trigger('scoring-change');
            });

            $view.on('change.binder', function (e, model) {
                if (e.namespace === 'binder' && model['qti-type'] === 'assessmentTest') {
                    changeScoring(model.scoring);

                    //update the test part title when the databinder has changed it
                    $title.text(model.title);
                }
            });

            modelOverseer.on('scoring-write', updateOutcomes);

            changeScoring(testModel.scoring);
            updateOutcomes();
        }

        /**
         * Enable to add new test parts
         * @private
         * @fires modelOverseer#part-add
         */
        function addTestPart () {

            $('.testpart-adder').adder({
                target: $('.testparts'),
                content : templates.testpart,
                templateData : function(cb){

                    //create an new testPart model object to be bound to the template
                    var testPartIndex = $('.testpart').length;
                    cb({
                        'qti-type' : 'testPart',
                        identifier : qtiTestHelper.getAvailableIdentifier(modelOverseer.getModel(), 'testPart'),
                        index  : testPartIndex,
                        navigationMode : 0,
                        submissionMode : 0,
                        assessmentSections : [{
                            'qti-type' : 'assessmentSection',
                            identifier : qtiTestHelper.getAvailableIdentifier(modelOverseer.getModel(), 'assessmentSection', 'section'),
                            title : 'Section 1',
                            index : 0,
                            sectionParts : []
                        }]
                    });
                }
            });

            //we listen the event not from the adder but  from the data binder to be sure the model is up to date
            $(document)
                .off('add.binder', '.testparts')
                .on ('add.binder', '.testparts', function(e, $testPart, added){
                    var partModel;
                    if(e.namespace === 'binder' && $testPart.hasClass('testpart')){
                        partModel = testModel.testParts[added.index];

                        //initialize the new test part
                        testPartView.setUp(creatorContext, partModel, $testPart);

                        /**
                         * @event modelOverseer#part-add
                         * @param {Object} partModel
                         */
                        modelOverseer.trigger('part-add', partModel);
                    }
                });
        }
    }

    return testView;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * Basic helper that is intended to generate outcomes processing rules for a test model.
 *
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/processingRule',[
    'lodash',
    'taoQtiTest/controller/creator/helpers/outcomeValidator',
    'taoQtiTest/controller/creator/helpers/qtiElement',
    'taoQtiTest/controller/creator/helpers/baseType',
    'taoQtiTest/controller/creator/helpers/cardinality'
], function (_, outcomeValidator, qtiElementHelper, baseTypeHelper, cardinalityHelper) {
    'use strict';

    var processingRuleHelper = {
        /**
         * Creates a basic processing rule
         * @param {String} type
         * @param {String} [identifier]
         * @param {Array|Object} [expression]
         * @returns {Object}
         * @throws {TypeError} if the type is empty or is not a string
         * @throws {TypeError} if the identifier is not valid
         * @throws {TypeError} if the expression does not contain valid QTI elements
         */
        create: function create(type, identifier, expression) {
            var processingRule = qtiElementHelper.create(type, identifier && validateIdentifier(identifier));

            if (expression) {
                processingRuleHelper.setExpression(processingRule, expression);
            }

            return processingRule;
        },

        /**
         * Sets an expression to a processing rule
         * @param {Object} processingRule
         * @param {Object|Array} expression
         * @throws {TypeError} if the expression does not contain valid QTI elements
         */
        setExpression: function setExpression(processingRule, expression) {
            if (processingRule) {
                if (_.isArray(expression)) {
                    if (processingRule.expression) {
                        processingRule.expression = null;
                    }
                    processingRule.expressions = validateOutcomeList(expression);
                } else {
                    if (processingRule.expressions) {
                        processingRule.expressions = null;
                    }
                    if (expression) {
                        processingRule.expression = validateOutcome(expression);
                    }
                }
            }
        },

        /**
         * Adds an expression to a processing rule
         * @param {Object} processingRule
         * @param {Object|Array} expression
         * @throws {TypeError} if the expression does not contain valid QTI elements
         */
        addExpression: function addExpression(processingRule, expression) {
            if (processingRule && expression) {
                if (processingRule.expression) {
                    processingRule.expressions = forceArray(processingRule.expression);
                    processingRule.expression = null;
                }

                if (_.isArray(expression)) {
                    processingRule.expressions = forceArray(processingRule.expressions).concat(validateOutcomeList(expression));
                } else {
                    if (processingRule.expressions) {
                        processingRule.expressions.push(expression);
                    } else {
                        processingRule.expression = validateOutcome(expression);
                    }
                }
            }
        },

        /**
         * Creates a `setOutcomeValue` rule
         * @param {String} identifier
         * @param {Object|Array} [expression]
         * @returns {Object}
         * @throws {TypeError} if the identifier is empty or is not a string
         * @throws {TypeError} if the expression does not contain valid QTI elements
         */
        setOutcomeValue: function setOutcomeValue(identifier, expression) {
            return processingRuleHelper.create('setOutcomeValue',  validateIdentifier(identifier), expression);
        },

        /**
         * Creates a `gte` rule
         * @param {Object|Array} left - the left operand
         * @param {Object|Array} right - the right operand
         * @returns {Object}
         * @throws {TypeError} if the left and right operands are not valid QTI elements
         */
        gte: function gte(left, right) {
            return binaryOperator('gte', left, right);
        },

        /**
         * Creates a `lte` rule
         * @param {Object|Array} left - the left operand
         * @param {Object|Array} right - the right operand
         * @returns {Object}
         * @throws {TypeError} if the left and right operands are not valid QTI elements
         */
        lte: function lte(left, right) {
            return binaryOperator('lte', left, right);
        },

        /**
         * Creates a `divide` rule
         * @param {Object|Array} left - the left operand
         * @param {Object|Array} right - the right operand
         * @returns {Object}
         * @throws {TypeError} if the left and right operands are not valid QTI elements
         */
        divide: function divide(left, right) {
            return binaryOperator('divide', left, right);
        },

        /**
         * Creates a `sum` rule
         * @param {Object|Array} terms
         * @returns {Object}
         * @throws {TypeError} if the terms are not valid QTI elements
         */
        sum: function sum(terms) {
            var processingRule = processingRuleHelper.create('sum', null, forceArray(terms));

            processingRule.minOperands = 1;
            processingRule.maxOperands = -1;
            processingRule.acceptedCardinalities = [cardinalityHelper.SINGLE, cardinalityHelper.MULTIPLE, cardinalityHelper.ORDERED];
            processingRule.acceptedBaseTypes = [baseTypeHelper.INTEGER, baseTypeHelper.FLOAT];

            return processingRule;
        },

        /**
         * Creates a `testVariables` rule
         * @param {String} identifier
         * @param {String|Number} [type]
         * @param {String} weightIdentifier
         * @param {String|String[]} [includeCategories]
         * @param {String|String[]} [excludeCategories]
         * @returns {Object}
         * @throws {TypeError} if the identifier is empty or is not a string
         */
        testVariables: function testVariables(identifier, type, weightIdentifier, includeCategories, excludeCategories) {
            var processingRule = processingRuleHelper.create('testVariables');

            processingRule.variableIdentifier = validateIdentifier(identifier);
            processingRule.baseType = baseTypeHelper.getValid(type);
            addWeightIdentifier(processingRule, weightIdentifier);
            addSectionIdentifier(processingRule, '');
            addCategories(processingRule, includeCategories, excludeCategories);

            return processingRule;
        },

        /**
         * Creates a `outcomeMaximum` rule
         * @param {String} identifier
         * @param {String} weightIdentifier
         * @param {String|String[]} [includeCategories]
         * @param {String|String[]} [excludeCategories]
         * @returns {Object}
         * @throws {TypeError} if the identifier is empty or is not a string
         */
        outcomeMaximum: function outcomeMaximum(identifier, weightIdentifier, includeCategories, excludeCategories) {
            var processingRule = processingRuleHelper.create('outcomeMaximum');

            processingRule.outcomeIdentifier = validateIdentifier(identifier);

            addWeightIdentifier(processingRule, weightIdentifier);
            addSectionIdentifier(processingRule, '');
            addCategories(processingRule, includeCategories, excludeCategories);

            return processingRule;
        },

        /**
         * Creates a `numberPresented` rule
         * @param {String|String[]} [includeCategories]
         * @param {String|String[]} [excludeCategories]
         * @returns {Object}
         */
        numberPresented: function numberPresented(includeCategories, excludeCategories) {
            var processingRule = processingRuleHelper.create('numberPresented');

            addSectionIdentifier(processingRule, '');
            addCategories(processingRule, includeCategories, excludeCategories);

            return processingRule;
        },

        /**
         * Creates a `baseValue` rule
         * @param {*} [value]
         * @param {String|Number} [type]
         * @returns {Object}
         */
        baseValue: function baseValue(value, type) {
            var processingRule = processingRuleHelper.create('baseValue');

            processingRule.baseType = baseTypeHelper.getValid(type, baseTypeHelper.FLOAT);
            processingRule.value = baseTypeHelper.getValue(processingRule.baseType, value);

            return processingRule;
        },

        /**
         ** Creates a `variable` rule
         * @param {String} identifier
         * @param {String} [weightIdentifier]
         * @returns {Object}
         * @throws {TypeError} if the identifier is not valid
         * @throws {TypeError} if the weight identifier is not valid
         */
        variable: function variable(identifier, weightIdentifier) {
            var processingRule = processingRuleHelper.create('variable', validateIdentifier(identifier));

            addWeightIdentifier(processingRule, weightIdentifier);

            return processingRule;
        },

        /**
         * Creates a `match` rule
         * @param {Object|Array} left - the left operand
         * @param {Object|Array} right - the right operand
         * @returns {Object}
         * @throws {TypeError} if the left and right operands are not valid QTI elements
         */
        match: function match(left, right) {
            return binaryOperator('match', left, right, cardinalityHelper.SAME, cardinalityHelper.SAME);
        },

        /**
         * Creates a `isNull` rule
         * @param {Object|Array} expression - the operand
         * @returns {Object}
         * @throws {TypeError} if the operand is not valid QTI element
         */
        isNull: function isNull(expression) {
            return unaryOperator('isNull', expression, baseTypeHelper.ANY, cardinalityHelper.ANY);
        },

        /**
         * Creates a `outcomeCondition` rule
         * @param {Object} outcomeIf
         * @param {Object} outcomeElse
         * @returns {Object}
         * @throws {TypeError} if the outcomeIf and outcomeElse operands are not valid QTI elements
         */
        outcomeCondition: function outcomeCondition(outcomeIf, outcomeElse) {
            var processingRule = processingRuleHelper.create('outcomeCondition');

            if (!outcomeValidator.validateOutcome(outcomeIf, false, 'outcomeIf')) {
                throw new TypeError('You must provide a valid outcomeIf element!');
            }

            if (outcomeElse && !outcomeValidator.validateOutcome(outcomeElse, false, 'outcomeElse')) {
                throw new TypeError('You must provide a valid outcomeElse element!');
            }

            processingRule.outcomeIf = outcomeIf;
            processingRule.outcomeElseIfs = [];

            if (outcomeElse) {
                processingRule.outcomeElse = outcomeElse;
            }

            return processingRule;
        },

        /**
         * Creates a `outcomeIf` rule
         * @param {Object} expression
         * @param {Object|Object[]} instruction
         * @returns {Object}
         * @throws {TypeError} if the expression and instruction operands are not valid QTI elements
         */
        outcomeIf: function outcomeIf(expression, instruction) {
            var processingRule = processingRuleHelper.create('outcomeIf');

            if (!_.isArray(instruction)) {
                instruction = [instruction];
            }

            processingRule.expression = validateOutcome(expression);
            processingRule.outcomeRules = validateOutcomeList(instruction);

            return processingRule;
        },

        /**
         * Creates a `outcomeElse` rule
         * @param {Object|Object[]} instruction
         * @returns {Object}
         * @throws {TypeError} if the instruction is not a valid QTI element
         */
        outcomeElse: function outcomeElse(instruction) {
            var processingRule = processingRuleHelper.create('outcomeElse');

            if (!_.isArray(instruction)) {
                instruction = [instruction];
            }

            processingRule.outcomeRules = validateOutcomeList(instruction);

            return processingRule;
        }

    };

    /**
     * Creates a unary operator rule
     * @param {String} type - The rule type
     * @param {Object|Array} expression - The operand
     * @param {Number|Array} [baseType] - The accepted base type
     * @param {Number|Array} [cardinality] - The accepted cardinality
     * @returns {Object}
     * @throws {TypeError} if the type is empty or is not a string
     * @throws {TypeError} if the operand is not valid QTI element
     */
    function unaryOperator(type, expression, baseType, cardinality) {
        var processingRule = processingRuleHelper.create(type, null, [expression]);

        processingRule.minOperands = 1;
        processingRule.maxOperands = 1;

        addTypeAndCardinality(processingRule, baseType, cardinality);

        return processingRule;
    }

    /**
     * Creates a binary operator rule
     * @param {String} type - The rule type
     * @param {Object|Array} left - The left operand
     * @param {Object|Array} right - The right operand
     * @param {Number|Array} [baseType] - The accepted base type
     * @param {Number|Array} [cardinality] - The accepted cardinality
     * @returns {Object}
     * @throws {TypeError} if the type is empty or is not a string
     * @throws {TypeError} if the left and right operands are not valid QTI elements
     */
    function binaryOperator(type, left, right, baseType, cardinality) {
        var processingRule = processingRuleHelper.create(type, null, [left, right]);

        processingRule.minOperands = 2;
        processingRule.maxOperands = 2;

        addTypeAndCardinality(processingRule, baseType, cardinality);

        return processingRule;
    }

    /**
     * Appends the base type and the cardinality on a processing rule
     * @param {Object} processingRule
     * @param {Number|Array} [baseType] - The accepted base type
     * @param {Number|Array} [cardinality] - The accepted cardinality
     * @returns {Object}
     */
    function addTypeAndCardinality(processingRule, baseType, cardinality) {
        if (_.isUndefined(baseType)) {
            baseType = [baseTypeHelper.INTEGER, baseTypeHelper.FLOAT];
        }

        if (_.isUndefined(cardinality)) {
            cardinality = [cardinalityHelper.SINGLE];
        }

        processingRule.acceptedCardinalities = forceArray(cardinality);
        processingRule.acceptedBaseTypes = forceArray(baseType);

        return processingRule;
    }

    /**
     * Extends a processing rule with categories
     * @param {Object} processingRule
     * @param {Array|String} [includeCategories]
     * @param {Array|String} [excludeCategories]
     * @returns {Object}
     */
    function addCategories(processingRule, includeCategories, excludeCategories) {
        processingRule.includeCategories = forceArray(includeCategories);
        processingRule.excludeCategories = forceArray(excludeCategories);

        return processingRule;
    }

    /**
     * Appends the section identifier on a processing rule
     * @param {Object} processingRule
     * @param {String} [sectionIdentifier]
     * @returns {Object}
     * @throws {TypeError} if the weight identifier is not valid
     */
    function addSectionIdentifier(processingRule, sectionIdentifier) {
        if (sectionIdentifier) {
            if (!outcomeValidator.validateIdentifier(sectionIdentifier)) {
                throw new TypeError('You must provide a valid weight identifier!');
            }
            processingRule.sectionIdentifier = sectionIdentifier;
        } else {
            processingRule.sectionIdentifier = '';
        }

        return processingRule;
    }

    /**
     * Appends the weight identifier on a processing rule
     * @param {Object} processingRule
     * @param {String} [weightIdentifier]
     * @returns {Object}
     * @throws {TypeError} if the weight identifier is not valid
     */
    function addWeightIdentifier(processingRule, weightIdentifier) {
        if (weightIdentifier) {
            if (!outcomeValidator.validateIdentifier(weightIdentifier)) {
                throw new TypeError('You must provide a valid weight identifier!');
            }
            processingRule.weightIdentifier = weightIdentifier;
        } else {
            processingRule.weightIdentifier = '';
        }

        return processingRule;
    }

    /**
     * Validates an identifier
     * @param {String} identifier
     * @returns {String}
     * @throws {TypeError} if the identifier is not valid
     */
    function validateIdentifier(identifier) {
        if (!outcomeValidator.validateIdentifier(identifier)) {
            throw new TypeError('You must provide a valid identifier!');
        }
        return identifier;
    }

    /**
     * Validates an outcome
     * @param {Object} outcome
     * @returns {Object}
     * @throws {TypeError} if the outcome is not valid
     */
    function validateOutcome(outcome) {
        if (!outcomeValidator.validateOutcome(outcome)) {
            throw new TypeError('You must provide a valid QTI element!');
        }
        return outcome;
    }

    /**
     * Validates a list of outcomes
     * @param {Array} outcomes
     * @returns {Array}
     * @throws {TypeError} if an outcome is not valid
     */
    function validateOutcomeList(outcomes) {
        if (!outcomeValidator.validateOutcomes(outcomes)) {
            throw new TypeError('You must provide a valid list of QTI elements!');
        }
        return outcomes;
    }

    /**
     * Ensures a value is an array
     * @param {*} value
     * @returns {Array}
     */
    function forceArray(value) {
        if (!value) {
            value = [];
        }
        if (!_.isArray(value)) {
            value = [value];
        }
        return value;
    }

    return processingRuleHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;
 */
/**
 * Basic helper that is intended to manage the score processing declaration in a test model.
 *
 * @author Jean-Sébastien Conan <jean-sebastien@taotesting.com>
 */
define('taoQtiTest/controller/creator/helpers/scoring',[
    'lodash',
    'i18n',
    'core/format',
    'taoQtiTest/controller/creator/helpers/baseType',
    'taoQtiTest/controller/creator/helpers/outcome',
    'taoQtiTest/controller/creator/helpers/processingRule'
], function (_, __, format, baseTypeHelper, outcomeHelper, processingRuleHelper) {
    'use strict';

    /**
     * The default cut score
     * @todo Move this to a config file
     * @type {Number}
     */
    var defaultCutScore = 0.5;

    /**
     * The name of the variable containing the score
     * @type {String}
     */
    var defaultScoreIdentifier = 'SCORE';

    /**
     * The list of supported processing modes, indexed by mode identifier
     * @type {Object}
     */
    var processingModes = {
        none: {
            key: 'none',
            label: __('None'),
            description: __('No outcome processing. Erase the existing rules, if any.')
        },
        custom: {
            key: 'custom',
            label: __('Custom'),
            description: __('Custom outcome processing. No changes will be made to the existing rules.')
        },
        total: {
            key: 'total',
            label: __('Total score'),
            description: __('The score will be processed for the entire test. A sum of all SCORE outcomes will be computed, the result will take place in the SCORE_TOTAL outcome.')
                         + ' ' +
                         __('If the category option is set, the score will also be processed per categories, and each results will take place in the SCORE_xxx outcome, where xxx is the name of the category.')
        },
        cut: {
            key: 'cut',
            label: __('Cut score'),
            description: __('The score will be processed for the entire test. A sum of all SCORE outcomes will be computed and divided by the sum of MAX SCORE, the result will be compared to the cut score (or pass ratio), then the PASS_TOTAL outcome will be set accordingly.')
                         + ' ' +
                         __('If the category option is set, the score will also be processed per categories, and each results will take place in the PASS_xxx outcome, where xxx is the name of the category.')
        }
    };

    /**
     * The list of recipes to generate the outcomes
     * @type {Object}
     */
    var outcomesRecipes = {
        none: {
            key: 'none',
            clean: true
        },
        custom: {
            key: 'custom',
            clean: false
        },
        total: {
            key: 'total',
            signature: /^SCORE_([a-zA-Z][a-zA-Z0-9_\.-]*)$/,
            outcomes: [{
                writer: 'total',
                identifier: 'SCORE_TOTAL',
                weighted: 'SCORE_TOTAL_WEIGHTED',
                categoryIdentifier: 'SCORE_CATEGORY_%s',
                categoryWeighted: 'SCORE_CATEGORY_WEIGHTED_%s'
            }, {
                writer: 'max',
                identifier: 'SCORE_TOTAL_MAX',
                weighted: 'SCORE_TOTAL_MAX_WEIGHTED',
                categoryIdentifier: 'SCORE_CATEGORY_MAX_%s',
                categoryWeighted: 'SCORE_CATEGORY_WEIGHTED_MAX_%s'
            }, {
                writer: 'ratio',
                identifier: 'SCORE_RATIO',
                weighted: 'SCORE_RATIO_WEIGHTED',
                scoreIdentifier: {
                    total : 'SCORE_TOTAL',
                    max : 'SCORE_TOTAL_MAX'
                },
                scoreWeighted : {
                    total : 'SCORE_TOTAL_WEIGHTED',
                    max : 'SCORE_TOTAL_MAX_WEIGHTED',
                },
            }],
            clean: true
        },
        cut: {
            key: 'cut',
            include: 'total',
            signature: /^PASS_([a-zA-Z][a-zA-Z0-9_\.-]*)$/,
            outcomes: [{
                writer: 'cut',
                identifier: 'PASS_ALL',
                feedback: 'PASS_ALL_RENDERING',
                feedbackOk: "passed",
                feedbackFailed: "not_passed",
                categoryIdentifier: 'PASS_CATEGORY_%s',
                categoryFeedback: 'PASS_CATEGORY_%s_RENDERING'
            }],
            clean: true
        }
    };

    /**
     * List of writers that provide the outcomes for each score processing mode.
     * @type {Object}
     */
    var outcomesWriters = {
        /**
         * Generates the outcomes that compute the "Score ratio"
         * @param {Object} descriptor
         * @param {Object} scoring
         * @param {Object} outcomes
         */
        ratio : function writerRatio(descriptor, scoring, outcomes){
            addRatioOutcomes(outcomes, descriptor.identifier, descriptor.scoreIdentifier.total, descriptor.scoreIdentifier.max);
            if(scoring.weightIdentifier){
                //add weighted ratio outcome only when the scoring outcome processing rule uses a weight
                addRatioOutcomes(outcomes, descriptor.weighted, descriptor.scoreWeighted.total, descriptor.scoreWeighted.max);
            }
        },

        /**
         * Generates the outcomes that compute the "Total score"
         * @param {Object} descriptor
         * @param {Object} scoring
         * @param {Object} outcomes
         * @param {Array} [categories]
         */
        total: function writerTotal(descriptor, scoring, outcomes, categories) {
            // create the outcome and the rule that process the overall score
            addTotalScoreOutcomes(outcomes, scoring, descriptor.identifier, false);
            if (descriptor.weighted && scoring.weightIdentifier) {
                addTotalScoreOutcomes(outcomes, scoring, descriptor.weighted, true);
            }

            // create an outcome per categories
            if (descriptor.categoryIdentifier && categories) {
                _.forEach(categories, function (category) {
                    addTotalScoreOutcomes(outcomes, scoring, formatCategoryOutcome(category, descriptor.categoryIdentifier), false, category);
                    if (descriptor.categoryWeighted && scoring.weightIdentifier) {
                        addTotalScoreOutcomes(outcomes, scoring, formatCategoryOutcome(category, descriptor.categoryWeighted), true, category);
                    }
                });
            }
        },

        /**
         * Generates the outcomes that compute the "Max score"
         * @param {Object} descriptor
         * @param {Object} scoring
         * @param {Object} outcomes
         * @param {Array} [categories]
         */
        max: function writerMax(descriptor, scoring, outcomes, categories) {
            // create the outcome and the rule that process the maximum overall score
            addMaxScoreOutcomes(outcomes, scoring, descriptor.identifier, false);
            if (descriptor.weighted && scoring.weightIdentifier) {
                addMaxScoreOutcomes(outcomes, scoring, descriptor.weighted, true);
            }

            // create an outcome per categories
            if (descriptor.categoryIdentifier && categories) {
                _.forEach(categories, function (category) {
                    addMaxScoreOutcomes(outcomes, scoring, formatCategoryOutcome(category, descriptor.categoryIdentifier), false, category);
                    if (descriptor.categoryWeighted && scoring.weightIdentifier) {
                        addMaxScoreOutcomes(outcomes, scoring, formatCategoryOutcome(category, descriptor.categoryWeighted), true, category);
                    }
                });
            }
        },

        /**
         * Generates the outcomes that compute the "Cut score"
         * @param {Object} descriptor
         * @param {Object} scoring
         * @param {Object} outcomes
         * @param {Array} [categories]
         */
        cut: function writerCut(descriptor, scoring, outcomes, categories) {
            var cutScore = scoring.cutScore;
            var totalModeOutcomes = outcomesRecipes.total.outcomes;
            var total = _.find(totalModeOutcomes, {writer: 'total'});
            var max = _.find(totalModeOutcomes, {writer: 'max'});
            var ratio = _.find(totalModeOutcomes, {writer: 'ratio'});
            var whichOutcome = scoring.weightIdentifier ? 'weighted' : 'identifier';
            var ratioIdentifier = ratio[whichOutcome];

            // create the outcome and the rule that process the overall score
            addGlobalCutScoreOutcomes(outcomes, descriptor.identifier, ratioIdentifier, cutScore);

            // create the outcome and the rule that process the score feedback
            if (descriptor.feedback) {
                addFeedbackScoreOutcomes(
                    outcomes,
                    descriptor.feedback,
                    descriptor.identifier,
                    descriptor.feedbackOk,
                    descriptor.feedbackFailed
                );
            }

            // create an outcome per category
            if (descriptor.categoryIdentifier && categories) {
                _.forEach(categories, function (category) {
                    var categoryOutcome = scoring.weightIdentifier ? 'categoryWeighted' : 'categoryIdentifier';
                    var categoryOutcomeIdentifier = formatCategoryOutcome(category, descriptor.categoryIdentifier);
                    var categoryScoreIdentifier = formatCategoryOutcome(category, total[categoryOutcome]);
                    var categoryCountIdentifier = formatCategoryOutcome(category, max[categoryOutcome]);

                    addCutScoreOutcomes(outcomes, categoryOutcomeIdentifier, categoryScoreIdentifier, categoryCountIdentifier, cutScore);

                    if (descriptor.categoryFeedback) {
                        addFeedbackScoreOutcomes(
                            outcomes,
                            formatCategoryOutcome(category, descriptor.categoryFeedback),
                            categoryOutcomeIdentifier,
                            descriptor.feedbackOk,
                            descriptor.feedbackFailed
                        );
                    }
                });
            }

            return outcomes;
        }
    };

    var scoringHelper = {
        /**
         * Checks the test model against outcome processing mode.
         * Initializes the scoring property accordingly.
         *
         * @param {modelOverseer} modelOverseer
         * @throws {TypeError} if the modelOverseer is invalid
         * @fires modelOverseer#scoring-init
         * @fires modelOverseer#scoring-generate
         * @fires modelOverseer#scoring-write
         */
        init: function init(modelOverseer) {
            var model;

            if (!modelOverseer || !_.isFunction(modelOverseer.getModel)) {
                throw new TypeError("You must provide a valid modelOverseer");
            }

            model = modelOverseer.getModel();

            // detect the score processing mode and build the descriptor used to manage the UI
            model.scoring = detectScoring(modelOverseer);

            modelOverseer
                .on('scoring-change category-change delete', function () {
                    /**
                     * Regenerates the outcomes on any significant changes.
                     * After the outcomes have been generated a write is needed to actually apply the data.
                     * Other component can listen to this event and eventually prevent the write to happen.
                     * @event modelOverseer#scoring-generate
                     * @param {Object} outcomes
                     */
                    modelOverseer.trigger('scoring-generate', scoringHelper.generate(modelOverseer));
                })
                .on('scoring-generate', function (outcomes) {
                    outcomeHelper.replaceOutcomes(model, outcomes);

                    /**
                     * The generated outcome have just been applied on the model.
                     * @event modelOverseer#scoring-write
                     * @param {Object} testModel
                     */
                    modelOverseer.trigger('scoring-write', model);
                })

                /**
                 * @event modelOverseer#scoring-init
                 * @param {Object} testModel
                 */
                .trigger('scoring-init', model);
        },

        /**
         * If the processing mode has been set, generates the outcomes that define the scoring.
         *
         * @param {modelOverseer} modelOverseer
         * @returns {Object}
         * @throws {TypeError} if the modelOverseer is invalid or the processing mode is unknown
         */
        generate: function generate(modelOverseer) {
            var model, scoring, outcomes, outcomeRecipe, recipes, categories;

            if (!modelOverseer || !_.isFunction(modelOverseer.getModel)) {
                throw new TypeError("You must provide a valid modelOverseer");
            }

            model = modelOverseer.getModel();
            scoring = model.scoring;
            outcomes = getOutcomes(model);

            // write the score processing mode by generating the outcomes variables, but only if the mode has been set
            if (scoring) {
                outcomeRecipe = outcomesRecipes[scoring.outcomeProcessing];
                if (outcomeRecipe) {

                    if (outcomeRecipe.clean) {
                        // erase the existing rules, they will be replaced by those that are defined here
                        removeScoring(outcomes);
                    }

                    // get the recipes that define the outcomes, include sub-recipes if any
                    recipes = getRecipes(outcomeRecipe);

                    // only get the categories if requested
                    if (handleCategories(modelOverseer)) {
                        categories = modelOverseer.getCategories();
                    }

                    // will generate outcomes based of the defined recipe
                    _.forEach(recipes, function(recipe) {
                        var writer = outcomesWriters[recipe.writer];
                        writer(recipe, scoring, outcomes, categories);
                    });

                } else {
                    throw new Error('Unknown score processing mode: ' + scoring.outcomeProcessing);
                }
            }

            return outcomes;
        }
    };

    /**
     * Creates an outcome and the rule that process the total score
     *
     * @param {Object} model
     * @param {Object} scoring
     * @param {String} identifier
     * @param {Boolean} [weight]
     * @param {String} [category]
     */
    function addTotalScoreOutcomes(model, scoring, identifier, weight, category) {
        var outcome = outcomeHelper.createOutcome(identifier, baseTypeHelper.FLOAT);
        var processingRule = processingRuleHelper.setOutcomeValue(identifier,
            processingRuleHelper.sum(
                processingRuleHelper.testVariables(scoring.scoreIdentifier, -1, weight && scoring.weightIdentifier, category)
            )
        );

        outcomeHelper.addOutcome(model, outcome, processingRule);
    }

    /**
     * Creates an outcome and the rule that process the maximum score
     *
     * @param {Object} model
     * @param {Object} scoring
     * @param {String} identifier
     * @param {Boolean} [weight]
     * @param {String} [category]
     */
    function addMaxScoreOutcomes(model, scoring, identifier, weight, category) {
        var outcome = outcomeHelper.createOutcome(identifier, baseTypeHelper.FLOAT);
        var processingRule = processingRuleHelper.setOutcomeValue(identifier,
            processingRuleHelper.sum(
                processingRuleHelper.testVariables('MAXSCORE', -1, weight && scoring.weightIdentifier, category)
            )
        );
        outcomeHelper.addOutcome(model, outcome, processingRule);
    }

    /**
     * Create an outcome and the rule that process the score ratio
     *
     * @param model
     * @param identifier
     * @param identifierTotal
     * @param identifierMax
     */
    function addRatioOutcomes(model, identifier, identifierTotal, identifierMax) {
        var outcome = outcomeHelper.createOutcome(identifier, baseTypeHelper.FLOAT);
        var outcomeCondition = processingRuleHelper.outcomeCondition(
            processingRuleHelper.outcomeIf(
                processingRuleHelper.isNull(
                    processingRuleHelper.variable(identifierMax)
                ),
                processingRuleHelper.setOutcomeValue(identifier,
                    processingRuleHelper.baseValue(0, baseTypeHelper.FLOAT)
                )
            ),
            processingRuleHelper.outcomeElse(
                processingRuleHelper.setOutcomeValue(identifier,
                    processingRuleHelper.divide(
                        processingRuleHelper.variable(identifierTotal),
                        processingRuleHelper.variable(identifierMax)
                    )
                )
            )
        );

        outcomeHelper.addOutcome(model, outcome);
        outcomeHelper.addOutcomeProcessing(model, outcomeCondition);
    }

    /**
     * Creates an outcome and the rule that process the cut score by category
     *
     * @param {Object} model
     * @param {String} identifier
     * @param {String} scoreIdentifier
     * @param {String} countIdentifier
     * @param {String|Number} cutScore
     */
    function addCutScoreOutcomes(model, identifier, scoreIdentifier, countIdentifier, cutScore) {
        var outcome = outcomeHelper.createOutcome(identifier, baseTypeHelper.BOOLEAN);
        var processingRule = processingRuleHelper.setOutcomeValue(identifier,
            processingRuleHelper.gte(
                processingRuleHelper.divide(
                    processingRuleHelper.variable(scoreIdentifier),
                    processingRuleHelper.variable(countIdentifier)
                ),
                processingRuleHelper.baseValue(cutScore, baseTypeHelper.FLOAT)
            )
        );

        outcomeHelper.addOutcome(model, outcome, processingRule);
    }

    /**
     * Creates an outcome and the rule that process the global cut score
     *
     * @param {Object} model
     * @param {String} identifier
     * @param {String} scoreIdentifier
     * @param {String} countIdentifier
     * @param {String|Number} cutScore
     */
    function addGlobalCutScoreOutcomes(model, identifier, ratioIdentifier, cutScore) {
        var outcome = outcomeHelper.createOutcome(identifier, baseTypeHelper.BOOLEAN);
        var processingRule = processingRuleHelper.setOutcomeValue(identifier,
            processingRuleHelper.gte(
                processingRuleHelper.variable(ratioIdentifier),
                processingRuleHelper.baseValue(cutScore, baseTypeHelper.FLOAT)
            )
        );

        outcomeHelper.addOutcome(model, outcome, processingRule);
    }

    /**
     * Creates an outcome and the rule that process the score feedback
     *
     * @param {Object} model
     * @param {String} identifier
     * @param {String} variable
     * @param {String} passed
     * @param {String} notPassed
     */
    function addFeedbackScoreOutcomes(model, identifier, variable, passed, notPassed) {
        var type = baseTypeHelper.IDENTIFIER;
        var outcome = outcomeHelper.createOutcome(identifier, type);
        var processingRule = processingRuleHelper.outcomeCondition(
            processingRuleHelper.outcomeIf(
                processingRuleHelper.match(
                    processingRuleHelper.variable(variable),
                    processingRuleHelper.baseValue(true, baseTypeHelper.BOOLEAN)
                ),
                processingRuleHelper.setOutcomeValue(identifier,
                    processingRuleHelper.baseValue(passed, type)
                )
            ),
            processingRuleHelper.outcomeElse(
                processingRuleHelper.setOutcomeValue(identifier,
                    processingRuleHelper.baseValue(notPassed, type)
                )
            )
        );

        outcomeHelper.addOutcome(model, outcome);
        outcomeHelper.addOutcomeProcessing(model, processingRule);
    }

    /**
     * Formats the identifier of a category outcome
     * @param {String} category
     * @param {String} template
     * @returns {String}
     */
    function formatCategoryOutcome(category, template) {
        return format(template, category.toUpperCase());
    }

    /**
     * Checks whether an identifier belongs to a particular recipe
     * @param {String} identifier
     * @param {Object} recipe
     * @param {Boolean} [onlyCategories]
     * @returns {Boolean}
     */
    function belongToRecipe(identifier, recipe, onlyCategories) {
        var match = false;
        if (recipe.signature && recipe.signature.test(identifier)) {
            match = true;
            if (onlyCategories) {
                _.forEach(recipe.outcomes, function(outcome) {
                    if (outcome.identifier === identifier ||
                        (outcome.weighted && outcome.weighted === identifier) ||
                        (outcome.feedback && outcome.feedback === identifier)) {
                        match = false;
                        return false;
                    }
                });
            }
        }
        return match;
    }

    /**
     * Checks if all the outcomes are related to the recipe
     * @param {Object} outcomeRecipe
     * @param {Array} outcomes
     * @param {Array} categories
     * @returns {Boolean}
     */
    function matchRecipe(outcomeRecipe, outcomes, categories) {
        var signatures = getSignatures(outcomeRecipe);
        var match = true;

        // check the outcomes definitions against the provided identifier
        function matchRecipeOutcome(recipe, identifier) {
            var outcomeMatch = false;

            // first level, the signature must match
            if (recipe.signature && recipe.signature.test(identifier)) {
                _.forEach(recipe.outcomes, function(outcome) {
                    // second level, the main identifier must match
                    if (outcome.identifier !== identifier &&
                        (!outcome.weighted || (outcome.weighted && outcome.weighted !== identifier)) &&
                        (!outcome.feedback || (outcome.feedback && outcome.feedback !== identifier))) {

                        if (categories) {
                            // third level, a category must match
                            _.forEach(categories, function(category) {
                                if (outcome.categoryIdentifier &&
                                    identifier === formatCategoryOutcome(category, outcome.categoryIdentifier)) {
                                    outcomeMatch = true;
                                } else if (outcome.categoryWeighted &&
                                    identifier === formatCategoryOutcome(category, outcome.categoryWeighted)) {
                                    outcomeMatch = true;
                                } else if (outcome.categoryFeedback &&
                                    identifier === formatCategoryOutcome(category, outcome.categoryFeedback)) {
                                    outcomeMatch = true;
                                }
                                // found something?
                                if (outcomeMatch) {
                                    return false;
                                }
                            });
                        }
                    } else {
                        outcomeMatch = true;
                    }

                    // found something?
                    if (outcomeMatch) {
                        return false;
                    }
                });
            }

            if (!outcomeMatch && recipe.include) {
                outcomeMatch = matchRecipeOutcome(outcomesRecipes[recipe.include], identifier);
            }

            return outcomeMatch;
        }

        // only check the outcomes that are related to the scoring mode
        _.forEach(outcomes, function(identifier) {
            var signatureMatch = false;
            _.forEach(signatures, function(signature) {
                if (signature.test(identifier)) {
                    signatureMatch = true;
                    return false;
                }
            });

            if (signatureMatch) {
                match = matchRecipeOutcome(outcomeRecipe, identifier);

                if (!match) {
                    return false;
                }
            }
        });

        return match;
    }

    /**
     * Gets all the outcomes signatures related to a scoring mode
     * @param {Object} recipe
     * @returns {Array}
     */
    function getSignatures(recipe) {
        var signatures = [];

        // list the signatures for each processing mode, taking care of includes
        while(recipe) {
            if (recipe.signature) {
                signatures.push(recipe.signature);
            }
            recipe = recipe.include && outcomesRecipes[recipe.include];
        }

        return signatures;
    }

    /**
     * Gets all the outcomes recipes related to a scoring mode
     * @param {Object} recipe
     * @returns {Array}
     */
    function getRecipes(recipe) {
        var descriptors = [];

        // get the recipes that define the outcomes, include sub-recipes if any
        while(recipe) {
            if (recipe.outcomes) {
                descriptors = [].concat(recipe.outcomes, descriptors);
            }
            recipe = recipe.include && outcomesRecipes[recipe.include];
        }

        return descriptors;
    }

    /**
     * Checks if an outcome is related to the outcomes recipe,
     * then returns the recipe descriptor.
     * @param {Object|String} outcome
     * @returns {Object}
     */
    function getOutcomesRecipe(outcome) {
        var identifier = outcomeHelper.getOutcomeIdentifier(outcome);
        var mode = null;
        _.forEach(outcomesRecipes, function (processingRecipe) {
            if (belongToRecipe(identifier, processingRecipe)) {
                mode = processingRecipe;
                return false;
            }
        });
        return mode;
    }

    /**
     * Gets the score processing modes from a list of outcomes
     * @param {Array} outcomes
     * @returns {Array}
     */
    function listScoringModes(outcomes) {
        var modes = {};
        _.forEach(outcomes, function (outcome) {
            var recipe = getOutcomesRecipe(outcome);
            if (recipe) {
                modes[recipe.key] = true;
            }
        });
        return _.keys(modes);
    }

    /**
     * Checks whether the categories have to be taken into account
     * @param {modelOverseer} modelOverseer
     * @returns {Boolean}
     */
    function handleCategories(modelOverseer) {
        var model = modelOverseer.getModel();
        return !!(model.scoring && model.scoring.categoryScore);
    }

    /**
     * Checks if the test model contains outcomes for categories
     * @param {Object} model
     * @returns {Boolean}
     */
    function hasCategoryOutcome(model) {
        var categoryOutcomes = false;
        _.forEach(outcomeHelper.getOutcomeDeclarations(model), function (outcomeDeclaration) {
            var identifier = outcomeHelper.getOutcomeIdentifier(outcomeDeclaration);
            _.forEach(outcomesRecipes, function (processingRecipe) {
                if (belongToRecipe(identifier, processingRecipe, true)) {
                    categoryOutcomes = true;
                    return false;
                }
            });
        });
        return categoryOutcomes;
    }

    /**
     * Gets the defined cut score from the outcome rules
     * @param {Object} model
     * @returns {Number}
     */
    function getCutScore(model) {
        var values = _(outcomeHelper.getOutcomeProcessingRules(model)).map(function (outcome) {
            return outcomeHelper.getProcessingRuleProperty(outcome, 'setOutcomeValue.gte.baseValue.value');
        }).compact().uniq().value();
        if (_.isEmpty(values)) {
            values = [defaultCutScore];
        }
        return Math.max(0, _.max(values));
    }

    /**
     * Gets the defined weight identifier from the outcome rules
     * @param {Object} model
     * @returns {String}
     */
    function getWeightIdentifier(model) {
        var values = [];
        outcomeHelper.eachOutcomeProcessingRuleExpressions(model, function (processingRule) {
            if (processingRule['qti-type'] === 'testVariables' && processingRule.weightIdentifier) {
                values.push(processingRule.weightIdentifier);
            }
        });
        values = _(values).compact().uniq().value();

        return values.length ? values[0] : '';
    }

    /**
     * Detects the outcome processing mode for the scoring
     * @param {modelOverseer} modelOverseer
     * @returns {String}
     */
    function getOutcomeProcessing(modelOverseer) {
        var model = modelOverseer.getModel();
        var outcomeDeclarations = outcomeHelper.getOutcomeDeclarations(model);
        var outcomeRules = outcomeHelper.getOutcomeProcessingRules(model);

        // walk through each outcome declaration, and tries to identify the score processing mode
        var declarations = listScoringModes(outcomeDeclarations);
        var processing = listScoringModes(outcomeRules);
        var diff = _.difference(declarations, processing);
        var count = _.size(declarations);
        var included;

        // default fallback, applied when several modes are detected at the same time
        var outcomeProcessing = 'custom';

        // set the score processing mode with respect to the found outcomes
        if (count === _.size(processing)) {
            if (!count) {
                // no mode detected, set the mode to none
                outcomeProcessing = 'none';
            } else if (_.isEmpty(diff)) {
                if (count > 1) {
                    // several modes detected, try to reduce the list by detecting includes
                    included = [];
                    _.forEach(declarations, function(mode) {
                        if (outcomesRecipes[mode] && outcomesRecipes[mode].include) {
                            included.push(outcomesRecipes[mode].include);
                        }
                    });
                    processing = _.difference(processing, included);
                    count = _.size(processing);
                }

                if (count === 1) {
                    // single mode detected, keep the last got key
                    outcomeProcessing = processing[0];

                    // check if all outcomes are strictly related to the detected mode
                    if (!matchRecipe(outcomesRecipes[outcomeProcessing], modelOverseer.getOutcomesNames(), modelOverseer.getCategories())) {
                        outcomeProcessing = 'custom';
                    }
                }
            }
        }

        return outcomeProcessing;
    }

    /**
     * Detects the score processing mode and builds the descriptor used to manage the UI.
     * @param {modelOverseer} modelOverseer
     * @returns {Object}
     */
    function detectScoring(modelOverseer) {
        var model = modelOverseer.getModel();
        return {
            modes: processingModes,
            scoreIdentifier: defaultScoreIdentifier,
            weightIdentifier: getWeightIdentifier(model),
            cutScore: getCutScore(model),
            categoryScore: hasCategoryOutcome(model),
            outcomeProcessing: getOutcomeProcessing(modelOverseer)
        };
    }

    /**
     * Removes all scoring outcomes
     * @param {Object} model
     */
    function removeScoring(model) {
        var scoringOutcomes = _.indexBy(outcomeHelper.listOutcomes(model, getOutcomesRecipe), function (outcome) {
            return outcome;
        });

        outcomeHelper.removeOutcomes(model, function(outcome) {
            var match = false;

            function browseExpressions(processingRule) {
                if (_.isArray(processingRule)) {
                    _.forEach(processingRule, browseExpressions);
                } else if (processingRule) {
                    if (scoringOutcomes[outcomeHelper.getOutcomeIdentifier(processingRule)]) {
                        match = true;
                    }

                    if (!match && processingRule.expression) {
                        browseExpressions(processingRule.expression);
                    }
                    if (!match && processingRule.expressions) {
                        browseExpressions(processingRule.expressions);
                    }
                    if (!match && processingRule.outcomeRules) {
                        browseExpressions(processingRule.outcomeRules);
                    }
                    if (!match && processingRule.outcomeIf) {
                        browseExpressions(processingRule.outcomeIf);
                    }
                    if (!match && processingRule.outcomeElse) {
                        browseExpressions(processingRule.outcomeElse);
                    }
                }
            }

            if (outcome['qti-type'] === 'outcomeCondition') {
                browseExpressions(outcome);
            } else {
                match = !!scoringOutcomes[outcomeHelper.getOutcomeIdentifier(outcome)];
            }
            return match;
        });
    }

    /**
     * Gets a copy of the list of outcomes, provides the same structure as the model
     * @param {Object} model
     * @returns {Object}
     */
    function getOutcomes(model) {
        return {
            outcomeDeclarations: [].concat(outcomeHelper.getOutcomeDeclarations(model)),
            outcomeProcessing: {
                outcomeRules: [].concat(outcomeHelper.getOutcomeProcessingRules(model))
            }
        };
    }

    return scoringHelper;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
/**
 * @author Bertrand Chevrier <bertrand@taotesting.com>
 */
define('taoQtiTest/controller/creator/creator',[
    'module',
    'jquery',
    'lodash',
    'helpers',
    'i18n',
    'ui/feedback',
    'core/databindcontroller',
    'taoQtiTest/controller/creator/qtiTestCreator',
    'taoQtiTest/controller/creator/views/item',
    'taoQtiTest/controller/creator/views/test',
    'taoQtiTest/controller/creator/views/testpart',
    'taoQtiTest/controller/creator/views/section',
    'taoQtiTest/controller/creator/views/itemref',
    'taoQtiTest/controller/creator/encoders/dom2qti',
    'taoQtiTest/controller/creator/templates/index',
    'taoQtiTest/controller/creator/helpers/qtiTest',
    'taoQtiTest/controller/creator/helpers/scoring',
    'taoQtiTest/controller/creator/helpers/categorySelector',
    'core/validator/validators'
], function(
    module,
    $,
    _,
    helpers,
    __,
    feedback,
    DataBindController,
    qtiTestCreatorFactory,
    itemView,
    testView,
    testPartView,
    sectionView,
    itemrefView,
    Dom2QtiEncoder,
    templates,
    qtiTestHelper,
    scoringHelper,
    categorySelector,
    validators
    ){

    'use strict';

    /**
     * The test creator controller is the main entry point
     * and orchestrates data retrieval and view/components loading.
     * @exports creator/controller
     */
    var Controller = {

        routes : {},

         /**
          * Start the controller, main entry method.
          * @public
          * @param {Object} options
          * @param {Object} options.labels - the list of item's labels to give to the ItemView
          * @param {Object} options.routes - action's urls
          * @param {Object} options.categoriesPresets - predefined category that can be set at the item or section level
          * @param {Boolean} [options.guidedNavigation  = false]- feature flag for the guided navigation
          */
        start : function(options){
            var self = this;
            var $container = $('#test-creator');
            var $saver = $('#saver');
            var binder, binderOptions, modelOverseer;
            var creatorContext;

            self.identifiers = [];

            options = _.merge(module.config(), options || {});
            options.routes = options.routes || {};
            options.labels = options.labels || {};
            options.categoriesPresets = options.categoriesPresets || {};
            options.guidedNavigation = options.guidedNavigation === true;

            categorySelector.setPresets(options.categoriesPresets);

            //back button
            $('#authoringBack').on('click', function(e){
                e.preventDefault();
                if (creatorContext) {
                    creatorContext.trigger('creatorclose');
                }
                window.history.back();
            });

            //set up the ItemView, give it a configured loadItems ref
            itemView($('.test-creator-items .item-selection', $container));

            // forwards some binder events to the model overseer
            $container.on('change.binder delete.binder', function (e, model) {
                if (e.namespace === 'binder' && model && modelOverseer) {
                    modelOverseer.trigger(e.type, model);
                }
            });

            //Data Binding options
            binderOptions = _.merge(options.routes, {
                filters : {
                    'isItemRef' : function(value){
                        return qtiTestHelper.filterQtiType(value, 'assessmentItemRef');
                    },
                    'isSection' : function(value){
                        return qtiTestHelper.filterQtiType(value, 'assessmentSection');
                    }
                },
                encoders : {
                    'dom2qti' : Dom2QtiEncoder
                },
                templates : templates,
                beforeSave : function(model){
                    //ensure the qti-type is present
                    qtiTestHelper.addMissingQtiType(model);

                    //apply consolidation rules
                    qtiTestHelper.consolidateModel(model);

                    //validate the model
                    try {
                        qtiTestHelper.validateModel(model);
                    } catch(err) {
                        $saver.attr('disabled', false).removeClass('disabled');
                        feedback().error(__('The test has not been saved.') + ' ' + err);
                        return false;
                    }
                    return true;
                }
            });

            //set up the databinder
            binder = DataBindController
                .takeControl($container, binderOptions)
                .get(function(model){

                    creatorContext = qtiTestCreatorFactory($container, {
                        uri : options.uri,
                        labels : options.labels,
                        routes : options.routes,
                        guidedNavigation : options.guidedNavigation
                    });
                    creatorContext.setTestModel(model);
                    modelOverseer = creatorContext.getModelOverseer();

                    //detect the scoring mode
                    scoringHelper.init(modelOverseer);

                    //register validators
                    validators.register('idFormat', qtiTestHelper.idFormatValidator());
                    validators.register('testIdFormat', qtiTestHelper.testidFormatValidator());
                    validators.register('testIdAvailable', qtiTestHelper.idAvailableValidator(modelOverseer), true);

                    //once model is loaded, we set up the test view
                    testView(creatorContext);

                    //listen for changes to update available actions
                    testPartView.listenActionState();
                    sectionView.listenActionState();
                    itemrefView.listenActionState();
                    itemrefView.resize();

                    $(window)
                        .off('resize.qti-test-creator')
                        .on('resize.qti-test-creator', function(){
                            itemrefView.resize();
                        });
                });

            //the save button triggers binder's save action.
            $saver.on('click', function(event){
                event.preventDefault();

                if(!$saver.hasClass('disabled')){
                    $saver.attr('disabled', true).addClass('disabled');
                    binder.save(function(){

                        $saver.attr('disabled', false).removeClass('disabled');

                        feedback().success(__('Test Saved'));

                    }, function(){

                        $saver.attr('disabled', false).removeClass('disabled');
                    });
                }
            });
        }
    };

    return Controller;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/controller/creator/helpers/ckConfigurator',['ui/ckeditor/ckConfigurator', 'mathJax'], function(ckConfigurator) {
    'use strict';

    /**
     * Generate a configuration object for CKEDITOR
     *
     * @param editor instance of ckeditor
     * @param toolbarType block | inline | flow | qtiBlock | qtiInline | qtiFlow | reset to get back to normal
     * @param {Object} [options] - is based on the CKEDITOR config object with some additional sugar
     *        Note that it's here you need to add parameters for the resource manager.
     *        Some options are not covered in http://docs.ckeditor.com/#!/api/CKEDITOR.config
     * @param [options.dtdOverrides] - @see dtdOverrides which pre-defines them
     * @param {Object} [options.positionedPlugins] - @see ckConfig.positionedPlugins
     * @param {Boolean} [options.qtiImage] - enables the qtiImage plugin
     * @param {Boolean} [options.qtiInclude] - enables the qtiInclude plugin
     * @param {Boolean} [options.underline] - enables the underline plugin
     * @param {Boolean} [options.mathJax] - enables the mathJax plugin
     *
     * @see http://docs.ckeditor.com/#!/api/CKEDITOR.config
     */
    var getConfig = function(editor, toolbarType, options){
        options = options || {};

        options.underline = true;

        return ckConfigurator.getConfig(editor, toolbarType, options);
    };

    return {
        getConfig : getConfig
    };
});

/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 *
 */

/**
 * This module allows adding extra buttons in the action bar of the test runner
 *
 */
define('taoQtiTest/testRunner/actionBarHook',[
    'jquery',
    'lodash',
    'core/errorHandler',
    'core/promise'
], function ($, _, errorHandler, Promise) {

    'use strict';

    /**
     * Events namespace
     * @type {String}
     * @private
     */
    var _ns = '.actionBarHook';

    /**
     * We need to access the root document to listen for some events
     * @type {jQuery}
     * @private
     */
    var $doc = $(document);

    /**
     * List of loaded and visible hooks
     * @type {Object}
     * @private
     */
    var tools = {};

    /**
     * Flag set to true when the item is loaded
     * @type {Boolean}
     * @private
     */
    var itemIsLoaded = false;

    // catch the item loaded event
    $doc.off(_ns).on('serviceloaded' + _ns, function() {
        itemIsLoaded = true;
        _.forEach(tools, function(tool) {
            triggerItemLoaded(tool);
        });
    });

    /**
     * Check that the toolConfig is correct
     *
     * @param {Object} toolconfig
     * @param {String} toolconfig.hook - the amd module to be loaded to initialize the button
     * @param {String} [toolconfig.label] - the label to be displayed in the button
     * @param {String} [toolconfig.icon] - the icon to be displayed in the button
     * @param {String} [toolconfig.title] - the title to be displayed in the button
     * @param {Array} [toolconfig.items] - an optional list of menu items
     * @returns {Boolean}
     */
    function isValidConfig(toolconfig) {
        return !!(_.isObject(toolconfig) && toolconfig.hook);
    }

    /**
     * Triggers the itemLoaded event inside the provided actionBar hook
     * @param {Object} tool
     */
    function triggerItemLoaded(tool) {
        if (tool && tool.itemLoaded) {
            tool.itemLoaded();
        }
    }

    /**
     * Init a test runner button from its config
     *
     * @param {String} id
     * @param {Object|String} toolconfig
     * @param {String} toolconfig.hook - the amd module to be loaded to initialize the button
     * @param {String} [toolconfig.label] - the label to be displayed in the button
     * @param {String} [toolconfig.icon] - the icon to be displayed in the button
     * @param {String} [toolconfig.title] - the title to be displayed in the button
     * @param {Array} [toolconfig.items] - an optional list of menu items
     * @param {Object} testContext - the complete state of the test
     * @param {Object} testRunner - the test runner instance
     * @fires ready.actionBarHook when the hook has been initialized
     * @returns {Promise}
     */
    function initQtiTool($toolsContainer, id, toolconfig, testContext, testRunner) {

        // the tool is always initialized before the item is loaded, so we can safely false the flag
        itemIsLoaded = false;
        tools[id] = null;

        if (_.isString(toolconfig)) {
            toolconfig = {
                hook: toolconfig
            };
        }

        return new Promise(function(resolve) {
            if (isValidConfig(toolconfig)) {

                require([toolconfig.hook], function (hook) {

                    var $button;
                    var $existingBtn;

                    if (isValidHook(hook)) {
                        //init the control
                        hook.init(id, toolconfig, testContext, testRunner);

                        //if an instance of the tool is already attached, remove it:
                        $existingBtn = $toolsContainer.children('[data-control="' + id + '"]');
                        if ($existingBtn.length) {
                            hook.clear($existingBtn);
                            $existingBtn.remove();
                        }

                        //check if the tool is to be available
                        if (hook.isVisible()) {
                            //keep access to the tool
                            tools[id] = hook;

                            // renders the button from the config
                            $button = hook.render();

                            //only attach the button to the dom when everything is ready
                            _appendInOrder($toolsContainer, $button);

                            //ready !
                            $button.trigger('ready' + _ns, [hook]);

                            //fires the itemLoaded event if the item has already been loaded
                            if (itemIsLoaded) {
                                triggerItemLoaded(hook);
                            }
                        }

                        resolve(hook);
                    } else {
                        errorHandler.throw(_ns, 'invalid hook format');
                        resolve(null);
                    }

                }, function (e) {
                    errorHandler.throw(_ns, 'the hook amd module cannot be found');
                    resolve(null);
                });

            } else {
                errorHandler.throw(_ns, 'invalid tool config format');
                resolve(null);
            }
        });
    }

    /**
     * Append a dom element $button to a $container in a specific order
     * The orders are provided by data-order attribute set to the $button
     *
     * @param {JQuery} $container
     * @param {JQuery} $button
     */
    function _appendInOrder($container, $button) {

        var $after, $before;
        var order = $button.data('order');

        if ('last' === order) {

            $container.append($button);

        } else if ('first' === order) {

            $container.prepend($button);

        } else {

            order = _.parseInt(order);
            if (!_.isNaN(order)) {

                $container.children('.action').each(function () {

                    var $btn = $(this),
                        _order = $btn.data('order');

                    if ('last' === _order) {

                        $before = $btn;
                        $after = null;

                    } else if ('first' === _order) {

                        $before = null;
                        $after = $btn;

                    } else {

                        _order = _.parseInt(_order);

                        if (_.isNaN(_order) || _order > order) {
                            $before = $btn;
                            $after = null;
                            //stops here because $container children returns the dom elements in the dom order
                            return false;
                        } else if (_order === order) {
                            $after = $btn;
                        } else if (_order < order) {
                            $after = $btn;
                            $before = null;
                        }

                    }

                });

                if ($after) {
                    $after.after($button);
                } else if ($before) {
                    $before.before($button);
                } else {
                    $container.append($button);
                }

            } else {
                //unordered buttons are append at the end (including when order equals 0)
                $container.append($button);
            }
        }
    }

    /**
     * Check if the hook object is valid
     *
     * @param {Object} hook
     * @param {Function} hook.init
     * @param {Function} hook.clear
     * @param {Function} hook.isVisible
     * @returns {Boolean}
     */
    function isValidHook(hook) {
        return (_.isObject(hook) && _(['init', 'render', 'clear', 'isVisible']).reduce(function (result, method) {
            return result && _.isFunction(hook[method]);
        }, true));
    }

    return {
        isValid: isValidConfig,
        initQtiTool: initQtiTool
    };
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/testRunner/actionBarTools',[
    'jquery',
    'lodash',
    'core/eventifier',
    'core/promise',
    'taoQtiTest/testRunner/actionBarHook'
], function ($, _, eventifier, Promise, actionBarHook) {
    'use strict';

    /**
     * The list of registered actionBar tools
     * @type {Object}
     */
    var registeredQtiTools;

    /**
     * The list of actionBar tools instances
     * @type {Object}
     */
    var qtiTools;

    /**
     * Manages the actionBar tools
     * @type {Object}
     */
    var actionBarTools = {
        /**
         * Registers the actionBar tools
         * @param {Object} tools
         */
        register : function register(tools) {
            var registerTools = tools || {};

            /**
             * @event actionBarTools#beforeregister
             * @param {Object} tools
             * @param {actionBarTools} this
             */
            this.trigger('beforeregister', registerTools, this);

            registeredQtiTools = registerTools;

            /**
             * @event actionBarTools#afterregister
             * @param {Object} tools
             * @param {actionBarTools} this
             */
            this.trigger('afterregister', registerTools, this);
        },

        /**
         * Gets the list of registered tools
         * @returns {Object}
         */
        getRegisteredTools : function getRegisteredTools() {
            return registeredQtiTools || {};
        },

        /**
         * Gets a particular tool config
         * @param {String} id
         * @returns {Object}
         */
        getRegistered : function getRegistered(id) {
            return registeredQtiTools && registeredQtiTools[id];
        },

        /**
         * Checks if a particular tool is registered
         * @param {String} id
         * @returns {Boolean}
         */
        isRegistered : function isRegistered(id) {
            return !!(registeredQtiTools && registeredQtiTools[id]);
        },

        /**
         * Gets a particular tool
         * @param {String} id
         * @returns {Object}
         */
        get : function get(id) {
            return qtiTools && qtiTools[id];
        },

        /**
         * Gets the list of tools instances
         * @returns {Array}
         */
        list : function list() {
            return _.values(qtiTools || {});
        },

        /**
         * Renders the actionBar
         * @param {String|jQuery|HTMLElement} container - The container in which renders the tools
         * @param {Object} testContext - The assessment test context
         * @param {Object} testRunner - The assessment test runner
         * @param {Function} [callback] - An optional callback fired when all tools have been rendered
         */
        render : function render(container, testContext, testRunner, callback) {
            var self = this;
            var $container = $(container);
            var promises = [];

            /**
             * @event actionBarTools#beforerender
             * @param {jQuery} $container
             * @param {Object} testContext
             * @param {Object} testRunner
             * @param {actionBarTools} this
             */
            this.trigger('beforerender', $container, testContext, testRunner, this);

            _.forIn(this.getRegisteredTools(), function(toolconfig, id){
                promises.push(actionBarHook.initQtiTool($container, id, toolconfig, testContext, testRunner));
            });

            Promise.all(promises).then(function(values) {
                var tools = [];
                qtiTools = {};

                _.forEach(values, function(tool) {
                    if (tool) {
                        tools.push(tool);
                        qtiTools[tool.getId()] = tool;
                    }
                });

                if (_.isFunction(callback)) {
                    callback.call(self, tools, $container, testContext, testRunner, self);
                }

                /**
                 * @event actionBarTools#afterrender
                 * @param {Array} tools
                 * @param {jQuery} $container
                 * @param {Object} testContext
                 * @param {Object} testRunner
                 * @param {actionBarTools} this
                 */
                self.trigger('afterrender', tools, $container, testContext, testRunner, self);
            });
        }
    };

    return eventifier(actionBarTools);
});


define('tpl!taoQtiTest/testRunner/tpl/navigator', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return " hidden";
  }

  buffer += "        <aside class=\"test-sidebar test-sidebar-";
  if (helper = helpers.region) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.region); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " flex-container-navi qti-navigator";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hidden), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n            <div class=\"qti-navigator-collapsible\">\n                <span class=\"qti-navigator-collapse icon icon-left\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Collapse the review panel", options) : helperMissing.call(depth0, "__", "Collapse the review panel", options)))
    + "\"></span>\n                <span class=\"qti-navigator-expand icon icon-right\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Expand the review panel", options) : helperMissing.call(depth0, "__", "Expand the review panel", options)))
    + "\"></span>\n            </div>\n\n            <div class=\"qti-navigator-info collapsible\">\n                <span class=\"qti-navigator-label\">\n                    <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Test status", options) : helperMissing.call(depth0, "__", "Test status", options)))
    + "</span>\n                    <span class=\"icon-up\"></span>\n                    <span class=\"icon-down\"></span>\n                </span>\n                <ul class=\"collapsible-panel plain\">\n                    <li class=\"qti-navigator-viewed\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Viewed items", options) : helperMissing.call(depth0, "__", "Viewed items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-viewed\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Viewed", options) : helperMissing.call(depth0, "__", "Viewed", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n                    </li>\n                    <li class=\"qti-navigator-answered\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Completed items", options) : helperMissing.call(depth0, "__", "Completed items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-answered\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Answered", options) : helperMissing.call(depth0, "__", "Answered", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n                    </li>\n                    <li class=\"qti-navigator-unanswered\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Unanswered items", options) : helperMissing.call(depth0, "__", "Unanswered items", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-unanswered\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Unanswered", options) : helperMissing.call(depth0, "__", "Unanswered", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n                    </li>\n                    <li class=\"qti-navigator-flagged\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Items marked for later review", options) : helperMissing.call(depth0, "__", "Items marked for later review", options)))
    + "\">\n                        <span class=\"qti-navigator-label\">\n                            <span class=\"qti-navigator-icon icon-flagged\"></span>\n                            <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Flagged", options) : helperMissing.call(depth0, "__", "Flagged", options)))
    + "</span>\n                            <span class=\"qti-navigator-counter\">-/-</span>\n                        </span>\n                    </li>\n                </ul>\n            </div>\n\n            <div class=\"qti-navigator-filters\">\n                <ul class=\"plain clearfix\">\n                    <li class=\"qti-navigator-filter active\" data-mode=\"all\">\n                        <span title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Reset filters", options) : helperMissing.call(depth0, "__", "Reset filters", options)))
    + "\" class=\"qti-navigator-tab\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "All", options) : helperMissing.call(depth0, "__", "All", options)))
    + "</span>\n                    </li>\n                    <li class=\"qti-navigator-filter\" data-mode=\"unanswered\">\n                        <span class=\"icon-unanswered qti-navigator-tab\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Only display the unanswered items", options) : helperMissing.call(depth0, "__", "Only display the unanswered items", options)))
    + "\"></span>\n                    </li>\n                    <li class=\"qti-navigator-filter\" data-mode=\"flagged\">\n                        <span class=\"icon-flagged qti-navigator-tab\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Only display the items marked for review", options) : helperMissing.call(depth0, "__", "Only display the items marked for review", options)))
    + "\"></span>\n                    </li>\n                </ul>\n            </div>\n\n            <nav class=\"qti-navigator-tree\">\n            </nav>\n\n            <div id=\"qti-navigator-linear\" class=\"qti-navigator-linear\">\n                <span class=\"icon icon-info\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\"></span>\n                <p class=\"qti-navigator-message\">\n                    "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\n                </p>\n            </div>\n        </aside>\n";
  return buffer;
  });
});


define('tpl!taoQtiTest/testRunner/tpl/navigatorTree', ['handlebars'], function(hb){ 
return hb.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                    <li class=\"qti-navigator-part collapsible ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                        <span class=\"qti-navigator-label\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                            <span class=\"qti-navigator-text\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n                            <span class=\"icon-up\"></span>\n                            <span class=\"icon-down\"></span>\n                        </span>\n                        ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.sections)),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.program(29, program29, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                    </li>\n                    ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "active";
  }

function program4(depth0,data) {
  
  
  return "collapsed";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n                        <ul class=\"qti-navigator-sections collapsible-panel plain\">\n                            ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.sections), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                        </ul>\n                        ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                            <li class=\"qti-navigator-section collapsible ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                                <span class=\"qti-navigator-label\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                                    <span class=\"qti-navigator-text\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n                                    <span class=\"qti-navigator-counter\">";
  if (helper = helpers.answered) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.answered); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "/"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.items)),stack1 == null || stack1 === false ? stack1 : stack1.length)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span>\n                                </span>\n                                <ul class=\"qti-navigator-items collapsible-panel plain\">\n                                    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.items), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                                </ul>\n                            </li>\n                            ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                                    <li class=\"qti-navigator-item";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.active), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.flagged), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.answered), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.viewed), {hash:{},inverse:self.program(17, program17, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-position=\"";
  if (helper = helpers.position) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.position); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                                        <span class=\"qti-navigator-label truncate\" title=\"";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n                                            <span class=\"qti-navigator-icon icon-";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.flagged), {hash:{},inverse:self.program(21, program21, data),fn:self.program(19, program19, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></span>\n                                            <span class=\"qti-navigator-number\">"
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</span>\n                                            ";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n                                        </span>\n                                    </li>\n                                    ";
  return buffer;
  }
function program9(depth0,data) {
  
  
  return " active";
  }

function program11(depth0,data) {
  
  
  return " flagged";
  }

function program13(depth0,data) {
  
  
  return " answered";
  }

function program15(depth0,data) {
  
  
  return " viewed";
  }

function program17(depth0,data) {
  
  
  return " unseen";
  }

function program19(depth0,data) {
  
  
  return "flagged";
  }

function program21(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.answered), {hash:{},inverse:self.program(24, program24, data),fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }
function program22(depth0,data) {
  
  
  return "answered";
  }

function program24(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.viewed), {hash:{},inverse:self.program(27, program27, data),fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }
function program25(depth0,data) {
  
  
  return "viewed";
  }

function program27(depth0,data) {
  
  
  return "unseen";
  }

function program29(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n                        <div class=\"qti-navigator-linear-part collapsible-panel\">\n                            <span class=\"icon icon-info\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\"></span>\n                            <p class=\"qti-navigator-message\">\n                                "
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "In this part of the test navigation is not allowed.", options) : helperMissing.call(depth0, "__", "In this part of the test navigation is not allowed.", options)))
    + "\n                            </p>\n                            <p class=\"qti-navigator-actions\">\n                                <button class=\"btn-info small\" data-id=\"";
  if (helper = helpers.itemId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.itemId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-position=\"";
  if (helper = helpers.position) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.position); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\""
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Start Test-part", options) : helperMissing.call(depth0, "__", "Start Test-part", options)))
    + "\">\n                                    <span class=\"qti-navigator-text\">"
    + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "Start Test-part", options) : helperMissing.call(depth0, "__", "Start Test-part", options)))
    + "</span>\n                                    <span class=\"icon-play r\"></span>\n                                </button>\n                            </p>\n                        </div>\n                        ";
  return buffer;
  }

  buffer += "                <ul class=\"qti-navigator-parts plain\">\n                    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.parts), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n                </ul>\n";
  return buffer;
  });
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/testRunner/testReview',[
    'jquery',
    'lodash',
    'i18n',
    'tpl!taoQtiTest/testRunner/tpl/navigator',
    'tpl!taoQtiTest/testRunner/tpl/navigatorTree',
    'util/capitalize'
], function ($, _, __, navigatorTpl, navigatorTreeTpl, capitalize) {
    'use strict';

    /**
     * List of CSS classes
     * @type {Object}
     * @private
     */
    var _cssCls = {
        active : 'active',
        collapsed : 'collapsed',
        collapsible : 'collapsible',
        hidden : 'hidden',
        disabled : 'disabled',
        flagged : 'flagged',
        answered : 'answered',
        viewed : 'viewed',
        unseen : 'unseen',
        icon : 'qti-navigator-icon',
        scope : {
            test : 'scope-test',
            testPart : 'scope-test-part',
            testSection : 'scope-test-section'
        }
    };

    /**
     * List of common CSS selectors
     * @type {Object}
     * @private
     */
    var _selectors = {
        component : '.qti-navigator',
        filterBar : '.qti-navigator-filters',
        tree : '.qti-navigator-tree',
        collapseHandle : '.qti-navigator-collapsible',
        linearState : '.qti-navigator-linear',
        infoAnswered : '.qti-navigator-answered .qti-navigator-counter',
        infoViewed : '.qti-navigator-viewed .qti-navigator-counter',
        infoUnanswered : '.qti-navigator-unanswered .qti-navigator-counter',
        infoFlagged : '.qti-navigator-flagged .qti-navigator-counter',
        infoPanel : '.qti-navigator-info',
        infoPanelLabels : '.qti-navigator-info > .qti-navigator-label',
        parts : '.qti-navigator-part',
        partLabels : '.qti-navigator-part > .qti-navigator-label',
        sections : '.qti-navigator-section',
        sectionLabels : '.qti-navigator-section > .qti-navigator-label',
        items : '.qti-navigator-item',
        itemLabels : '.qti-navigator-item > .qti-navigator-label',
        itemIcons : '.qti-navigator-item > .qti-navigator-icon',
        icons : '.qti-navigator-icon',
        linearStart : '.qti-navigator-linear-part button',
        counters : '.qti-navigator-counter',
        actives : '.active',
        collapsible : '.collapsible',
        collapsiblePanels : '.collapsible-panel',
        unseen : '.unseen',
        answered : '.answered',
        flagged : '.flagged',
        notFlagged : ':not(.flagged)',
        notAnswered : ':not(.answered)',
        hidden : '.hidden'
    };

    /**
     * Maps the filter mode to filter criteria.
     * Each filter criteria is a CSS selector used to find and mask the items to be discarded by the filter.
     * @type {Object}
     * @private
     */
    var _filterMap = {
        all : "",
        unanswered : _selectors.answered,
        flagged : _selectors.notFlagged,
        answered : _selectors.notAnswered,
        filtered : _selectors.hidden
    };

    /**
     * Maps of config options translated from the context object to the local options
     * @type {Object}
     * @private
     */
    var _optionsMap = {
        'reviewScope' : 'reviewScope',
        'reviewPreventsUnseen' : 'preventsUnseen',
        'canCollapse' : 'canCollapse'
    };

    /**
     * Maps the handled review scopes
     * @type {Object}
     * @private
     */
    var _reviewScopes = {
        test : 'test',
        testPart : 'testPart',
        testSection : 'testSection'
    };

    /**
     * Provides a test review manager
     * @type {Object}
     */
    var testReview = {
        /**
         * Initializes the component
         * @param {String|jQuery|HTMLElement} element The element on which install the component
         * @param {Object} [options] A list of extra options
         * @param {String} [options.region] The region on which put the component: left or right
         * @param {String} [options.reviewScope] Limit the review screen to a particular scope:
         * the whole test, the current test part or the current test section)
         * @param {Boolean} [options.preventsUnseen] Prevents the test taker to access unseen items
         * @returns {testReview}
         */
        init: function init(element, options) {
            var initOptions = _.isObject(options) && options || {};
            var putOnRight = 'right' === initOptions.region;
            var insertMethod = putOnRight ? 'append' : 'prepend';

            this.options = initOptions;
            this.disabled = false;
            this.hidden = !!initOptions.hidden;
            this.currentFilter = 'all';

            // clean the DOM if the init method is called after initialisation
            if (this.$component) {
                this.$component.remove();
            }

            // build the component structure and inject it into the DOM
            this.$container = $(element);
            insertMethod = this.$container[insertMethod];
            if (insertMethod) {
                insertMethod.call(this.$container, navigatorTpl({
                    region: putOnRight ? 'right' : 'left',
                    hidden: this.hidden
                }));
            } else {
                throw new Error("Unable to inject the component structure into the DOM");
            }

            // install the component behaviour
            this._loadDOM();
            this._initEvents();
            this._updateDisplayOptions();

            return this;
        },

        /**
         * Links the component to the underlying DOM elements
         * @private
         */
        _loadDOM: function() {
            this.$component = this.$container.find(_selectors.component);

            // access to info panel displaying counters
            this.$infoAnswered = this.$component.find(_selectors.infoAnswered);
            this.$infoViewed = this.$component.find(_selectors.infoViewed);
            this.$infoUnanswered = this.$component.find(_selectors.infoUnanswered);
            this.$infoFlagged = this.$component.find(_selectors.infoFlagged);

            // access to filter switches
            this.$filterBar = this.$component.find(_selectors.filterBar);
            this.$filters = this.$filterBar.find('li');

            // access to the tree of parts/sections/items
            this.$tree = this.$component.find(_selectors.tree);

            // access to the panel displayed when a linear part is reached
            this.$linearState = this.$component.find(_selectors.linearState);
        },

        /**
         * Installs the event handlers on the underlying DOM elements
         * @private
         */
        _initEvents: function() {
            var self = this;

            // click on the collapse handle: collapse/expand the review panel
            this.$component.on('click' + _selectors.component, _selectors.collapseHandle, function() {
                if (self.disabled) {
                    return;
                }

                self.$component.toggleClass(_cssCls.collapsed);
                if (self.$component.hasClass(_cssCls.collapsed)) {
                    self._openSelected();
                }
            });

            // click on the info panel title: toggle the related panel
            this.$component.on('click' + _selectors.component, _selectors.infoPanelLabels, function() {
                if (self.disabled) {
                    return;
                }

                var $panel = $(this).closest(_selectors.infoPanel);
                self._togglePanel($panel, _selectors.infoPanel);
            });

            // click on a part title: toggle the related panel
            this.$tree.on('click' + _selectors.component, _selectors.partLabels, function() {
                if (self.disabled) {
                    return;
                }

                var $panel = $(this).closest(_selectors.parts);
                var open = self._togglePanel($panel, _selectors.parts);

                if (open) {
                    if ($panel.hasClass(_cssCls.active)) {
                        self._openSelected();
                    } else {
                        self._openOnly($panel.find(_selectors.sections).first(), $panel);
                    }
                }
            });

            // click on a section title: toggle the related panel
            this.$tree.on('click' + _selectors.component, _selectors.sectionLabels, function() {
                if (self.disabled) {
                    return;
                }

                var $panel = $(this).closest(_selectors.sections);

                self._togglePanel($panel, _selectors.sections);
            });

            // click on an item: jump to the position
            this.$tree.on('click' + _selectors.component, _selectors.itemLabels, function(event) {
                if (self.disabled) {
                    return;
                }

                var $item = $(this).closest(_selectors.items);
                var $target;

                if (!$item.hasClass(_cssCls.disabled)) {
                    $target = $(event.target);
                    if ($target.is(_selectors.icons) && !self.$component.hasClass(_cssCls.collapsed)) {
                        if (!$item.hasClass(_cssCls.unseen)) {
                            self._mark($item);
                        }
                    } else {
                        self._select($item);
                        self._jump($item);
                    }
                }
            });

            // click on the start button inside a linear part: jump to the position
            this.$tree.on('click' + _selectors.component, _selectors.linearStart, function() {
                if (self.disabled) {
                    return;
                }

                var $btn = $(this);

                if (!$btn.hasClass(_cssCls.disabled)) {
                    $btn.addClass(_cssCls.disabled);
                    self._jump($btn);
                }
            });

            // click on a filter button
            this.$filterBar.on('click' + _selectors.component, 'li', function() {
                if (self.disabled) {
                    return;
                }

                var $btn = $(this);
                var mode = $btn.data('mode');

                self.$filters.removeClass(_cssCls.active);
                self.$component.removeClass(_cssCls.collapsed);
                $btn.addClass(_cssCls.active);

                self._filter(mode);
            });
        },

        /**
         * Filters the items by a criteria
         * @param {String} criteria
         * @private
         */
        _filter: function(criteria) {
            var $items = this.$tree.find(_selectors.items).removeClass(_cssCls.hidden);
            var filter = _filterMap[criteria];
            if (filter) {
                $items.filter(filter).addClass(_cssCls.hidden);
            }
            this._updateSectionCounters(!!filter);
            this.currentFilter = criteria;
        },

        /**
         * Selects an item
         * @param {String|jQuery} position The item's position
         * @param {Boolean} [open] Forces the tree to be opened on the selected item
         * @returns {jQuery} Returns the selected item
         * @private
         */
        _select: function(position, open) {
            // find the item to select and extract its hierarchy
            var selected = position && position.jquery ? position : this.$tree.find('[data-position=' + position + ']');
            var hierarchy = selected.parentsUntil(this.$tree);

            // collapse the full tree and open only the hierarchy of the selected item
            if (open) {
                this._openOnly(hierarchy);
            }

            // select the item
            this.$tree.find(_selectors.actives).removeClass(_cssCls.active);
            hierarchy.add(selected).addClass(_cssCls.active);
            return selected;
        },

        /**
         * Opens the tree on the selected item only
         * @returns {jQuery} Returns the selected item
         * @private
         */
        _openSelected: function() {
            // find the selected item and extract its hierarchy
            var selected = this.$tree.find(_selectors.items + _selectors.actives);
            var hierarchy = selected.parentsUntil(this.$tree);

            // collapse the full tree and open only the hierarchy of the selected item
            this._openOnly(hierarchy);

            return selected;
        },

        /**
         * Collapses the full tree and opens only the provided branch
         * @param {jQuery} opened The element to be opened
         * @param {jQuery} [root] The root element from which collapse the panels
         * @private
         */
        _openOnly: function(opened, root) {
            (root || this.$tree).find(_selectors.collapsible).addClass(_cssCls.collapsed);
            opened.removeClass(_cssCls.collapsed);
        },

        /**
         * Toggles a panel
         * @param {jQuery} panel The panel to toggle
         * @param {String} [collapseSelector] Selector of panels to collapse
         * @returns {Boolean} Returns `true` if the panel just expanded now
         */
        _togglePanel: function(panel, collapseSelector) {
            var collapsed = panel.hasClass(_cssCls.collapsed);

            if (collapseSelector) {
                this.$tree.find(collapseSelector).addClass(_cssCls.collapsed);
            }

            if (collapsed) {
                panel.removeClass(_cssCls.collapsed);
            } else {
                panel.addClass(_cssCls.collapsed);
            }
            return collapsed;
        },

        /**
         * Sets the icon of a particular item
         * @param {jQuery} $item
         * @param {String} icon
         * @private
         */
        _setItemIcon: function($item, icon) {
            $item.find(_selectors.icons).attr('class', _cssCls.icon + ' icon-' + icon);
        },

        /**
         * Sets the icon of a particular item according to its state
         * @param {jQuery} $item
         * @private
         */
        _adjustItemIcon: function($item) {
            var icon = null;
            var defaultIcon = _cssCls.unseen;
            var iconCls = [
                _cssCls.flagged,
                _cssCls.answered,
                _cssCls.viewed
            ];

            _.forEach(iconCls, function(cls) {
                if ($item.hasClass(cls)) {
                    icon = cls;
                    return false;
                }
            });

            this._setItemIcon($item, icon || defaultIcon);
        },

        /**
         * Toggle the marked state of an item
         * @param {jQuery} $item
         * @param {Boolean} [flag]
         * @private
         */
        _toggleFlag: function($item, flag) {
            $item.toggleClass(_cssCls.flagged, flag);
            this._adjustItemIcon($item);
        },

        /**
         * Marks an item for later review
         * @param {jQuery} $item
         * @private
         */
        _mark: function($item) {
            var itemId = $item.data('id');
            var itemPosition = $item.data('position');
            var flag = !$item.hasClass(_cssCls.flagged);

            this._toggleFlag($item);

            /**
             * A storage of the flag is required
             * @event testReview#mark
             * @param {Boolean} flag - Tells whether the item is marked for review or not
             * @param {Number} position - The item position on which jump
             * @param {String} itemId - The identifier of the target item
             * @param {testReview} testReview - The client testReview component
             */
            this.trigger('mark', [flag, itemPosition, itemId]);
        },

        /**
         * Jumps to an item
         * @param {jQuery} $item
         * @private
         */
        _jump: function($item) {
            var itemId = $item.data('id');
            var itemPosition = $item.data('position');

            /**
             * A jump to a particular item is required
             * @event testReview#jump
             * @param {Number} position - The item position on which jump
             * @param {String} itemId - The identifier of the target item
             * @param {testReview} testReview - The client testReview component
             */
            this.trigger('jump', [itemPosition, itemId]);
        },

        /**
         * Updates the sections related items counters
         * @param {Boolean} filtered
         */
        _updateSectionCounters: function(filtered) {
            var self = this;
            var filter = _filterMap[filtered ? 'filtered' : 'answered'];
            this.$tree.find(_selectors.sections).each(function() {
                var $section = $(this);
                var $items = $section.find(_selectors.items);
                var $filtered = $items.filter(filter);
                var total = $items.length;
                var nb = total - $filtered.length;
                self._writeCount($section.find(_selectors.counters), nb, total);
            });
        },

        /**
         * Updates the display according to options
         * @private
         */
        _updateDisplayOptions: function() {
            var reviewScope = _reviewScopes[this.options.reviewScope] || 'test';
            var scopeClass = _cssCls.scope[reviewScope];
            var $root = this.$component;
            _.forEach(_cssCls.scope, function(cls) {
                $root.removeClass(cls);
            });
            if (scopeClass) {
                $root.addClass(scopeClass);
            }
            $root.toggleClass(_cssCls.collapsible, this.options.canCollapse);
        },

        /**
         * Updates the local options from the provided context
         * @param {Object} testContext The progression context
         * @private
         */
        _updateOptions: function(testContext) {
            var options = this.options;
            _.forEach(_optionsMap, function(optionKey, contextKey) {
                if (undefined !== testContext[contextKey]) {
                    options[optionKey] = testContext[contextKey];
                }
            });
        },

        /**
         * Updates the info panel
         */
        _updateInfos: function() {
            var progression = this.progression,
                unanswered = Number(progression.total) - Number(progression.answered);

            // update the info panel
            this._writeCount(this.$infoAnswered, progression.answered, progression.total);
            this._writeCount(this.$infoUnanswered, unanswered, progression.total);
            this._writeCount(this.$infoViewed, progression.viewed, progression.total);
            this._writeCount(this.$infoFlagged, progression.flagged, progression.total);
        },

        /**
         * Updates a counter
         * @param {jQuery} $place
         * @param {Number} count
         * @param {Number} total
         * @private
         */
        _writeCount: function($place, count, total) {
            $place.text(count + '/' + total);
        },

        /**
         * Gets the progression stats for the whole test
         * @param {Object} testContext The progression context
         * @returns {{total: (Number), answered: (Number), viewed: (Number), flagged: (Number)}}
         * @private
         */
        _getProgressionOfTest: function(testContext) {
            return {
                total : testContext.numberItems || 0,
                answered : testContext.numberCompleted || 0,
                viewed : testContext.numberPresented || 0,
                flagged : testContext.numberFlagged || 0
            };
        },

        /**
         * Gets the progression stats for the current test part
         * @param {Object} testContext The progression context
         * @returns {{total: (Number), answered: (Number), viewed: (Number), flagged: (Number)}}
         * @private
         */
        _getProgressionOfTestPart: function(testContext) {
            return {
                total : testContext.numberItemsPart || 0,
                answered : testContext.numberCompletedPart || 0,
                viewed : testContext.numberPresentedPart || 0,
                flagged : testContext.numberFlaggedPart || 0
            };
        },

        /**
         * Gets the progression stats for the current test section
         * @param {Object} testContext The progression context
         * @returns {{total: (Number), answered: (Number), viewed: (Number), flagged: (Number)}}
         * @private
         */
        _getProgressionOfTestSection: function(testContext) {
            return {
                total : testContext.numberItemsSection || 0,
                answered : testContext.numberCompletedSection || 0,
                viewed : testContext.numberPresentedSection || 0,
                flagged : testContext.numberFlaggedSection || 0
            };
        },

        /**
         * Updates the navigation tre
         * @param {Object} testContext The progression context
         */
        _updateTree: function(testContext) {
            var navigatorMap = testContext.navigatorMap;
            var reviewScope = this.options.reviewScope;
            var reviewScopePart = reviewScope === 'testPart';
            var reviewScopeSection = reviewScope === 'testSection';
            var _partsFilter = function(part) {
                if (reviewScopeSection && part.sections) {
                    part.sections = _.filter(part.sections, _partsFilter);
                }
                return part.active;
            };

            // rebuild the tree
            if (navigatorMap) {
                if (reviewScopePart || reviewScopeSection) {
                    // display only the current section
                    navigatorMap = _.filter(navigatorMap, _partsFilter);
                }

                this.$filterBar.show();
                this.$linearState.hide();
                this.$tree.html(navigatorTreeTpl({
                    parts: navigatorMap
                }));

                if (this.options.preventsUnseen) {
                    // disables all unseen items to prevent the test taker has access to.
                    this.$tree.find(_selectors.unseen).addClass(_cssCls.disabled);
                }
            } else {
                this.$filterBar.hide();
                this.$linearState.show();
                this.$tree.empty();
            }

            // apply again the current filter
            this._filter(this.$filters.filter(_selectors.actives).data('mode'));
        },

        /**
         * Set the marked state of an item
         * @param {Number|String|jQuery} position
         * @param {Boolean} flag
         */
        setItemFlag: function setItemFlag(position, flag) {
            var $item = position && position.jquery ? position : this.$tree.find('[data-position=' + position + ']');
            var progression = this.progression;

            // update the item flag
            this._toggleFlag($item, flag);

            // update the info panel
            progression.flagged = this.$tree.find(_selectors.flagged).length;
            this._writeCount(this.$infoFlagged, progression.flagged, progression.total);
            this._filter(this.currentFilter);
        },

        /**
         * Update the number of flagged items in the test context
         * @param {Object} testContext The test context
         * @param {Number} position The position of the flagged item
         * @param {Boolean} flag The flag state
         */
        updateNumberFlagged: function(testContext, position, flag) {
            var fields = ['numberFlagged'];
            var currentPosition = testContext.itemPosition;
            var currentFound = false, currentSection = null, currentPart = null;
            var itemFound = false, itemSection = null, itemPart = null;

            if (testContext.navigatorMap) {
                // find the current item and the marked item inside the navigator map
                // check if the marked item is in the current section
                _.forEach(testContext.navigatorMap, function(part) {
                    _.forEach(part && part.sections, function(section) {
                        _.forEach(section && section.items, function(item) {
                            if (item) {
                                if (item.position === position) {
                                    itemPart = part;
                                    itemSection = section;
                                    itemFound = true;
                                }
                                if (item.position === currentPosition) {
                                    currentPart = part;
                                    currentSection = section;
                                    currentFound = true;

                                }
                                if (itemFound && currentFound) {
                                    return false;
                                }
                            }
                        });

                        if (itemFound && currentFound) {
                            return false;
                        }
                    });

                    if (itemFound && currentFound) {
                        return false;
                    }
                });

                // select the context to update
                if (itemFound && currentPart === itemPart) {
                    fields.push('numberFlaggedPart');
                }
                if (itemFound && currentSection === itemSection) {
                    fields.push('numberFlaggedSection');
                }
            } else {
                // no navigator map, the current the marked item is in the current section
                fields.push('numberFlaggedPart');
                fields.push('numberFlaggedSection');
            }

            _.forEach(fields, function(field) {
                if (field in testContext) {
                    testContext[field] += flag ? 1 : -1;
                }
            });
        },

        /**
         * Get progression
         * @param {Object} testContext The progression context
         * @returns {object} progression
         */
        getProgression: function getProgression(testContext) {
            var reviewScope = _reviewScopes[this.options.reviewScope] || 'test',
                progressInfoMethod = '_getProgressionOf' + capitalize(reviewScope),
                getProgression = this[progressInfoMethod] || this._getProgressionOfTest,
                progression = getProgression && getProgression(testContext) || {};

            return progression;
        },

        /**
         * Updates the review screen
         * @param {Object} testContext The progression context
         * @returns {testReview}
         */
        update: function update(testContext) {
            this.progression = this.getProgression(testContext);
            this._updateOptions(testContext);
            this._updateInfos(testContext);
            this._updateTree(testContext);
            this._updateDisplayOptions(testContext);
            return this;
        },

        /**
         * Disables the component
         * @returns {testReview}
         */
        disable: function disable() {
            this.disabled = true;
            this.$component.addClass(_cssCls.disabled);
            return this;
        },

        /**
         * Enables the component
         * @returns {testReview}
         */
        enable: function enable() {
            this.disabled = false;
            this.$component.removeClass(_cssCls.disabled);
            return this;
        },

        /**
         * Hides the component
         * @returns {testReview}
         */
        hide: function hide() {
            this.disabled = true;
            this.hidden = true;
            this.$component.addClass(_cssCls.hidden);
            return this;
        },

        /**
         * Shows the component
         * @returns {testReview}
         */
        show: function show() {
            this.disabled = false;
            this.hidden = false;
            this.$component.removeClass(_cssCls.hidden);
            return this;
        },

        /**
         * Toggles the display state of the component
         * @param {Boolean} [show] External condition that's tells if the component must be shown or hidden
         * @returns {testReview}
         */
        toggle: function toggle(show) {
            if (undefined === show) {
                show = this.hidden;
            }

            if (show) {
                this.show();
            } else {
                this.hide();
            }

            return this;
        },

        /**
         * Install an event handler on the underlying DOM element
         * @param {String} eventName
         * @returns {testReview}
         */
        on: function on(eventName) {
            var dom = this.$component;
            if (dom) {
                dom.on.apply(dom, arguments);
            }

            return this;
        },

        /**
         * Uninstall an event handler from the underlying DOM element
         * @param {String} eventName
         * @returns {testReview}
         */
        off: function off(eventName) {
            var dom = this.$component;
            if (dom) {
                dom.off.apply(dom, arguments);
            }

            return this;
        },

        /**
         * Triggers an event on the underlying DOM element
         * @param {String} eventName
         * @param {Array|Object} extraParameters
         * @returns {testReview}
         */
        trigger : function trigger(eventName, extraParameters) {
            var dom = this.$component;

            if (undefined === extraParameters) {
                extraParameters = [];
            }
            if (!_.isArray(extraParameters)) {
                extraParameters = [extraParameters];
            }

            extraParameters.push(this);

            if (dom) {
                dom.trigger(eventName, extraParameters);
            }

            return this;
        }
    };

    /**
     * Builds an instance of testReview
     * @param {String|jQuery|HTMLElement} element The element on which install the component
     * @param {Object} [options] A list of extra options
     * @param {String} [options.region] The region on which put the component: left or right
     * @param {String} [options.reviewScope] Limit the review screen to a particular scope:
     * the whole test, the current test part or the current test section)
     * @param {Boolean} [options.preventsUnseen] Prevents the test taker to access unseen items
     * @returns {testReview}
     */
    var testReviewFactory = function(element, options) {
        var component = _.clone(testReview, true);
        return component.init(element, options);
    };

    return testReviewFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA ;
 */
/**
 * @author Jean-Sébastien Conan <jean-sebastien.conan@vesperiagroup.com>
 */
define('taoQtiTest/testRunner/progressUpdater',[
    'jquery',
    'lodash',
    'i18n',
    'ui/progressbar'
], function ($, _, __) {
    'use strict';

    /**
     * Provides a versatile progress bar updater
     * @type {{init: Function, update: Function}}
     */
    var progressUpdaters = {
        /**
         * Initializes the progress updater
         *
         * @param {String|jQuery|HTMLElement} progressBar The element on which put the progress bar
         * @param {String|jQuery|HTMLElement} progressLabel The element on which put the progress label
         * @returns {progressUpdaters}
         */
        init: function(progressBar, progressLabel) {
            this.progressBar = $(progressBar).progressbar();
            this.progressLabel = $(progressLabel);
            return this;
        },

        /**
         * Writes the progress label and update the progress by ratio
         * @param {String} label
         * @param {Number} ratio
         * @returns {progressUpdaters}
         */
        write: function(label, ratio) {
            this.progressLabel.text(label);
            this.progressBar.progressbar('value', ratio);
            return this;
        },

        /**
         * Updates the progress bar
         * @param {Object} testContext The progression context
         * @returns {{ratio: number, label: string}}
         */
        update: function(testContext) {
            var progressIndicator = testContext.progressIndicator || 'percentage';
            var progressIndicatorMethod = progressIndicator + 'Progression';
            var getProgression = this[progressIndicatorMethod] || this.percentageProgression;
            var progression = getProgression && getProgression(testContext) || {};

            this.write(progression.label, progression.ratio);
            return progression;
        },

        /**
         * Updates the progress bar displaying the percentage
         * @param {Object} testContext The progression context
         * @returns {{ratio: number, label: string}}
         */
        percentageProgression: function(testContext) {
            var total = Math.max(1, testContext.numberItems);
            var ratio = Math.floor(testContext.numberCompleted / total * 100);
            return {
                ratio : ratio,
                label : ratio + '%'
            };
        },

        /**
         * Updates the progress bar displaying the position
         * @param {Object} testContext The progression context
         * @returns {{ratio: number, label: string}}
         */
        positionProgression: function(testContext) {
            var progressScope = testContext.progressIndicatorScope;
            var progressScopeCounter = {
                test : {
                    total : 'numberItems',
                    position : 'itemPosition'
                },
                testPart : {
                    total : 'numberItemsPart',
                    position : 'itemPositionPart'
                },
                testSection : {
                    total : 'numberItemsSection',
                    position : 'itemPositionSection'
                }
            };
            var counter = progressScopeCounter[progressScope] || progressScopeCounter.test;
            var total = Math.max(1, testContext[counter.total]);
            var position = testContext[counter.position] + 1;
            return {
                ratio : Math.floor(position / total * 100),
                label : __('Item %d of %d', position, total)
            };
        }
    };

    /**
     * Builds an instance of progressUpdaters
     * @param {String|jQuery|HTMLElement} progressBar The element on which put the progress bar
     * @param {String|jQuery|HTMLElement} progressLabel The element on which put the progress label
     * @returns {progressUpdaters}
     */
    var progressUpdaterFactory = function(progressBar, progressLabel) {
        var updater = _.clone(progressUpdaters, true);
        return updater.init(progressBar, progressLabel);
    };

    return progressUpdaterFactory;
});

/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA;
 *
 */

/**
 * Metadata to be sent to the server. Will be saved in result storage as a trace variable.
 * Usage example:
 * <pre>
 * var testMetaData = testMetaDataFactory({
 *   testServiceCallId : this.itemServiceApi.serviceCallId
 * });
 *
 * testMetaData.setData({
 *   'TEST' : {
 *      'TEST_EXIT_CODE' : 'T'
 *   },
 *   'SECTION' : {
 *      'SECTION_EXIT_CODE' : 704
 *   }
 * });
 *
 * testMetaData.addData({'ITEM' : {
 *      'ITEM_START_TIME_CLIENT' : 1443596730143,
 *      'ITEM_END_TIME_CLIENT' : 1443596731301
 *    }
 * });
 * </pre>
 *
 * Data for each service call id will be stored in local storage to be able get data
 * after reloading the page or resuming the test session.
 *
 * To clear all data related to current test_call_id used <i>clearData</i> method.
 */
define('taoQtiTest/testRunner/testMetaData',[
    'lodash'
], function (_) {
    'use strict';

    /**
     * @param {Object} options
     * @param {string} options.testServiceCallId - test call id.
     */
     var testMetaDataFactory = function testMetaDataFactory(options) {
        var _testServiceCallId,
            _storageKeyPrefix = 'testMetaData_',
            _data = {};

        if (!options || options.testServiceCallId === undefined) {
            throw new TypeError("testServiceCallId option is required");
        }

        var testMetaData = {
            SECTION_EXIT_CODE : {
                'COMPLETED_NORMALLY': 700,
                'QUIT': 701,
                'COMPLETE_TIMEOUT': 703,
                'TIMEOUT': 704,
                'FORCE_QUIT': 705,
                'IN_PROGRESS': 706,
                'ERROR': 300
            },
            TEST_EXIT_CODE : {
                'COMPLETE': 'C',
                'TERMINATED': 'T',
                'INCOMPLETE': 'IC',
                'INCOMPLETE_QUIT': 'IQ',
                'INACTIVE': 'IA',
                'CANDIDATE_DISAGREED_WITH_NDA': 'DA'
            },
            /**
             * Return test call id.
             * @returns {string}- Test call id
             */
            getTestServiceCallId : function getTestServiceCallId () {
                return _testServiceCallId;
            },

            /**
             * Set test call id.
             * @param {string} value
             */
            setTestServiceCallId : function setTestServiceCallId (value) {
                _testServiceCallId = value;
            },

            /**
             * Set meta data. Current data object will be overwritten.
             * @param {Object} data - metadata object
             */
            setData : function setData(data) {
                _data = data;
                setLocalStorageData(JSON.stringify(_data));
            },

            /**
             * Add data.
             * @param {Object} data - metadata object
             * @param {Boolean} overwrite - whether the same data should be overwritten. Default - <i>false</i>
             */
            addData : function addData(data, overwrite) {
                data = _.clone(data);
                if (overwrite === undefined) {
                    overwrite = false;
                }

                if (overwrite) {
                    _.merge(_data, data);
                } else {
                    _data = _.merge(data, _data);
                }
                setLocalStorageData(JSON.stringify(_data));
            },

            /**
             * Get the saved data.
             * The cloned object will be returned to avoid unwanted affecting of the original data.
             * @returns {Object} - metadata object.
             */
            getData : function getData() {
                return _.clone(_data);
            },

            /**
             * Clear all data saved in current object and in local storage related to current test call id.
             * @returns {Object} - metadata object.
             */
            clearData : function clearData() {
                _data = {};
                window.localStorage.removeItem(testMetaData.getLocalStorageKey());
            },

            getLocalStorageKey : function getLocalStorageKey () {
                return _storageKeyPrefix + _testServiceCallId;
            }
        };

        /**
         * Initialize test meta data manager
         */
        function init() {
            _testServiceCallId = options.testServiceCallId;
            testMetaData.setData(getLocalStorageData());
        }

        /**
         * Set data to local storage
         * @param {string} val - data to be stored.
         */
        function setLocalStorageData(val) {
            var currentKey = testMetaData.getLocalStorageKey();
            try {
                window.localStorage.setItem(currentKey, val);
            } catch(domException) {
                if (domException.name === 'QuotaExceededError' ||
                    domException.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    var removed = 0,
                        i = window.localStorage.length,
                        key;
                    while (i--) {
                        key  = localStorage.key(i);
                        if (/^testMetaData_.*/.test(key) && key !== currentKey) {
                            window.localStorage.removeItem(key);
                            removed++;
                        }
                    }
                    if (removed) {
                        setLocalStorageData(val);
                    } else {
                        throw domException;
                    }
                } else {
                    throw domException;
                }
            }
        }

        /**
         * Get data from local storage stored for current call id
         * @returns {*} saved data or empty object
         */
        function getLocalStorageData() {
            var data = window.localStorage.getItem(testMetaData.getLocalStorageKey()),
                result = JSON.parse(data) || {};

            return result;
        }

        init();

        return testMetaData;
    };

    return testMetaDataFactory;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2014 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
 */
define('serviceApi/ServiceApi',['jquery', 'urlParser'], function($, UrlParser){
    'use strict';

    /**
     * @constructor
     */
    function ServiceApi(baseUrl, parameters, serviceCallId, stateStorage, userService, paused){
        this.baseUrl = baseUrl;
        this.parameters = parameters;
        this.connected = false;

        this.serviceCallId = serviceCallId;
        this.state = stateStorage;
        this.userService = userService;
        this.hasBeenPaused = paused;
    }

    ServiceApi.SIG_SUCCESS = 0;
    ServiceApi.SIG_ERROR = 1;

    ServiceApi.prototype.loadInto = function(frame, connected){
        var self = this;
        var $frame = $(frame);
        var callUrl = this.getCallUrl();
        var isCORSAllowed = new UrlParser(callUrl).checkCORS();

        $frame.on('load', function(e){
             //if we are  in the same domain, we add a variable
             //to the frame window, so the frame knows it can communicate
             //with the parent
            $(document).on('serviceready', function(){
                self.connect(frame, function(){
                    $(document).off('serviceready');
                    if(typeof connected === 'function'){
                        connected();
                    }
                });
            });
             if(isCORSAllowed === true){
                 frame.contentWindow.__knownParent__ = true;
             }
         });

        $frame.attr('src', callUrl);
    };

    ServiceApi.prototype.connect = function(frame, connected){
        if(this.connected === false && frame.contentWindow){
            //frame.contentWindow.serviceApi = this;
            if (typeof(frame.contentWindow.onServiceApiReady) === "function") {
                frame.contentWindow.onServiceApiReady(this);
                this.connected = true;
                if(typeof connected === 'function'){
                    connected();
                }
            }
        }
    };

    /**
     * Get the service call URL
     * @returns {String} the URI
     */
    ServiceApi.prototype.getCallUrl = function(){
        var params = this.parameters || {};
        params.serviceCallId = this.serviceCallId;
        return this.baseUrl + '?' + $.param(params);
    };

    ServiceApi.prototype.getUserPropertyValues = function(property, callback){
    	this.userService.get(property, callback);
    };

    //Context
    ServiceApi.prototype.getServiceCallId = function(){
        return this.serviceCallId;
    };

    //Context
    ServiceApi.prototype.getState = function(){
        return this.state.get();
    };

    ServiceApi.prototype.setState = function(state, callback){
        return this.state.set(state, callback);
    };

    //Context
    ServiceApi.prototype.getHasBeenPaused = function(){
        return this.hasBeenPaused;
    };

    ServiceApi.prototype.setHasBeenPaused = function(paused){
        this.hasBeenPaused = paused;
    };

    // Variables
    ServiceApi.prototype.getParameter = function(identifier){
        if (typeof(this.parameters[identifier]) !== "undefined") {
            return this.parameters[identifier];
        } else {
            return null;
        }
    };

    /**
     * Sets a callback on the finish action
     * @param {Function} callback
     * @returns {ServiceApi}
     */
    ServiceApi.prototype.onFinish = function(callback) {
        this.onFinishCallback = callback;
        return this;
    };

    /**
     * Sets a callback on the kill action
     * @param {Function} callback
     * @returns {ServiceApi}
     */
    ServiceApi.prototype.onKill = function(callback) {
        this.onKillCallback = callback;
        return this;
    };

    /**
     * Sets a callback on the exit action
     * @param {Function} callback
     * @returns {ServiceApi}
     */
    ServiceApi.prototype.onExit = function(callback) {
        this.onExitCallback = callback;
        return this;
    };

    /**
     * @param {Function} callback - Function called if no dedicated callback is found
     */
    ServiceApi.prototype.kill = function(callback) {
    	if (typeof this.onKillCallback === 'function') {
    		this.onKillCallback(callback);
    	} else {
    		callback(0);
    	}
    };

    /**
     * Exits the flow
     * @param {Function} callback - Function called if no dedicated callback is found
     */
    ServiceApi.prototype.exit = function(callback) {
    	if (typeof this.onExitCallback === 'function') {
    		this.onExitCallback(callback);
    	} else {
    		callback(0);
    	}
    };

    /**
     * Finishes the flow
     * @param valueArray - return parameters of the service.
     */
    ServiceApi.prototype.finish = function(valueArray) {
        //return execution to service caller
        if (typeof this.onFinishCallback === 'function') {
                this.onFinishCallback(valueArray);
        }
    };

    return ServiceApi;

});

define('serviceApi/UserInfoService',['jquery'], function($){
    
    function UserInfoService(requestUrl, data) {
        this.data = data;
        this.requestUrl = requestUrl;
    }

    UserInfoService.prototype.get = function(property, callback){
        if (this.data.hasOwnProperty(property)) {
            if (typeof callback === "function") {
                    callback(this.data[property]);
            }
        } else {
            $.ajax({
                url : this.requestUrl,
                data 		: {
                    'property' : property
                },
                type        : 'post',
                dataType	: 'json',
                success     : (function(service, callback) {return function(r) {
            		for (key in r.data) {
            			service.data[key] = r.data[key];
            		}
                    if (typeof callback === "function") {
                        callback(service.data[property]);
                    }

                }})(this, callback)
                /*	
            	function(r){
                    if(r.success){
                    	console.log(this.data);
                    	this.data[property] = r.values;
                    	//console.log(this.data);
	                    if (typeof callback === "function") {
	                        callback(this.data[property]);
	                    }
                    }
                }
                */
                
                
            });
        }
    };

    return UserInfoService;
});
/**
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2013 (original work) Open Assessment Technologies SA ;
 */
define('serviceApi/StateStorage',['jquery'], function($){
    'use strict';
    
    function StateStorage(state, submitUrl) {
        this.state = state;
        this.submitUrl = submitUrl;
    }

    StateStorage.prototype.get = function(callback){
        if (typeof callback === 'function') {
                callback(this.state);
        }
        return this.state;
    };

    StateStorage.prototype.set = function(state, callback){

        if (state === this.state) {
            if (typeof callback === "function") {
                    callback();
            }
        } else {
            this.state = state;
            $.ajax({
                url : this.submitUrl,
                data 		: {
                    'state' : state
                },
                type        : 'post',
                dataType	: 'json',
                success     : typeof callback === "function" ? callback : null
            });
        }
    };

    return StateStorage;
});
/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; under version 2
 * of the License (non-upgradable).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Copyright (c) 2015 (original work) Open Assessment Technologies SA;
 *
 */

define('taoQtiTest/controller/runtime/testRunner',[
    'jquery',
    'lodash',
    'i18n',
    'module',
    'taoQtiTest/testRunner/actionBarTools',
    'taoQtiTest/testRunner/testReview',
    'taoQtiTest/testRunner/progressUpdater',
    'taoQtiTest/testRunner/testMetaData',
    'serviceApi/ServiceApi',
    'serviceApi/UserInfoService',
    'serviceApi/StateStorage',
    'iframeNotifier',
    'mathJax',
    'ui/feedback',
    'ui/deleter',
    'moment',
    'ui/modal',
    'ui/progressbar'
],
function (
    $,
    _,
    __,
    module,
    actionBarTools,
    testReview,
    progressUpdater,
    testMetaDataFactory,
    ServiceApi,
    UserInfoService,
    StateStorage,
    iframeNotifier,
    MathJax,
    feedback,
    deleter,
    moment,
    modal
) {

    'use strict';

    var timerIds = [],
        currentTimes = [],
        lastDates = [],
        timeDiffs = [],
        waitingTime = 0,
        $timers,
        $controls,
        timerIndex,
        testMetaData,
        sessionStateService,
        $doc = $(document),
        optionNextSection = 'x-tao-option-nextSection',
        optionNextSectionWarning = 'x-tao-option-nextSectionWarning',
        optionReviewScreen = 'x-tao-option-reviewScreen',
        optionEndTestWarning = 'x-tao-option-endTestWarning',
        optionNoExitTimedSectionWarning = 'x-tao-option-noExitTimedSectionWarning',
        TestRunner = {
            // Constants
            'TEST_STATE_INITIAL': 0,
            'TEST_STATE_INTERACTING': 1,
            'TEST_STATE_MODAL_FEEDBACK': 2,
            'TEST_STATE_SUSPENDED': 3,
            'TEST_STATE_CLOSED': 4,
            'TEST_NAVIGATION_LINEAR': 0,
            'TEST_NAVIGATION_NONLINEAR': 1,
            'TEST_ITEM_STATE_INTERACTING': 1,

            /**
             * Prepare a transition to another item
             * @param {Function} [callback]
             */
            beforeTransition: function (callback) {
                // Ask the top window to start the loader.
                iframeNotifier.parent('loading');

                // Disable buttons.
                this.disableGui();

                $controls.$itemFrame.hide();
                $controls.$rubricBlocks.hide();
                $controls.$timerWrapper.hide();

                // Wait at least waitingTime ms for a better user experience.
                if (typeof callback === 'function') {
                    setTimeout(callback, waitingTime);
                }
            },

            /**
             * Complete a transition to another item
             */
            afterTransition: function () {
                this.enableGui();

                //ask the top window to stop the loader
                iframeNotifier.parent('unloading');
                testMetaData.addData({
                    'ITEM' : {'ITEM_START_TIME_CLIENT' : Date.now() / 1000}
                });
            },

            /**
             * Jumps to a particular item in the test
             * @param {Number} position The position of the item within the test
             */
            jump: function(position) {
                var self = this,
                    action = 'jump',
                    params = {position: position};
                this.disableGui();

                if( this.isJumpOutOfSection(position)  && this.isCurrentItemActive() && this.isTimedSection() ){
                    this.exitTimedSection(action, params);
                } else {
                    this.killItemSession(function() {
                        self.actionCall(action, params);
                    });
                }
            },

            /**
             * Push to server how long user seen that item before to track duration
             * @param {Number} duration
             */
            keepItemTimed: function(duration){
                if (duration) {
                    var self = this,
                        action = 'keepItemTimed',
                        params = {duration: duration};
                    self.actionCall(action, params);
                }
            },

            /**
             * Marks an item for later review
             * @param {Boolean} flag The state of the flag
             * @param {Number} position The position of the item within the test
             */
            markForReview: function(flag, position) {
                var self = this;

                // Ask the top window to start the loader.
                iframeNotifier.parent('loading');

                // Disable buttons.
                this.disableGui();

                $.ajax({
                    url: self.testContext.markForReviewUrl,
                    cache: false,
                    async: true,
                    type: 'POST',
                    dataType: 'json',
                    data: {
                        flag: flag,
                        position: position
                    },
                    success: function(data) {
                        // update the item flagged state
                        if (self.testReview) {
                            self.testReview.setItemFlag(position, flag);
                            self.testReview.updateNumberFlagged(self.testContext, position, flag);
                            if (self.testContext.itemPosition === position) {
                                self.testContext.itemFlagged = flag;
                            }
                            self.updateTools(self.testContext);
                        }

                        // Enable buttons.
                        self.enableGui();

                        //ask the top window to stop the loader
                        iframeNotifier.parent('unloading');
                    }
                });
            },

            /**
             * Move to the next available item
             */
            moveForward: function () {
                var self = this,
                    action = 'moveForward';

                function doExitSection() {
                    if( self.isTimedSection() && !self.testContext.isTimeout){
                        self.exitTimedSection(action);
                    } else {
                        self.exitSection(action);
                    }
                }

                this.disableGui();

                if( (( this.testContext.numberItemsSection - this.testContext.itemPositionSection - 1) == 0) && this.isCurrentItemActive()){
                    if (this.shouldDisplayEndTestWarning()) {
                        this.displayEndTestWarning(doExitSection);
                        this.enableGui();
                    } else {
                        doExitSection();
                    }

                } else {
                    this.killItemSession(function () {
                        self.actionCall(action);
                    });
                }
            },

            /**
             * Check if necessary to display an end test warning
             */
            shouldDisplayEndTestWarning: function(){
                return (this.testContext.isLast === true && this.hasOption(optionEndTestWarning));
            },

            /**
             * Warns upon exiting test
             */
            displayEndTestWarning: function(nextAction){
                var options = {
                    confirmLabel: __('OK'),
                    cancelLabel: __('Cancel'),
                    showItemCount: false
                };

                this.displayExitMessage(
                    __('You are about to submit the test. You will not be able to access this test once submitted. Click OK to continue and submit the test.'),
                    nextAction,
                    options
                );
            },

            /**
             * Move to the previous available item
             */
            moveBackward: function () {
                var self = this,
                    action = 'moveBackward';

                this.disableGui();

                if( (this.testContext.itemPositionSection == 0) && this.isCurrentItemActive() && this.isTimedSection() ){
                    this.exitTimedSection(action);
                } else {
                this.killItemSession(function () {
                        self.actionCall(action);
                    });
                }
            },

            /**
             * Checks if a position is out of the current section
             * @param {Number} jumpPosition
             * @returns {Boolean}
             */
            isJumpOutOfSection: function(jumpPosition){
                var items = this.getCurrentSectionItems(),
                    isJumpToOtherSection = true,
                    isValidPosition = (jumpPosition >= 0) && ( jumpPosition < this.testContext.numberItems );

                if( isValidPosition){
                    for(var i in items ) {
                        if (!items.hasOwnProperty(i)) {
                            continue;
                        }
                        if( items[i].position == jumpPosition ){
                            isJumpToOtherSection = false;
                            break;
                        }
                    }
                } else {
                    isJumpToOtherSection = false;
                }

                return isJumpToOtherSection;
            },

            /**
             * Exit from the current section. Set the exit code.de
             * @param {String} action
             * @param {Object} params
             * @param {Number} [exitCode]
             */
            exitSection: function(action, params, exitCode){
                var self = this;

                testMetaData.addData({"SECTION" : {"SECTION_EXIT_CODE" : exitCode || testMetaData.SECTION_EXIT_CODE.COMPLETED_NORMALLY}});
                self.killItemSession(function () {
                    self.actionCall(action, params);
                });
            },

            /**
             * Tries to exit a timed section. Display a confirm message.
             * @param {String} action
             * @param {Object} params
             */
            exitTimedSection: function(action, params){
                var self = this,
                    qtiRunner = this.getQtiRunner(),
                    doExitTimedSection = function() {
                        if (qtiRunner) {
                            qtiRunner.updateItemApi();
                        }
                        self.exitSection(action, params);
                    };

                if ((action === 'moveForward' && this.shouldDisplayEndTestWarning())    // prevent duplicate warning
                    || this.hasOption(optionNoExitTimedSectionWarning)                  // check if warning is disabled
                    || this.testContext.keepTimerUpToTimeout                            // no need to display the message as we may be able to go back
                ) {
                    doExitTimedSection();
                } else {
                    this.displayExitMessage(
                        __('After you complete the section it would be impossible to return to this section to make changes. Are you sure you want to end the section?'),
                        doExitTimedSection,
                        { scope: 'testSection' }
                    );
                }

                this.enableGui();
            },

            /**
             * Tries to leave the current section and go to the next
             */
            nextSection: function(){
                var self = this;
                var qtiRunner = this.getQtiRunner();
                var doNextSection = function() {
                    self.exitSection('nextSection', null, testMetaData.SECTION_EXIT_CODE.QUIT);
                };

                if (qtiRunner) {
                    qtiRunner.updateItemApi();
                }

                if (this.hasOption(optionNextSectionWarning)) {
                    this.displayExitMessage(
                        __('After you complete the section it would be impossible to return to this section to make changes. Are you sure you want to end the section?'),
                        doNextSection,
                        { scope: 'testSection' }
                    );
                } else {
                    doNextSection();
                }

                this.enableGui();
            },

            /**
             * Gets the current progression within a particular scope
             * @param {String} [scope]
             * @returns {Object}
             */
            getProgression: function(scope) {
                var scopeSuffixMap = {
                    test : '',
                    testPart : 'Part',
                    testSection : 'Section'
                };
                var scopeSuffix = scope && scopeSuffixMap[scope] || '';

                return {
                    total : this.testContext['numberItems' + scopeSuffix] || 0,
                    answered : this.testContext['numberCompleted' + scopeSuffix] || 0,
                    viewed : this.testContext['numberPresented' + scopeSuffix] || 0,
                    flagged : this.testContext['numberFlagged' + scopeSuffix] || 0
                };
            },

            /**
             * Displays an exit message for a particular scope
             * @param {String} message
             * @param {Function} [action]
             * @param {Object} [options]
             * @param {String} [options.scope]
             * @param {String} [options.confirmLabel] - label of confirm button
             * @param {String} [options.cancelLabel] - label of cancel button
             * @param {Boolean} [options.showItemCount] - display the number of unanswered / flagged items in modal
             * @returns {jQuery} Returns the message box
             */
            displayExitMessage: function(message, action, options) {
                var self = this,
                    options = options || {},
                    scope = options.scope,
                    confirmLabel = options.confirmLabel || __('Yes'),
                    cancelLabel = options.cancelLabel || __('No'),
                    showItemCount = typeof options.showItemCount !== 'undefined' ? options.showItemCount : true;

                var $confirmBox = $('.exit-modal-feedback');
                var progression = this.getProgression(scope);
                var unansweredCount = (progression.total - progression.answered);
                var flaggedCount = progression.flagged;

                if (showItemCount) {
                    if (unansweredCount && this.isCurrentItemAnswered()) {
                        unansweredCount--;
                    }

                    if (flaggedCount && unansweredCount) {
                        message = __('You have %s unanswered question(s) and have %s item(s) marked for review.',
                                unansweredCount.toString(),
                                flaggedCount.toString()
                            ) + ' ' + message;
                    } else {
                        if (flaggedCount) {
                            message = __('You have %s item(s) marked for review.', flaggedCount.toString()) + ' ' + message;
                        }

                        if (unansweredCount) {
                            message = __('You have %s unanswered question(s).', unansweredCount.toString()) + ' ' + message;
                        }
                    }
                }

                $confirmBox.find('.message').html(message);
                $confirmBox.find('.js-exit-confirm').html(confirmLabel);
                $confirmBox.find('.js-exit-cancel').html(cancelLabel);
                $confirmBox.modal({ width: 500 });

                $confirmBox.find('.js-exit-cancel, .modal-close').off('click').on('click', function () {
                    $confirmBox.modal('close');
                });

                $confirmBox.find('.js-exit-confirm').off('click').on('click', function () {
                    $confirmBox.modal('close');
                    if (_.isFunction(action)) {
                        action.call(self);
                    }
                });

                return $confirmBox;
            },

            /**
             * Kill current item section and execute callback function given as first parameter.
             * Item end execution time will be stored in metadata object to be sent to the server.
             * @param {function} callback
             */
            killItemSession : function (callback) {
                testMetaData.addData({
                    'ITEM' : {
                        'ITEM_END_TIME_CLIENT' : Date.now() / 1000,
                        'ITEM_TIMEZONE' : moment().utcOffset(moment().utcOffset()).format('Z')
                    }
                });
                if (typeof callback !== 'function') {
                    callback = _.noop;
                }
                this.itemServiceApi.kill(callback);
            },

            /**
             * Checks if the current item is active
             * @returns {Boolean}
             */
            isCurrentItemActive: function(){
                return (this.testContext.itemSessionState !=4);
            },

            /**
             * Tells is the current item has been answered or not
             * The item is considered answered when at least one response has been set to not empty {base : null}
             *
             * @returns {Boolean}
             */
            isCurrentItemAnswered: function(){
                var answered = false;
                _.each(this.getCurrentItemState(), function(state){
                    if(state && _.isObject(state.response) && state.response.base !== null){
                        answered = true;//at least one response is not null so consider the item answered
                        return false;
                    }
                });
                return answered;
            },

            /**
             * Checks if a particular option is enabled for the current item
             * @param {String} option
             * @returns {Boolean}
             */
            hasOption: function(option) {
                return _.indexOf(this.testContext.categories, option) >= 0;
            },

            /**
             * Gets access to the qtiRunner instance
             * @returns {Object}
             */
            getQtiRunner: function(){
                var itemFrame = document.getElementById('qti-item');
                var itemWindow = itemFrame && itemFrame.contentWindow;
                var itemContainerFrame = itemWindow && itemWindow.document.getElementById('item-container');
                var itemContainerWindow = itemContainerFrame && itemContainerFrame.contentWindow;
                return itemContainerWindow && itemContainerWindow.qtiRunner;
            },

            /**
             * Checks if the current section is timed
             * @returns {Boolean}
             */
            isTimedSection: function(){
                var timeConstraints = this.testContext.timeConstraints,
                    isTimedSection = false;
                for( var index in timeConstraints ){
                    if(timeConstraints.hasOwnProperty(index) &&
                        timeConstraints[index].qtiClassName === 'assessmentSection' ){
                        isTimedSection = true;
                    }
                }

                return isTimedSection;
            },

            /**
             * Gets the list of items owned by the current section
             * @returns {Array}
             */
            getCurrentSectionItems: function(){
                var partId  = this.testContext.testPartId,
                    navMap  = this.testContext.navigatorMap,
                    sectionItems;

                for( var partIndex in navMap ){
                    if( !navMap.hasOwnProperty(partIndex)){
                        continue;
                    }
                    if( navMap[partIndex].id !== partId ){
                        continue;
                    }

                    for(var sectionIndex in navMap[partIndex].sections){
                        if( !navMap[partIndex].sections.hasOwnProperty(sectionIndex)){
                            continue;
                        }
                        if( navMap[partIndex].sections[sectionIndex].active === true ){
                            sectionItems = navMap[partIndex].sections[sectionIndex].items;
                            break;
                        }
                    }
                }

                return sectionItems;
            },

            /**
             * Skips the current item
             */
            skip: function () {
                var self = this,
                    doSkip = function() {
                        self.disableGui();
                        self.actionCall('skip');
                    };

                if (this.shouldDisplayEndTestWarning()) {
                    this.displayEndTestWarning(doSkip);
                } else {
                    doSkip();
                }
            },

            /**
             * Handles the timeout state
             */
            timeout: function () {
                var self = this;
                this.disableGui();
                this.testContext.isTimeout = true;
                this.updateTimer();

                this.killItemSession(function () {
                    var confirmBox = $('.timeout-modal-feedback'),
                        testContext = self.testContext,
                        confirmBtn = confirmBox.find('.js-timeout-confirm, .modal-close');

                    if (testContext.numberCompletedSection === testContext.numberItemsSection) {
                        testMetaData.addData({"SECTION" : {"SECTION_EXIT_CODE" : testMetaData.SECTION_EXIT_CODE.COMPLETE_TIMEOUT}});
                    } else {
                        testMetaData.addData({"SECTION" : {"SECTION_EXIT_CODE" : testMetaData.SECTION_EXIT_CODE.TIMEOUT}});
                    }

                    self.enableGui();
                    confirmBox.modal({width: 500});
                    confirmBtn.off('click').on('click', function () {
                        confirmBox.modal('close');
                        self.actionCall('timeout');
                    });
                });
            },

            /**
             * Sets the assessment test context object
             * @param {Object} testContext
             */
            setTestContext: function(testContext) {
                this.testContext = testContext;
                this.itemServiceApi = eval(testContext.itemServiceApiCall);
                this.itemServiceApi.setHasBeenPaused(testContext.hasBeenPaused);
            },


            /**
             * Handles Metadata initialization
             */
            initMetadata: function (){
                testMetaData = testMetaDataFactory({
                    testServiceCallId: this.itemServiceApi.serviceCallId
                });
            },

            /**
             * Retrieve service responsible for broken session tracking
             * @returns {*}
             */
            getSessionStateService: function () {
                if (!sessionStateService) {
                    sessionStateService = this.testContext.sessionStateService({accuracy: 1000});
                }
                return sessionStateService;
            },

            /**
             * Updates the GUI
             * @param {Object} testContext
             */
            update: function (testContext) {
                var self = this;
                $controls.$itemFrame.remove();

                var $runner = $('#runner');
                $runner.css('height', 'auto');

                this.getSessionStateService().restart();

                this.setTestContext(testContext);
                this.updateContext();
                this.updateProgress();
                this.updateNavigation();
                this.updateTestReview();
                this.updateInformation();
                this.updateRubrics();
                this.updateTools(testContext);
                this.updateTimer();
                this.updateExitButton();
                this.resetCurrentItemState();
                this.initMetadata();

                $controls.$itemFrame = $('<iframe id="qti-item" frameborder="0" scrollbars="no"/>');
                $controls.$itemFrame.appendTo($controls.$contentBox);

                if (this.testContext.itemSessionState === this.TEST_ITEM_STATE_INTERACTING && self.testContext.isTimeout === false) {
                    $doc.off('.testRunner').on('serviceloaded.testRunner', function () {
                        self.afterTransition();
                        self.adjustFrame();
                        $controls.$itemFrame.css({visibility: 'visible'});
                    });

                    // Inject API into the frame.
                    this.itemServiceApi.loadInto($controls.$itemFrame[0], function () {
                        // We now rely on the 'serviceloaded' event.
                    });
                }
                else {
                    // e.g. no more attempts or timeout! Simply consider the transition is finished,
                    // but do not load the item.
                    self.afterTransition();
                }
            },

            /**
             * Displays feedback on the current state of the test
             */
            updateInformation: function () {

                if (this.testContext.isTimeout === true) {
                    feedback().error(__('Time limit reached for item "%s".', this.testContext.itemIdentifier));
                }
                else if (this.testContext.itemSessionState !== this.TEST_ITEM_STATE_INTERACTING) {
                    feedback().error(__('No more attempts allowed for item "%s".', this.testContext.itemIdentifier));
                }
            },

            /**
             * Updates the displayed tools
             * @param {Object} testContext
             */
            updateTools: function updateTools(testContext) {
                var showSkip = false;
                var showSkipEnd = false;
                var showNextSection = !!testContext.nextSection && (this.hasOption(optionNextSection) || this.hasOption(optionNextSectionWarning));

                if (this.testContext.allowSkipping === true) {
                    if (this.testContext.isLast === false) {
                        showSkip = true;
                    } else {
                        showSkipEnd = true;
                    }
                }

                $controls.$skip.toggle(showSkip);
                $controls.$skipEnd.toggle(showSkipEnd);
                $controls.$nextSection.toggle(showNextSection);

                actionBarTools.render('.tools-box-list', testContext, TestRunner);
            },

            /**
             * Displays a timer
             * @param {Object} cst
             * @returns {*|jQuery|HTMLElement}
             */
            createTimer: function(cst) {
                var $timer = $('<div>', {'class': 'qti-timer qti-timer__type-' + cst.qtiClassName }),
                    $label = $('<div>', {'class': 'qti-timer_label truncate', text: cst.label }),
                    $time  = $('<div>', {'class': 'qti-timer_time', text: this.formatTime(cst.seconds) });

                $timer.append($label);
                $timer.append($time);
                return $timer;
            },

            /**
             * Updates the timers
             */
            updateTimer: function () {
                var self = this;
                var hasTimers;
                $controls.$timerWrapper.empty();

                for (var i = 0; i < timerIds.length; i++) {
                    clearTimeout(timerIds[i]);
                }

                timerIds = [];
                currentTimes = [];
                lastDates = [];
                timeDiffs = [];

                if (self.testContext.isTimeout === false &&
                    self.testContext.itemSessionState === self.TEST_ITEM_STATE_INTERACTING) {

                    hasTimers = !!this.testContext.timeConstraints.length;
                    $controls.$topActionBar.toggleClass('has-timers', hasTimers);

                    if (hasTimers) {

                        // Insert QTI Timers container.
                        // self.formatTime(cst.seconds)
                        for (i = 0; i < this.testContext.timeConstraints.length; i++) {

                            var cst = this.testContext.timeConstraints[i];

                            if (cst.allowLateSubmission === false) {

                                // Set up a timer for this constraint
                                $controls.$timerWrapper.append(self.createTimer(cst));

                                // Set up a timer and update it with setInterval.
                                currentTimes[i] = cst.seconds;
                                lastDates[i] = new Date();
                                timeDiffs[i] = 0;
                                timerIndex = i;

                                if (self.testContext.timerWarning && self.testContext.timerWarning[cst.qtiClassName]) {
                                    cst.warnings = {};
                                    _(self.testContext.timerWarning[cst.qtiClassName]).forEach(function (value, key) {
                                        if (_.contains(['info', 'warning', 'danger'], value)) {
                                            cst.warnings[key] = {
                                                type: value,
                                                showed: cst.seconds <= key,
                                                point: parseInt(key, 10)
                                            };
                                        }
                                    });
                                    var closestPreviousWarning = _.find(cst.warnings, { showed: true });
                                    if (!_.isEmpty(closestPreviousWarning) && closestPreviousWarning.point) {
                                        cst.warnings[closestPreviousWarning.point].showed = false;
                                    }
                                }

                                (function (timerIndex, cst) {
                                    timerIds[timerIndex] = setInterval(function () {

                                        timeDiffs[timerIndex] += (new Date()).getTime() - lastDates[timerIndex].getTime();

                                        if (timeDiffs[timerIndex] >= 1000) {
                                            var seconds = timeDiffs[timerIndex] / 1000;
                                            currentTimes[timerIndex] -= seconds;
                                            timeDiffs[timerIndex] = 0;
                                        }

                                        $timers.eq(timerIndex)
                                            .html(self.formatTime(Math.round(currentTimes[timerIndex])));

                                        if (currentTimes[timerIndex] <= 0) {
                                            // The timer expired...
                                            currentTimes[timerIndex] = 0;
                                            clearInterval(timerIds[timerIndex]);

                                            // Hide item to prevent any further interaction with the candidate.
                                            $controls.$itemFrame.hide();
                                            self.timeout();
                                        } else {
                                            lastDates[timerIndex] = new Date();
                                        }

                                        var warning = _.findLast(cst.warnings, { showed: false });

                                        if (!_.isEmpty(warning) && _.isFinite(warning.point) && currentTimes[timerIndex] <= warning.point) {
                                            self.timeWarning(cst, warning);
                                        }

                                    }, 1000);
                                }(timerIndex, cst));
                            }
                        }

                        $timers = $controls.$timerWrapper.find('.qti-timer .qti-timer_time');
                        $controls.$timerWrapper.show();
                    }
                }
            },

            /**
             * Mark appropriate timer by warning colors and show feedback message
             *
             * @param {object} cst - Time constraint
             * @param {integer} cst.warningTime - Warning time in seconds.
             * @param {integer} cst.qtiClassName - Class name of qti instance for which the timer is set (assessmentItemRef | assessmentSection | testPart | assessmentTest).
             * @param {integer} cst.seconds - Initial timer value.
             * @param {object} warning - Current actual warning
             * @param {integer} warning.point - Warning time point in seconds, when show message
             * @param {boolean} warning.showed - boolean flag for mark already showed warnings
             * @param {string} warning.type - type of warning (from config), can be info, warning or error
             *
             * @returns {undefined}
             */
            timeWarning: function (cst, warning) {
                var message = '',
                    remaining,
                    $timer = $controls.$timerWrapper.find('.qti-timer__type-' + cst.qtiClassName),
                    $time = $timer.find('.qti-timer_time');

                $time.removeClass('txt-info txt-warning txt-danger').addClass('txt-' + warning.type);

                remaining = moment.duration(warning.point, "seconds").humanize();

                switch (cst.qtiClassName) {
                    case 'assessmentItemRef':
                        message = __("Warning – You have %s remaining to complete this item.", remaining);
                        break;
                    case 'assessmentSection':
                        message = __("Warning – You have %s remaining to complete this section.", remaining);
                        break;
                    case 'testPart':
                        message = __("Warning – You have %s remaining to complete this test part.", remaining);
                        break;
                    case 'assessmentTest':
                        message = __("Warning – You have %s remaining to complete the test.", remaining);
                        break;
                }

                feedback()[warning.type](message);

                cst.warnings[warning.point].showed = true;
            },

            /**
             * Displays or hides the rubric block
             */
            updateRubrics: function () {
                $controls.$rubricBlocks.remove();

                if (this.testContext.rubrics.length > 0) {

                    $controls.$rubricBlocks = $('<div id="qti-rubrics"/>');

                    for (var i = 0; i < this.testContext.rubrics.length; i++) {
                        $controls.$rubricBlocks.append(this.testContext.rubrics[i]);
                    }

                    // modify the <a> tags in order to be sure it
                    // opens in another window.
                    $controls.$rubricBlocks.find('a').bind('click keypress', function () {
                        window.open(this.href);
                        return false;
                    });

                    $controls.$rubricBlocks.prependTo($controls.$contentBox);

                    if (MathJax) {
                        MathJax.Hub.Queue(["Typeset", MathJax.Hub], $controls.$rubricBlocks[0]);
                    }

                }
            },

            /**
             * Updates the list of navigation buttons (previous, next, skip, etc.)
             */
            updateNavigation: function () {
                $controls.$exit.show();

                if(this.testContext.isLast === true) {
                    $controls.$moveForward.hide();
                    $controls.$moveEnd.show();
                }
                else {
                    $controls.$moveForward.show();
                    $controls.$moveEnd.hide();
                }
                if (this.testContext.navigationMode === this.TEST_NAVIGATION_LINEAR) {
                    // LINEAR
                    $controls.$moveBackward.hide();
                }
                else {
                    // NONLINEAR
                    $controls.$controls.show();
                    if(this.testContext.canMoveBackward === true) {
                        $controls.$moveBackward.show();
                    }
                    else {
                        $controls.$moveBackward.hide();
                    }
                }
            },

            /**
             * Updates the test taker review screen
             */
            updateTestReview: function() {
                var considerProgress = this.testContext.considerProgress === true;

                if (this.testReview) {
                    this.testReview.toggle(considerProgress && this.hasOption(optionReviewScreen));
                    this.testReview.update(this.testContext);
                }
            },

            /**
             * Updates the progress bar
             */
            updateProgress: function () {
                var considerProgress = this.testContext.considerProgress === true;

                $controls.$progressBox.css('visibility', considerProgress ? 'visible' : 'hidden');

                if (considerProgress) {
                    this.progressUpdater.update(this.testContext);
                }
            },

            /**
             * Updates the test informations
             */
            updateContext: function () {

                $controls.$title.text(this.testContext.testTitle);

                // Visibility of section?
                var sectionText = (this.testContext.isDeepestSectionVisible === true) ? (' - ' + this.testContext.sectionTitle) : '';

                $controls.$position.text(sectionText);
                $controls.$titleGroup.show();
            },

            /**
             * Displays the right exit button
             */
            updateExitButton : function(){

                $controls.$logout.toggleClass('hidden', !this.testContext.logoutButton);
                $controls.$exit.toggleClass('hidden', !this.testContext.exitButton);
            },

            /**
             * Ensures the frame has the right size
             */
            adjustFrame: function () {
                var rubricHeight = $controls.$rubricBlocks.outerHeight(true) || 0;
                var frameContentHeight;
                var finalHeight = $(window).innerHeight() - $controls.$topActionBar.outerHeight() - $controls.$bottomActionBar.outerHeight();
                var itemFrame = $controls.$itemFrame.get(0);
                $controls.$contentBox.height(finalHeight);
                if($controls.$sideBars.length){
                    $controls.$sideBars.each(function() {
                        var $sideBar = $(this);
                        $sideBar.height(finalHeight - $sideBar.outerHeight() + $sideBar.height());
                    });
                }

                if(itemFrame && itemFrame.contentWindow){
                    frameContentHeight = $controls.$itemFrame.contents().outerHeight(true);

                    if (frameContentHeight < finalHeight) {
                        if (rubricHeight) {
                            frameContentHeight = Math.max(frameContentHeight, finalHeight - rubricHeight);
                        } else {
                            frameContentHeight = finalHeight;
                        }
                    }
                    if (itemFrame.contentWindow.$) {
                        itemFrame.contentWindow.$('body').trigger('setheight', [frameContentHeight]);
                    }
                    $controls.$itemFrame.height(frameContentHeight);
                }
            },

            /**
             * Locks the GUI
             */
            disableGui: function () {
                $controls.$naviButtons.addClass('disabled');
                if (this.testReview) {
                    this.testReview.disable();
                }
            },

            /**
             * Unlocks the GUI
             */
            enableGui: function () {
                $controls.$naviButtons.removeClass('disabled');
                if (this.testReview) {
                    this.testReview.enable();
                }
            },

            /**
             * Hides the GUI
             */
            hideGui: function () {
                $controls.$naviButtons.addClass('hidden');
                if (this.testReview) {
                    this.testReview.hide();
                }
            },

            /**
             * Shows the GUI
             */
            showGui: function () {
                $controls.$naviButtons.removeClass('hidden');
                if (this.testReview) {
                    this.testReview.show();
                }
            },

            /**
             * Formats a timer
             * @param {Number} totalSeconds
             * @returns {String}
             */
            formatTime: function (totalSeconds) {
                var sec_num = totalSeconds;
                var hours = Math.floor(sec_num / 3600);
                var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
                var seconds = Math.floor(sec_num - (hours * 3600) - (minutes * 60));

                if (hours < 10) {
                    hours = "0" + hours;
                }
                if (minutes < 10) {
                    minutes = "0" + minutes;
                }
                if (seconds < 10) {
                    seconds = "0" + seconds;
                }

                var time = hours + ':' + minutes + ':' + seconds;

                return time;
            },

            /**
             * Processes an error
             * @param {Object} error
             */
            processError : function processError(error) {
                var self = this;

                // keep disabled
                this.hideGui();
                this.beforeTransition();

                // ask the parent to display a message
                iframeNotifier.parent('messagealert', {
                    message : error.message,
                    action : function() {
                        if (testMetaData) {
                            testMetaData.clearData();
                        }
                        if (error.state === self.TEST_STATE_CLOSED) {
                            // test is closed, finish it
                            self.serviceApi.finish();
                        } else {
                            // test is still open, just exit to the index
                            self.serviceApi.exit();
                        }
                    }
                });
            },

            /**
             * Call action specified in testContext. A postfix <i>Url</i> will be added to the action name.
             * To specify actions see {@link https://github.com/oat-sa/extension-tao-testqti/blob/master/helpers/class.TestRunnerUtils.php}
             * @param {String} action - Action name
             * @param {Object} [extraParams] - Additional parameters to be sent to the server
             * @returns {undefined}
             */
            actionCall: function (action, extraParams) {
                var self = this,
                    params = {metaData: testMetaData ? testMetaData.getData() : {}};

                if (extraParams) {
                    params = _.assign(params, extraParams);
                }
                this.beforeTransition(function () {
                    $.ajax({
                        url: self.testContext[action + 'Url'],
                        cache: false,
                        data: params,
                        async: true,
                        dataType: 'json',
                        success: function (testContext) {
                            testMetaData.clearData();

                            if (!testContext.success) {
                                self.processError(testContext);
                            }
                            else if (testContext.state === self.TEST_STATE_CLOSED) {
                                self.serviceApi.finish();
                            }
                            else {
                                self.update(testContext);
                            }
                        }
                    });
                });
            },

            /**
             * Exit from test (after confirmation). All answered questions will be submitted.
             *
             * @returns {undefined}
             */
            exit: function () {
                var self = this;
                testMetaData.addData({
                    "TEST" : {"TEST_EXIT_CODE" : testMetaData.TEST_EXIT_CODE.INCOMPLETE},
                    "SECTION" : {"SECTION_EXIT_CODE" : testMetaData.SECTION_EXIT_CODE.QUIT}
                });
                this.displayExitMessage(
                    __('Are you sure you want to end the test?'),
                    function() {
                    self.killItemSession(function () {
                        self.actionCall('endTestSession');
                        testMetaData.clearData();
                    });
                    },
                    { scope: this.testReview ? this.testContext.reviewScope : null }
                );
            },

            /**
             * Set the state of the current item in the test runner
             *
             * @param {string} id
             * @param {object} state
             */
            setCurrentItemState : function(id, state){
                if(id){
                    this.currentItemState[id] = state;
                }
            },

            /**
             * Reset the state of the current item in the test runner
             */
            resetCurrentItemState : function(){
                this.currentItemState = {};
            },

            /**
             * Get the state of the current item as stored in the test runner
             * @returns {Object}
             */
            getCurrentItemState : function(){
                return this.currentItemState;
            }
        };

        var config = module.config();
        if (config) {
            actionBarTools.register(config.qtiTools);
        }

        return {
            start: function (testContext) {

                $controls = {
                    // navigation
                    $moveForward: $('[data-control="move-forward"]'),
                    $moveEnd: $('[data-control="move-end"]'),
                    $moveBackward: $('[data-control="move-backward"]'),
                    $nextSection: $('[data-control="next-section"]'),
                    $skip: $('[data-control="skip"]'),
                    $skipEnd: $('[data-control="skip-end"]'),
                    $exit: $(window.parent.document).find('[data-control="exit"]'),
                    $logout: $(window.parent.document).find('[data-control="logout"]'),
                    $naviButtons: $('.bottom-action-bar .action'),
                    $skipButtons: $('.navi-box .skip'),
                    $forwardButtons: $('.navi-box .forward'),

                    // progress bar
                    $progressBar: $('[data-control="progress-bar"]'),
                    $progressLabel: $('[data-control="progress-label"]'),
                    $progressBox: $('.progress-box'),

                    // title
                    $title:  $('[data-control="qti-test-title"]'),
                    $position:  $('[data-control="qti-test-position"]'),

                    // timers
                    $timerWrapper:  $('[data-control="qti-timers"]'),

                    // other zones
                    $contentPanel: $('.content-panel'),
                    $controls: $('.qti-controls'),
                    $itemFrame: $('#qti-item'),
                    $rubricBlocks: $('#qti-rubrics'),
                    $contentBox: $('#qti-content'),
                    $sideBars: $('.test-sidebar'),
                    $topActionBar: $('.horizontal-action-bar.top-action-bar'),
                    $bottomActionBar: $('.horizontal-action-bar.bottom-action-bar')
                };

                // title
                $controls.$titleGroup = $controls.$title.add($controls.$position);

                $doc.ajaxError(function (event, jqxhr) {
                    if (jqxhr.status === 403) {
                        iframeNotifier.parent('serviceforbidden');
                    }
                });

                window.onServiceApiReady = function onServiceApiReady(serviceApi) {
                    TestRunner.serviceApi = serviceApi;

                    if (!testContext.success) {
                        TestRunner.processError(testContext);
                    }

                    // If the assessment test session is in CLOSED state,
                    // we give the control to the delivery engine by calling finish.
                    else if (testContext.state === TestRunner.TEST_STATE_CLOSED) {
                        serviceApi.finish();
                        testMetaData.clearData();
                    }
                    else {

                        if (TestRunner.getSessionStateService().getDuration()) {
                            TestRunner.setTestContext(testContext);
                            TestRunner.initMetadata();

                            TestRunner.keepItemTimed(TestRunner.getSessionStateService().getDuration());
                            TestRunner.getSessionStateService().restart();
                        } else {
                            TestRunner.update(testContext);
                        }
                    }
                };

                TestRunner.beforeTransition();
                TestRunner.testContext = testContext;

                $controls.$skipButtons.click(function () {
                    if (!$(this).hasClass('disabled')) {
                        TestRunner.skip();
                    }
                });

                $controls.$forwardButtons.click(function () {
                    if (!$(this).hasClass('disabled')) {
                        TestRunner.moveForward();
                    }
                });

                $controls.$moveBackward.click(function () {
                    if (!$(this).hasClass('disabled')) {
                        TestRunner.moveBackward();
                    }
                });

                $controls.$nextSection.click(function () {
                    if (!$(this).hasClass('disabled')) {
                        TestRunner.nextSection();
                    }
                });

                $controls.$exit.click(function (e) {
                    e.preventDefault();
                    TestRunner.exit();
                });

                $(window).on('resize', _.throttle(function () {
                    TestRunner.adjustFrame();
                    $controls.$titleGroup.show();
                }, 250));

                $doc.on('loading', function () {
                    iframeNotifier.parent('loading');
                });


                $doc.on('unloading', function () {
                    iframeNotifier.parent('unloading');
                });

                TestRunner.progressUpdater = progressUpdater($controls.$progressBar, $controls.$progressLabel);

                if (testContext.reviewScreen) {
                    TestRunner.testReview = testReview($controls.$contentPanel, {
                        region: testContext.reviewRegion || 'left',
                        hidden: !TestRunner.hasOption(optionReviewScreen),
                        reviewScope: testContext.reviewScope,
                        preventsUnseen: !!testContext.reviewPreventsUnseen,
                        canCollapse: !!testContext.reviewCanCollapse
                    }).on('jump', function(event, position) {
                        TestRunner.jump(position);
                    }).on('mark', function(event, flag, position) {
                        TestRunner.markForReview(flag, position);
                    });
                    $controls.$sideBars = $('.test-sidebar');
                }

                TestRunner.updateProgress();
                TestRunner.updateTestReview();

                iframeNotifier.parent('serviceready');


                TestRunner.adjustFrame();

                $controls.$topActionBar.add($controls.$bottomActionBar).animate({ opacity: 1 }, 600);

                deleter($('#feedback-box'));
                modal($('body'));

                //listen to state change in the current item
                $(document).on('responsechange', function(e, responseId, response){
                    if(responseId && response){
                        TestRunner.setCurrentItemState(responseId, {response:response});
                    }
                }).on('stateready', function(e, id, state){
                    if(id && state){
                        TestRunner.setCurrentItemState(id, state);
                    }
                }).on('heightchange', function(e, height) {
                    $controls.$itemFrame.height(height);
                });

            }
        };
    });


//# sourceMappingURL=controllers.min.js.map